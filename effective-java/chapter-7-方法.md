### 方法

#### 第 38 条: 检查参数的有效性
绝大多数方法和构造器对于传递给它们的参数值都会有某些限制, 例如索引值必须是非负数, 对象引用不能为 null 等等; 这些应该在文档中清楚的指明, 并且在方法体的开头处检查参数, 以强制施加这些限制; 这是 "应该在发生错误之后尽快检测出错误" 这一普遍原则的一个具体情形; 如果不能做到这一点, 检测到错误的可能性就比较小了, 即使检测到了错误, 也较难确定错误的根源   
不要从本条目内容得出这样的结论: 对参数的任何限制都是好事; 相反, 在设计方法时, 应该使它们尽可能的通用, 并符合实际的需要; 假如方法对于它能接受的所有参数值能够完成合理的工作, 对参数的限制越少越好

#### 第 39 条: 必要时进行保护性拷贝
使 Java 使用起来如此舒适的一个因素在于它是一门安全的语言 (safe language), 并不像 C 或者 C++ 那样把内存当作一个巨大的数组来看待, 所以对于内存破坏的错误都可以免疫; 但即使在安全的语言中, 如果不采取一点措施, 还是无法与其他类隔离开来; 假设客户端尽其所能的来破坏, 或者对 API 的误用所导致的不可预期的情况, 都只好由类来处理; 编写一些面对客户的不良行为时仍能保持健壮的类, 这是非常值得投入的事情  
没有对象的帮助, 另一个类不可能修改对象的内部状态, 但是对象很容易在无意识的情况下提供这种帮助; 考虑以下的类, 声称可以表示一段不可变的时间周期
```
// Broken "immutable" time period class
public final class Period {
    private final Date start;
    private final Date end;

    public Period(Date start, Date end) {

        this.start = start;
        this.end = end;
    }

    public Date start() {
        retuen start;
    }

    public Date end() {
       return end;
    }
    ...
}
```
乍一看这个类是不可变的, 然而因为 Date 类本身是可变的, 因此很容易违反这个条件; 为了保护 Period 实例的内部信息避免受到这种攻击, 首先对于构造器的每个可变参数进行保护性拷贝 (defensive copy) 是必要的, 并且使用备份对象作为 Period 实例的组件, 而不适用原始的对象
```
// Required constructor - makes defensive copies of parameters
public Period(Date start, Date end) {
    this.start = new Date(start.getTime());
    this.end = new Date(end.getTime);

    if (start.comparaTo(end) > 0) {
        throw new IllegalArgumentException(start + "after" + end);
    }
}
```
用了新的构造器后, 外部对于传递给构造器的 Date 对象的修改不会影响到 Period 实例; 注意, 保护性拷贝是在检查参数的有效性 (见第 38 条) 之前进行的, 并且有效性检查是针对拷贝州的对象, 而不是针对原始的对象; 这样看起来有点不太自然, 但却是有必要的; 这样做可以避免在 "危险阶段" 期间从另一个线程改变类的参数, 这里的危险阶段是指从检查参数开始直到拷贝参数之间的时间段 (在计算机安全社区中, 被称作 Time-Of-Check/Time-Of-Use 或者 TOCTOU 攻击)  
同时也注意, 这里没有使用 Date 的 clone 方法来进行保护性拷贝, 因为 Date 是非 final 的, 不能保证 clone 方法一定返回类为 java.util.Date 的对象: 有可能返回专门处于恶意目的而设计的不可信子类的实例; 例如, 这样的子类可以在每个实例被创建的时候, 把指向该实例的引用记录到一个私有的静态列表中, 并且允许攻击者访问列表, 这将使得攻击者可以控制所有实例; 为了阻止这种攻击, 对于类型参数可以被不可信任子类化的参数, 不要使用 clone 方法进行保护性拷贝  
虽然构造方法成功避免了攻击, 但实例域的访问方法被外部访问, 仍有可能改变实例域的值; 为了防止这种攻击, 需要修改实例域的访问方法
```
// Required accessors - make defensive copies of internal fields
public Date start() {
    return new Date(start.getTime());
}

public Date end() {
    return new Date(end.getTime());
}
```
采用了新的构造器和新的访问方法后, Period 实例域被封装在对象的内部; 访问方法与构造器不同, 它们在进行保护性拷贝时可以使用 clone 方法, 因为可以保证 Period 内部的 Date 对象是 java.util.Date, 而不可能是其他的某个潜在的不可信子类; 对象的内部组件在返回给客户端之前, 应该考虑是否进行保护性拷贝; 对于长度非零的数组总是可变的, 因此把内存不数组返回给客户端之前, 应该进行保护性拷贝, 另外一种解决方案是返回该数组的不可变视图, 这两种方法见第 13 条  
以上启示在于, 只要有可能都应该使用不可变的对象作为对象内部组件, 这样就不必再进行保护性拷贝; Period 类可将 Date 域变成 long 类型表示, 这样就可以避免保护性拷贝; 如果类所包含的方法或者构造器的调用需要移交对象的控制权, 这个类就无法让自身抵御恶意的客户端, 只能靠类与客户端之间的信任  
简而言之, 如果类具有从客户端得到或着返回到客户端的可变组件, 类就必须保护性拷贝这些组件, 如果拷贝的成本受限制, 并且类信任客户端不会不恰当的修改组件, 就可以在文档中指明客户端的指责是不得修改受影响的组件, 依此来代替保护性拷贝

#### 第 40 条: 谨慎设计方法签名
- 谨慎的的选择方法的名称
方法名称应该时钟遵循标准的命名习惯; 首要目标是选择容易理解的, 并且与同一个包中的其他名称风格一致的名称; 第二个目标应该是选择与大众认可的相一致的名称
- 不要过于追求提供便利的方法
每个方法都应该尽其所能, 方法太多会使类难以学习, 使用, 测试, 维护; 对于接口和类所支持的每个动作, 都提供一个功能齐全的方法, 只有当一项操作经常被用到的时候, 才考虑为它提供快捷方式, 如果不能确定还是不提供的好
- 避免过长的参数列表
目标是不多于四个参数, 如果编写的许多方法都超过了这个限制, 那么 API 就会变得不好使用, 需要经常的查看文档; 相同类型的长参数序列格外有害, 会难以记住参数的顺序而导致出错

有三种方法可以缩短过长的参数列表; 第一种是把方法分解成多个方法, 每个方法只需要这些参数的一些子集, 如果这样做不小心导致了方法过多, 可以通过提升方法的正交性来减少方法的数目; 第二个方法时创建辅助类, 用来保存参数的分组, 这些辅助类一般为静态成员类 (见第 22 条), 如果一个频繁出现的参数序列可以被看作是代表了某个独特的实体, 则建议使用这种方法; 第三种方法是从对象构建到方法调用都采用 Builder 模式 (见第 2 条), 如果方法带有多个参数, 尤其是当它们中有些是可选的使用, 最好定义一个对象来表示所有参数, 并允许客户端在这个对象上进行多次 "setter" 调用, 每次调用都设置一个参数, 或者设置一个较小的相关的集合
