### 通用程序设计

#### 第 45 条: 将局部变量的作用域最小化
本条目与第 13 条 (使类和成员的可访问性最小化) 本质上是类似的, 将局部变量的作用域最小化, 可以增强代码的可读性和可维护性, 并降低出错的可能性  
要使局部变量的作用域最小化, 最有力的方法就是在第一次使用它的地方声明; 几乎每个局部变量的声明都应该包含一个初始化表达式, 如果还没有足够的信息来对一个变量初始化, 就应该推迟这个声明, 直到可以初始化为止; 这条规则有个例外的情况是与 try-catch 语句有关, 如果一个变量被一个方法初始化, 而这个方法会抛出一个受检异常, 该变量就必须在 try 块的内部初始化, 如果变量的值必须在 try 块的外部被使用到, 就必须在 try 块之前被声明, 但是在 try 块之前还不能被 "有意义的初始化"  
循环中提供了特殊的机会来将变量的作用域最小化 (无论是传统的还是 for-each 形式的), for 循环都允许声明循环变量, 它们的作用域被限定在正好需要的范围内; 因此, 如果在循环终止后不再需要循环变量的内容, for 循环就优先于 while 循环

#### 第 46 条: for-each 循环优先于传统的 for 循环
在 Java 1.5 发行版本之前, 对集合进行遍历的首选做法如下
```
// No longer the prefered idiom to Iterate over a collection
for (Iterator i = c.iterator(); i.hasNext(); ) {
    doSomething((Element) i.next());
}
```
遍历数组的首选做法如下
```
// No longer the prefered idiom to Iterate over a array
for (int i = 0; i < a.length; i++) {
    doSomething(a[i];
}
```
这些做法都比 while 循环要好 (见第 45 条), 但是也并不完美, 迭代器和索引变量都会造成一些混乱, 这也代表着出错的可能性; Java 1.5 发行版本引入了 for-each 循环, 通过完全隐藏迭代器或者索引变量, 避免了混乱和出错的可能
```
// The prefered  idiom to Iterate over collections and arrays
for (Element e : elements) {
    doSomething(e);
}
```
利用 for-each 循环不会有性能损失, 甚至用于数组也一样, 实际上某些情况下, 比起普通的 for 循环, 还稍具有性能优势, 因为它对数组索引的边界值只计算一次; for-each 循环不仅可以变量集合和数组, 还可以变量任何实现了 Iterable 接口的对象  
总之, for-each 循环的简洁性和预防 Bug 方面都有着传统的 for 循环无法比拟的优势, 而且没有性能损失, 应该尽可能的使用 for-each 循环; 遗憾的是以下三种情况无法使用 for-each 循环
- 过滤
如果集合需要遍历, 并删除选定的元素, 就需要使用显示的迭代器, 以便可以调用它的 remove 方法
- 转换
如果需要遍历列表或者数组, 并取代它部分或者全部的元素值
- 平行迭代
如果需要并行的遍历多个集合, 就需要显示的控制迭代器或者索引变量, 以便所有迭代器或者索引变量都可以得到同步前移

#### 第 47 条: 了解和使用类库
TODO

#### 第 48 条: 如果需要精确的答案, 请避免使用 float 和 double
float 和 double 类型主要是为了科学计算和工程计算而设计的; 它们执行二进制浮点运算, 这是为了在广泛的数值范围上提供较为精确的快速近似计算而精心设计的; 然而它们并没有提供完全精确的结果, 所以不应该被用于需要精确计算的场合; floa 和 double 类型尤其不适合用于货币计算, 通常使用 BigDecimal 来计算精确的值; 如果性能非常关键, 又不介意自己记录十进制小数点, 而且所涉及的数值又不大, 就可以使用 int 或 long 代替; 数值没有超过 9 位的就可以使用 int, 如果不超过 18 位数字就可以使用 long, 如果数值超过了 18 位就必须使用 BigDecimal

#### 第 49 条: 基本类型优先于装箱基本类型
