### 通用程序设计

#### 第 45 条: 将局部变量的作用域最小化
本条目与第 13 条 (使类和成员的可访问性最小化) 本质上是类似的, 将局部变量的作用域最小化, 可以增强代码的可读性和可维护性, 并降低出错的可能性  
要使局部变量的作用域最小化, 最有力的方法就是在第一次使用它的地方声明; 几乎每个局部变量的声明都应该包含一个初始化表达式, 如果还没有足够的信息来对一个变量初始化, 就应该推迟这个声明, 直到可以初始化为止; 这条规则有个例外的情况是与 try-catch 语句有关, 如果一个变量被一个方法初始化, 而这个方法会抛出一个受检异常, 该变量就必须在 try 块的内部初始化, 如果变量的值必须在 try 块的外部被使用到, 就必须在 try 块之前被声明, 但是在 try 块之前还不能被 "有意义的初始化"  
循环中提供了特殊的机会来将变量的作用域最小化 (无论是传统的还是 for-each 形式的), for 循环都允许声明循环变量, 它们的作用域被限定在正好需要的范围内; 因此, 如果在循环终止后不再需要循环变量的内容, for 循环就优先于 while 循环

#### 第 46 条: for-each 循环优先于传统的 for 循环
在 Java 1.5 发行版本之前, 对集合进行遍历的首选做法如下
```
// No longer the prefered idiom to Iterate over a collection
for (Iterator i = c.iterator(); i.hasNext(); ) {
    doSomething((Element) i.next());
}
```
遍历数组的首选做法如下
```
// No longer the prefered idiom to Iterate over a array
for (int i = 0; i < a.length; i++) {
    doSomething(a[i];
}
```
这些做法都比 while 循环要好 (见第 45 条), 但是也并不完美, 迭代器和索引变量都会造成一些混乱, 这也代表着出错的可能性; Java 1.5 发行版本引入了 for-each 循环, 通过完全隐藏迭代器或者索引变量, 避免了混乱和出错的可能
```
// The prefered  idiom to Iterate over collections and arrays
for (Element e : elements) {
    doSomething(e);
}
```
利用 for-each 循环不会有性能损失, 甚至用于数组也一样, 实际上某些情况下, 比起普通的 for 循环, 还稍具有性能优势, 因为它对数组索引的边界值只计算一次; for-each 循环不仅可以变量集合和数组, 还可以变量任何实现了 Iterable 接口的对象  
总之, for-each 循环的简洁性和预防 Bug 方面都有着传统的 for 循环无法比拟的优势, 而且没有性能损失, 应该尽可能的使用 for-each 循环; 遗憾的是以下三种情况无法使用 for-each 循环
- 过滤
如果集合需要遍历, 并删除选定的元素, 就需要使用显示的迭代器, 以便可以调用它的 remove 方法
- 转换
如果需要遍历列表或者数组, 并取代它部分或者全部的元素值
- 平行迭代
如果需要并行的遍历多个集合, 就需要显示的控制迭代器或者索引变量, 以便所有迭代器或者索引变量都可以得到同步前移

#### 第 47 条: 了解和使用类库
TODO

#### 第 48 条: 如果需要精确的答案, 请避免使用 float 和 double
float 和 double 类型主要是为了科学计算和工程计算而设计的; 它们执行二进制浮点运算, 这是为了在广泛的数值范围上提供较为精确的快速近似计算而精心设计的; 然而它们并没有提供完全精确的结果, 所以不应该被用于需要精确计算的场合; floa 和 double 类型尤其不适合用于货币计算, 通常使用 BigDecimal 来计算精确的值; 如果性能非常关键, 又不介意自己记录十进制小数点, 而且所涉及的数值又不大, 就可以使用 int 或 long 代替; 数值没有超过 9 位的就可以使用 int, 如果不超过 18 位数字就可以使用 long, 如果数值超过了 18 位就必须使用 BigDecimal

#### 第 49 条: 基本类型优先于装箱基本类型
Java 系统中的类型由两部分组成, 包含基本类型 (primitive) 和引用类型 (reference type), 但每个基本类型都有一个对应的引用类型, 称作是装箱基本类型 (boxed primitive); Java 1.5 发行本版中增加了自动装箱 (autoboxing) 和自动拆箱 (auto-unboxing), 如第 5 条所述, 这些特性模糊了但并没有完全抹去基本类型和装箱基本类型之间的区别  
在基本类型和装箱基本类型之间有三个主要区别
- 基本类型只有值, 而装箱基本类型则具有与它们的值不同的同一性, 即两个装箱基本类型可以具有相同的值和不同的同一性
- 基本类型只有功能完备的值, 而每个装箱基本类型除了它对应的基本类型的功能值之外, 还有非功能值: null
- 基本类型通常比装箱基本类型更节省时间和空间

考虑下面这个比较器, 被设计用来表示 Integer 值的递增数字顺序
```
// Broken Comparator - can you stop the flaw?
Comparator<Integer> naturalOrder = new Comparator<Integer>() {
    public int compare(Integer first, Integer second) {
        return first < second ? -1 : (first == second ? 0 : 1)
    }
}
```
这个比较器开起来是可以运行的, 但是当是两个基本值相同的装箱基本类型时, 应该返回为 0, 但是却会返回 1; < 的操作做了自动拆箱, 但是 == 的操作并没有, 所以返回了错误的值  
接下来, 考虑这个小程序
```
public class Unbelievable {
    static Integer i;

    public static void main(String[] args) {
        if (i == 42) {
            System.out.println("Unbelievable");
        }
    }
}
```
由于 i 未被初始化, 自动拆箱是 null 对象引用, 则会抛出 NullPointerException  
最后考虑第 5 条中的这个程序
```
// Hideously slow program! Can you spot the object creation?
public static void main(String[] args) {
    Long sum = 0;
    for(long i = 0; i < Interface.MAX_VALUE; i++) {
        sum += i;
    }
    System.out.println(sum)
}
```
这个程序运行起来比预计的慢一些, 因为不小心将一个局部变量 sum 声明为装箱基本类型 Long, 与基本类型 long 相加再赋予运行起来会不停的拆箱装箱, 导致明显的性能下降  
总之, 当可以选择热时候, 基本类型要优先于装箱基本类型, 基本类型也更加简单和快速; 如果必须使用装箱基本类型, 则要特别小心! 自动装箱减少了使用装箱基本类型的繁琐性, 但是并没有减少它的风险; 当使用 == 操作比较两个装箱基本类型时, 做的同一性比较需要注意; 当程序进行设计装箱和拆箱基本类型的混合类型计算, 为初始化的装箱基本类型会抛出 NullPointerException 异常; 最后当频繁拆箱装箱时会导致高开销和不必要的对象创建

#### 第 50 条: 如果其他类型更适合, 则尽量避免使用字符串
- 字符串不适合代替其他的值类型
- 字符串不适合代替枚举类型
- 字符串不适合代替聚集类型
- 字符串也不适合代替能力表

#### 第 51 条: 当心字符串连接的性能
字符串连接操作符 (+, string concatenation operator) 是把多个字符串合并成一个字符串的便利途径; 要想产生单独一行的输出, 或者构造一个字符串来表示一个较小的, 大小固定的对象, 使用连接操作符是适合的, 但是不适合运用在大规模的场景中, 为连接 n 个字符串而重复的使用字符串连接操作符, 需要 n 的平方级时间; 这时由于字符串不可变 (见第 15 条)
而导致的不幸结果, 当两个字符串被连接在一起的时候, 它们的内容都需要被拷贝; 建议使用 StringBuilder 的 append 方法, 另一种方法是使用字符数组, 或者每次只处理一个字符串而不是将它们全部组合

#### 第 52 tiao: 通过接口引用对象
第 40 条中有一条建议: 应该使用接口而不是类作为参数的类型; 更一般的讲, 应该优先使用接口而不是类引用对象; 如果有合适的接口类型存在, 那么对于参数, 返回值, 变量和域来说, 就都应该使用这个接口类型进行声明, 只有当利用构造器创建某个对象的时候, 才真正需要引用这个对象的类; 但也有以下情形并不适合
- 没有合适的接口存在, 则完全可以使用类而不是接口来引用对象
- 如果对象属于一个框架, 而框架的基本类型是类而不是接口, 则往往使用抽象类来引用这个对象, 而不是实现类
- 如果类实现了接口, 但提供了接口中不存在的额外方法, 则只能使用类来引用对象

#### 第 53 条: 接口优先于反射机制
核心反射机制 (core reflection facility) java.lang.reflect 提供了 "通过程序来访问关于已装载的类的信息" 的能力; 给定一个 Class 实例, 可以获得 Constructor, Method, Field 实例, 分别代表了该 Class 实例所表示的类的 Constructor (构造器), Method (方法) 和 Field (域); 而这些实例能够通过反射机制操作它们的底层对等体: 通过调用 Constructor, Method, Field 实例上的方法, 可以构造底层类的实例, 调用底层类的方法, 并访问底层类中的域; 反射机制允许一个类使用另一个类, 即使当前者被编译的时候后者还根本不存在, 然而这种能力也要付出代价
- 丧失了编译时类型检查的好处
包括异常检查, 如果企图用反射的方式调用不存在的或者不可执行的方法, 在运行时将会失败, 除非采取了特别的预防措施
- 执行反射访问所需要的代码非常笨拙和冗长
编写这样的代码很乏味, 阅读起来也很困难
- 性能损失
反射方法调用比普通方法调用慢了很多, 具体慢多少受多个因素影响

核心反射机制最初是为了基于组件的应用创建工具而设计的, 这类工具通常要根据需要装载类, 并且用反射功能找出它们支持哪些方法和构造器, 这些工具允许用户交互式地构建出访问这些类的应用程序, 但是所产生出来的这些应用程序能够以正常的方式访问这些类, 而不是以反射的方式; 反射功能只是在设计时 (design time) 被用到, 通常普通应用不应该在运行时以反射方式访问对象  
如果只是以非常有限的形式使用反射机制, 虽然也要付出少许代价, 但是可以获得许多好处; 对于有些程序, 它们必须用到在编译时无法获取的类, 但是在编译时存在适当的接口或者超类, 通过它们可以引用这个类 (见第 52 条); 如果是这样的情况, 就可以以反射方式创建实例, 然后通过它们的接口或者超类, 以正常的方式访问这些实例, 如果适当的构造器不带参数, 甚至根本不需要使用 java.lang.reflect 包, Class.newInstance 方法就已经提供了所需的功能  
简而言之, 反射机制是一种功能强大的机制, 对于特定的复杂系统编程任务, 它是非常必要的; 但它也有一些缺点, 如果编写的程序要与编译时未知的类一起工作, 如果有可能就应该仅仅使用反射机制来实例化对象, 而访问对象时则使用编译时已知的某个接口或者超类

#### 第 54 条: 谨慎使用本地方法
Java Native Inteface (JNI) 允许 Java 应用程序可以调用本地方法 (native method), 所谓本地方法是指用本地程序设计语言 (比如 C 或者 C++) 来编写的特殊方法, 本地方法在本地语言中可以执行任意的计算任务, 并返回到 Java 程序语言中  
从历史上看, 本地方法主要有三种用途; 它们提供了 "访问特定于平台的机制" 的能力, 例如访问注册表和文件锁等; 它们还提供了访问遗留代码库的能力, 从而可以访问遗留数据; 最后本地方法可以通过本地语言编写应用程序中注重性能的部分, 以提高系统的性能  
但由于 JVM 的发展, 以前宿主机上本地方法的功能也在 JDK 中提供, 并且性能也不相上下, 所以并不提倡使用本地方法
#### 第 55 条: 谨慎地进行优化
TODO

#### 第 56 条: 遵守普遍接受的命名惯例
TODO
