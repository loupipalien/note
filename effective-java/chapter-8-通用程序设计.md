### 通用程序设计

#### 第 45 条: 将局部变量的作用域最小化
本条目与第 13 条 (使类和成员的可访问性最小化) 本质上是类似的, 将局部变量的作用域最小化, 可以增强代码的可读性和可维护性, 并降低出错的可能性  
要使局部变量的作用域最小化, 最有力的方法就是在第一次使用它的地方声明; 几乎每个局部变量的声明都应该包含一个初始化表达式, 如果还没有足够的信息来对一个变量初始化, 就应该推迟这个声明, 直到可以初始化为止; 这条规则有个例外的情况是与 try-catch 语句有关, 如果一个变量被一个方法初始化, 而这个方法会抛出一个受检异常, 该变量就必须在 try 块的内部初始化, 如果变量的值必须在 try 块的外部被使用到, 就必须在 try 块之前被声明, 但是在 try 块之前还不能被 "有意义的初始化"  
循环中提供了特殊的机会来将变量的作用域最小化 (无论是传统的还是 for-each 形式的), for 循环都允许声明循环变量, 它们的作用域被限定在正好需要的范围内; 因此, 如果在循环终止后不再需要循环变量的内容, for 循环就优先于 while 循环

#### 第 46 条: for-each 循环优先于传统的 for 循环
在 Java 1.5 发行版本之前, 对集合进行遍历的首选做法如下
```
// No longer the prefered idiom to Iterate over a collection
for (Iterator i = c.iterator(); i.hasNext(); ) {
    doSomething((Element) i.next());
}
```
遍历数组的首选做法如下
```
// No longer the prefered idiom to Iterate over a array
for (int i = 0; i < a.length; i++) {
    doSomething(a[i];
}
```
这些做法都比 while 循环要好 (见第 45 条), 但是也并不完美, 迭代器和索引变量都会造成一些混乱, 这也代表着出错的可能性; Java 1.5 发行版本引入了 for-each 循环, 通过完全隐藏迭代器或者索引变量, 避免了混乱和出错的可能
```
// The prefered  idiom to Iterate over collections and arrays
for (Element e : elements) {
    doSomething(e);
}
```
利用 for-each 循环不会有性能损失, 甚至用于数组也一样, 实际上某些情况下, 比起普通的 for 循环, 还稍具有性能优势, 因为它对数组索引的边界值只计算一次; for-each 循环不仅可以变量集合和数组, 还可以变量任何实现了 Iterable 接口的对象  
总之, for-each 循环的简洁性和预防 Bug 方面都有着传统的 for 循环无法比拟的优势, 而且没有性能损失, 应该尽可能的使用 for-each 循环; 遗憾的是以下三种情况无法使用 for-each 循环
- 过滤
如果集合需要遍历, 并删除选定的元素, 就需要使用显示的迭代器, 以便可以调用它的 remove 方法
- 转换
如果需要遍历列表或者数组, 并取代它部分或者全部的元素值
- 平行迭代
如果需要并行的遍历多个集合, 就需要显示的控制迭代器或者索引变量, 以便所有迭代器或者索引变量都可以得到同步前移

#### 第 47 条: 了解和使用类库
TODO

#### 第 48 条: 如果需要精确的答案, 请避免使用 float 和 double
float 和 double 类型主要是为了科学计算和工程计算而设计的; 它们执行二进制浮点运算, 这是为了在广泛的数值范围上提供较为精确的快速近似计算而精心设计的; 然而它们并没有提供完全精确的结果, 所以不应该被用于需要精确计算的场合; floa 和 double 类型尤其不适合用于货币计算, 通常使用 BigDecimal 来计算精确的值; 如果性能非常关键, 又不介意自己记录十进制小数点, 而且所涉及的数值又不大, 就可以使用 int 或 long 代替; 数值没有超过 9 位的就可以使用 int, 如果不超过 18 位数字就可以使用 long, 如果数值超过了 18 位就必须使用 BigDecimal

#### 第 49 条: 基本类型优先于装箱基本类型
Java 系统中的类型由两部分组成, 包含基本类型 (primitive) 和引用类型 (reference type), 但每个基本类型都有一个对应的引用类型, 称作是装箱基本类型 (boxed primitive); Java 1.5 发行本版中增加了自动装箱 (autoboxing) 和自动拆箱 (auto-unboxing), 如第 5 条所述, 这些特性模糊了但并没有完全抹去基本类型和装箱基本类型之间的区别  
在基本类型和装箱基本类型之间有三个主要区别
- 基本类型只有值, 而装箱基本类型则具有与它们的值不同的同一性, 即两个装箱基本类型可以具有相同的值和不同的同一性
- 基本类型只有功能完备的值, 而每个装箱基本类型除了它对应的基本类型的功能值之外, 还有非功能值: null
- 基本类型通常比装箱基本类型更节省时间和空间

考虑下面这个比较器, 被设计用来表示 Integer 值的递增数字顺序
```
// Broken Comparator - can you stop the flaw?
Comparator<Integer> naturalOrder = new Comparator<Integer>() {
    public int compare(Integer first, Integer second) {
        return first < second ? -1 : (first == second ? 0 : 1)
    }
}
```
这个比较器开起来是可以运行的, 但是当是两个基本值相同的装箱基本类型时, 应该返回为 0, 但是却会返回 1; < 的操作做了自动拆箱, 但是 == 的操作并没有, 所以返回了错误的值  
接下来, 考虑这个小程序
```
public class Unbelievable {
    static Integer i;

    public static void main(String[] args) {
        if (i == 42) {
            System.out.println("Unbelievable");
        }
    }
}
```
由于 i 未被初始化, 自动拆箱是 null 对象引用, 则会抛出 NullPointerException  
最后考虑第 5 条中的这个程序
```
// Hideously slow program! Can you spot the object creation?
public static void main(String[] args) {
    Long sum = 0;
    for(long i = 0; i < Interface.MAX_VALUE; i++) {
        sum += i;
    }
    System.out.println(sum)
}
```
这个程序运行起来比预计的慢一些, 因为不小心将一个局部变量 sum 声明为装箱基本类型 Long, 与基本类型 long 相加再赋予运行起来会不停的拆箱装箱, 导致明显的性能下降  
总之, 当可以选择热时候, 基本类型要优先于装箱基本类型, 基本类型也更加简单和快速; 如果必须使用装箱基本类型, 则要特别小心! 自动装箱减少了使用装箱基本类型的繁琐性, 但是并没有减少它的风险; 当使用 == 操作比较两个装箱基本类型时, 做的同一性比较需要注意; 当程序进行设计装箱和拆箱基本类型的混合类型计算, 为初始化的装箱基本类型会抛出 NullPointerException 异常; 最后当频繁拆箱装箱时会导致高开销和不必要的对象创建

#### 第 50 条: 如果其他类型更适合, 则尽量避免使用字符串
- 字符串不适合代替其他的值类型
- 字符串不适合代替枚举类型
- 字符串不适合代替聚集类型
- 字符串也不适合代替能力表

#### 第 51 条: 当心字符串连接的性能
字符串连接操作符 (+, string concatenation operator) 是把多个字符串合并成一个字符串的便利途径; 要想产生单独一行的输出, 或者构造一个字符串来表示一个较小的, 大小固定的对象, 使用连接操作符是适合的, 但是不适合运用在大规模的场景中, 为连接 n 个字符串而重复的使用字符串连接操作符, 需要 n 的平方级时间; 这时由于字符串不可变 (见第 15 条)
而导致的不幸结果, 当两个字符串被连接在一起的时候, 它们的内容都需要被拷贝; 建议使用 StringBuilder 的 append 方法, 另一种方法是使用字符数组, 或者每次只处理一个字符串而不是将它们全部组合

#### 第 52 tiao: 通过接口引用对象
第 40 条中有一条建议: 应该使用接口而不是类作为参数的类型; 更一般的讲, 应该优先使用接口而不是类引用对象; 如果有合适的接口类型存在, 那么对于参数, 返回值, 变量和域来说, 就都应该使用这个接口类型进行声明, 只有当利用构造器创建某个对象的时候, 才真正需要引用这个对象的类; 但也有以下情形并不适合
- 没有合适的接口存在, 则完全可以使用类而不是接口来引用对象
- 如果对象属于一个框架, 而框架的基本类型是类而不是接口, 则往往使用抽象类来引用这个对象, 而不是实现类
- 如果类实现了接口, 但提供了接口中不存在的额外方法, 则只能使用类来引用对象

#### 第 53 条: 接口优先于反射机制
