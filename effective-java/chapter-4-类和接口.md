### 类和接口

#### 第 13 条: 使类和成员的可访问性最小化
要区别设计良好的模块与设计不好的模块, 最重要的因素在于这个模块对于外部的其他模块而言, 是否隐藏器内部数据和其他实现细节; 设计良好的模块会隐藏所有的实现细节, 把它的 API 与它的实现清晰地隔离开来, 然后模块之间只通过它们的 API 进行通信, 一个模块不需要知道其他模块的内部工作情况; 这个概念被称为**信息隐藏 (information hiding) 或封装**, 是软件设计的基本原则之一  

##### 尽可能的使每个类或者成员不被外界访问
对于顶层的 (非嵌套的) 类和接口, 只有两种可能的访问级别: 包私有的 (package-private) 和公有的 (public); 如果类或者接口能够被做成包私有的, 那么它就应该被做成包私有的; 通过把类或者接口做成包私有的, 它实际上成了这个包的实现的一部分, 而不是包导出 API 的一部分, 在以后的发行版本中, 可以对它进行修改, 替换, 删除, 而无需担心会影响到现有的客户端程序, 如果把它做成公有的, 就有责任永远支持它, 并保持它们的兼容性  
如果一个包级私有的顶层类 (或者接口) 只是在一个类的内部被用到, 就应该考虑使它成为唯一使用它的那个类的私有嵌套类, 这样可以将它的可访问范围从包中的所有类缩小到了使用它的那个类; 然而降低不必要公有类的可访问性比降低包级私有的顶层类更重要的多, 因为公有类是包的 API 的一部分, 而包级私有的顶层类是这个包实现的一部分; 对于成员 (域, 方法, 嵌套类, 嵌套接口) 有四种访问级别, 按照以下顺序依次递增
- 私有的 (private): 只有在声明该成员的顶层类内部才可以访问这个成员
- 包级私有的 (package-private): 声明该成员的包内存不的任何类都可以访问这个成员
- 受保护的 (protected): 声明该成员的类的子类可以访问这个成员, 并且声明该成员的包内部的任何类也可以访问这个成员
- 公有的 (public): 在任何地方都可以访问该成员

私有成员和包级私有成员都是一个类的实现中的一部分, 一般不会影响它的导出 API, 然而如果这个类实现了 Serializable 接口, 这些域就有可能会被 "泄露" 到导出 API 中; 对于公有类的成员, 当访问级别从包级私有变成保护级别时会大大增强可访问性, 但也意味着其变成类的导出 API 的一部分, 必须永远得到支持; 有一条规则限制了降低方法的可访问性的能力, 即方法覆盖了超类中的一个方法, 子类中的访问级别就不允许低于超类中的访问级别  
实例域绝不能是公有的, 如果域是非 final 的或者是一个指向可变对象的 final 引用, 那么一旦使这个域成为公有的, 就放弃了对存储在这个域中的值进行限制的能力, 因此包含可变域的类不是线程安全的; 同样的建议也适用于静态域, 只有公有的静态 final 域暴露的常量 (基本类型的值或者不可变对象) 是例外情况

#### 在公有类中使用访问方法而非公有域
如果类可以在它所在的包的外部进行访问就提供访问方法; 如果类是包级私有的或者私有的嵌套类, 直接暴露它的数据域并没有本质的错误

#### 使可变性最小化
不可变类只是其实例不能被修改的类, 每个实例中包含的所有信息都必须在创建该实例的时候就提供, 并在对象的整个生命周期内固定不变, Java 类库中有基本类型包装类, String, BigInteger, BigDecimal 等; 不可变类比可变类更易设计, 实现, 使用, 安全; 使类成为不可变类要遵守以下五条规则
- 不要提供任何会修改对象状态的方法 (也称为 mutator)
- 保证类不会被扩展: 这样可以防止粗心或者恶意的子类假装对象的状态已经转变而破坏类的不可变行为, 为了防止子类化一般的做法是将这个类成为 final 的
- 使所有的域都是 final 的: 通过系统的强制方式保证线程安全的
- 使所有的域都成为私有的: 这样可以防止客户端或者访问
