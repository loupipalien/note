### 类和接口

#### 第 13 条: 使类和成员的可访问性最小化
要区别设计良好的模块与设计不好的模块, 最重要的因素在于这个模块对于外部的其他模块而言, 是否隐藏器内部数据和其他实现细节; 设计良好的模块会隐藏所有的实现细节, 把它的 API 与它的实现清晰地隔离开来, 然后模块之间只通过它们的 API 进行通信, 一个模块不需要知道其他模块的内部工作情况; 这个概念被称为**信息隐藏 (information hiding) 或封装**, 是软件设计的基本原则之一  

##### 尽可能的使每个类或者成员不被外界访问
对于顶层的 (非嵌套的) 类和接口, 只有两种可能的访问级别: 包私有的 (package-private) 和公有的 (public); 如果类或者接口能够被做成包私有的, 那么它就应该被做成包私有的; 通过把类或者接口做成包私有的, 它实际上成了这个包的实现的一部分, 而不是包导出 API 的一部分, 在以后的发行版本中, 可以对它进行修改, 替换, 删除, 而无需担心会影响到现有的客户端程序, 如果把它做成公有的, 就有责任永远支持它, 并保持它们的兼容性  
如果一个包级私有的顶层类 (或者接口) 只是在一个类的内部被用到, 就应该考虑使它成为唯一使用它的那个类的私有嵌套类, 这样可以将它的可访问范围从包中的所有类缩小到了使用它的那个类; 然而降低不必要公有类的可访问性比降低包级私有的顶层类更重要的多, 因为公有类是包的 API 的一部分, 而包级私有的顶层类是这个包实现的一部分; 对于成员 (域, 方法, 嵌套类, 嵌套接口) 有四种访问级别, 按照以下顺序依次递增
- 私有的 (private): 只有在声明该成员的顶层类内部才可以访问这个成员
- 包级私有的 (package-private): 声明该成员的包内存不的任何类都可以访问这个成员
- 受保护的 (protected): 声明该成员的类的子类可以访问这个成员, 并且声明该成员的包内部的任何类也可以访问这个成员
- 公有的 (public): 在任何地方都可以访问该成员

私有成员和包级私有成员都是一个类的实现中的一部分, 一般不会影响它的导出 API, 然而如果这个类实现了 Serializable 接口, 这些域就有可能会被 "泄露" 到导出 API 中; 对于公有类的成员, 当访问级别从包级私有变成保护级别时会大大增强可访问性, 但也意味着其变成类的导出 API 的一部分, 必须永远得到支持; 有一条规则限制了降低方法的可访问性的能力, 即方法覆盖了超类中的一个方法, 子类中的访问级别就不允许低于超类中的访问级别  
实例域绝不能是公有的, 如果域是非 final 的或者是一个指向可变对象的 final 引用, 那么一旦使这个域成为公有的, 就放弃了对存储在这个域中的值进行限制的能力, 因此包含可变域的类不是线程安全的; 同样的建议也适用于静态域, 只有公有的静态 final 域暴露的常量 (基本类型的值或者不可变对象) 是例外情况

#### 在公有类中使用访问方法而非公有域
如果类可以在它所在的包的外部进行访问就提供访问方法; 如果类是包级私有的或者私有的嵌套类, 直接暴露它的数据域并没有本质的错误

#### 使可变性最小化
不可变类只是其实例不能被修改的类, 每个实例中包含的所有信息都必须在创建该实例的时候就提供, 并在对象的整个生命周期内固定不变, Java 类库中有基本类型包装类, String, BigInteger, BigDecimal 等; 不可变类比可变类更易设计, 实现, 使用, 安全; 使类成为不可变类要遵守以下五条规则
- 不要提供任何会修改对象状态的方法 (也称为 mutator)
- 保证类不会被扩展: 这样可以防止粗心或者恶意的子类假装对象的状态已经转变而破坏类的不可变行为, 为了防止子类化一般的做法是将这个类成为 final 的
- 使所有的域都是 final 的: 通过系统的强制方式保证线程安全的
- 使所有的域都成为私有的: 这样可以防止客户端或者访问被域引用的可变对象的权限. 并防止客户端直接修改这些对象
- 确保对于任何可变组件的护持访问: 如果类具有指向可变对象的域, 则必须确保该类的客户端无法获得指向这些对象的引用, 并且永远不要用客户端提供的对象引用来初始化这样的域, 也不要从任何访问方法中返回该对象的引用; 在构造器, 访问方法, readObject 方法中使用保护性拷贝 (defensive copy) 技术

不可变对象的本质上是线程安全的, 它们不要求同步, 所以不可变对象可以被自由地共享, 由此导致的结果是不可变类永远也不需要进行保护性拷贝, 因为这些拷贝始终等于原始对象, 因此不需要也不应该为不可变类提供 clone 方法或者拷贝构造器 (虽然 String 类具有拷贝构造器, 但是应该尽量少用); 不可变对象甚至也可以共享它们的内部信息; 不可变对象也为其他对象提供了大量的构件; 不可变类的唯一缺点是对于不同的值需要一个单独的对象  
对于不可变类的序列化需要注意, 不可变类实现了 Serializable 接口, 并且它包含一个或者多个指向可变对象的域, 就必须提供一个显式的 readObject 或者 readResolve 方法, 或者使用 ObjectOutputStream.writeUnrshared 和 ObjectInputStream.readUnshared 的方法, 即使默认的序列化的形式是可以接受的, 否则攻击者可能从不可变类创建可变的实例

#### 复合优先于继承
继承是实现代码重用的有力手段, 但它并非永远是完成这项工作的最佳工具; 在包内使用继承是非常安全的, 专门设计用于继承的
