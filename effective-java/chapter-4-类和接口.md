### 类和接口

#### 第 13 条: 使类和成员的可访问性最小化
要区别设计良好的模块与设计不好的模块, 最重要的因素在于这个模块对于外部的其他模块而言, 是否隐藏器内部数据和其他实现细节; 设计良好的模块会隐藏所有的实现细节, 把它的 API 与它的实现清晰地隔离开来, 然后模块之间只通过它们的 API 进行通信, 一个模块不需要知道其他模块的内部工作情况; 这个概念被称为**信息隐藏 (information hiding) 或封装**, 是软件设计的基本原则之一  

##### 尽可能的使每个类或者成员不被外界访问
对于顶层的 (非嵌套的) 类和接口, 只有两种可能的访问级别: 包私有的 (package-private) 和公有的 (public); 如果类或者接口能够被做成包私有的, 那么它就应该被做成包私有的; 通过把类或者接口做成包私有的, 它实际上成了这个包的实现的一部分, 而不是包导出 API 的一部分, 在以后的发行版本中, 可以对它进行修改, 替换, 删除, 而无需担心会影响到现有的客户端程序, 如果把它做成公有的, 就有责任永远支持它, 并保持它们的兼容性  
如果一个包级私有的顶层类 (或者接口) 只是在一个类的内部被用到, 就应该考虑使它成为唯一使用它的那个类的私有嵌套类, 这样可以将它的可访问范围从包中的所有类缩小到了使用它的那个类; 然而降低不必要公有类的可访问性比降低包级私有的顶层类更重要的多, 因为公有类是包的 API 的一部分, 而包级私有的顶层类是这个包实现的一部分; 对于成员 (域, 方法, 嵌套类, 嵌套接口) 有四种访问级别, 按照以下顺序依次递增
- 私有的 (private): 只有在声明该成员的顶层类内部才可以访问这个成员
- 包级私有的 (package-private): 声明该成员的包内存不的任何类都可以访问这个成员
- 受保护的 (protected): 声明该成员的类的子类可以访问这个成员, 并且声明该成员的包内部的任何类也可以访问这个成员
- 公有的 (public): 在任何地方都可以访问该成员

私有成员和包级私有成员都是一个类的实现中的一部分, 一般不会影响它的导出 API, 然而如果这个类实现了 Serializable 接口, 这些域就有可能会被 "泄露" 到导出 API 中; 对于公有类的成员, 当访问级别从包级私有变成保护级别时会大大增强可访问性, 但也意味着其变成类的导出 API 的一部分, 必须永远得到支持; 有一条规则限制了降低方法的可访问性的能力, 即方法覆盖了超类中的一个方法, 子类中的访问级别就不允许低于超类中的访问级别  
实例域绝不能是公有的, 如果域是非 final 的或者是一个指向可变对象的 final 引用, 那么一旦使这个域成为公有的, 就放弃了对存储在这个域中的值进行限制的能力, 因此包含可变域的类不是线程安全的; 同样的建议也适用于静态域, 只有公有的静态 final 域暴露的常量 (基本类型的值或者不可变对象) 是例外情况

#### 在公有类中使用访问方法而非公有域
如果类可以在它所在的包的外部进行访问就提供访问方法; 如果类是包级私有的或者私有的嵌套类, 直接暴露它的数据域并没有本质的错误

#### 使可变性最小化
不可变类只是其实例不能被修改的类, 每个实例中包含的所有信息都必须在创建该实例的时候就提供, 并在对象的整个生命周期内固定不变, Java 类库中有基本类型包装类, String, BigInteger, BigDecimal 等; 不可变类比可变类更易设计, 实现, 使用, 安全; 使类成为不可变类要遵守以下五条规则
- 不要提供任何会修改对象状态的方法 (也称为 mutator)
- 保证类不会被扩展: 这样可以防止粗心或者恶意的子类假装对象的状态已经转变而破坏类的不可变行为, 为了防止子类化一般的做法是将这个类成为 final 的
- 使所有的域都是 final 的: 通过系统的强制方式保证线程安全的
- 使所有的域都成为私有的: 这样可以防止客户端或者访问被域引用的可变对象的权限. 并防止客户端直接修改这些对象
- 确保对于任何可变组件的护持访问: 如果类具有指向可变对象的域, 则必须确保该类的客户端无法获得指向这些对象的引用, 并且永远不要用客户端提供的对象引用来初始化这样的域, 也不要从任何访问方法中返回该对象的引用; 在构造器, 访问方法, readObject 方法中使用保护性拷贝 (defensive copy) 技术

不可变对象的本质上是线程安全的, 它们不要求同步, 所以不可变对象可以被自由地共享, 由此导致的结果是不可变类永远也不需要进行保护性拷贝, 因为这些拷贝始终等于原始对象, 因此不需要也不应该为不可变类提供 clone 方法或者拷贝构造器 (虽然 String 类具有拷贝构造器, 但是应该尽量少用); 不可变对象甚至也可以共享它们的内部信息; 不可变对象也为其他对象提供了大量的构件; 不可变类的唯一缺点是对于不同的值需要一个单独的对象  
对于不可变类的序列化需要注意, 不可变类实现了 Serializable 接口, 并且它包含一个或者多个指向可变对象的域, 就必须提供一个显式的 readObject 或者 readResolve 方法, 或者使用 ObjectOutputStream.writeUnrshared 和 ObjectInputStream.readUnshared 的方法, 即使默认的序列化的形式是可以接受的, 否则攻击者可能从不可变类创建可变的实例

#### 复合优先于继承
继承是实现代码重用的有力手段, 但它并非永远是完成这项工作的最佳工具; 在包内使用继承是非常安全的, 对于专门设计用于继承的且有良好说明文档的类来说也是安全的, 但对普通的具体类进行跨越包边界的继承是非常危险的  
与方法调用不同的是, 继承打破了封装性, 即子类依赖于其超类中特定功能的实现细节, 超类的实现有可能会随着发行版本的不同而有所变化, 如果真的发生了则子类可能会遭到破坏; 以及子类覆盖了超类的方法以满足某些功能需要, 当超类增加新方法时子类调用则可能不满足功能, 导致异常; 以及超类后续添加了与子类相同方法签名但不同返回类型的方法时, 会导致子类无法编译; 所以如果不是专用的继承则可能导致种种问题, 幸运的是可以使用复合替换继承来避免这些问题, 在新的类中增加一个私有域引用现有类的一个实例, 新类中的每个实例方法都可以调用被包含的现有实例中对应的方法并返回结果, 新的类也被称为包装类, 也正是 Decorator 模式  
继承的功能非常强大, 但是也存在诸多问题, 因为其违背了封装原则, 只有子类和超类之间确实存在子类型关系时, 使用继承才是恰当的; 当子类和超类不在同一个包中时, 并且超类不是专门设计用于继承的, 则建议使用包装模式替代继承, 并且包装类更加稳定和强大

#### 要么为继承而设计, 并提供说明文档, 要么禁止继承
对于专门为了继承而设计的类的文档必须精确的描述覆盖每个方法所带来的影响, 即该类必须有文档说明它可覆盖的方法的自用性; 对于每个公有的或受保护的方法或者构造器, 它的文档必须指明该方法或者构造器的调用了哪些可覆盖的方法, 是以什么顺序调用的, 每个的调用结果又是如何影响后续的处理过程的  
关于程序文档有句格言: 好的 API 文档应该描述一个给定的方法做了什么工作, 而不是描述它如何做到的; 为了继承而进行的设计不仅仅设涉及自用模式的为胆囊设计, 为了使程序员能够编写出更加有效的子类, 而无需承受不必要的痛苦, 类必须通过某种形式提供适当的钩子, 以便能够进入它的内部工作流中, 这种形式可以是精心选择的受保护的方法  
为了允许继承, 类还必须遵守其他一些约束; 构造器决不能调用可被覆盖的方法, 无论是直接调用的还是间接调用的, 如果违反了此规则可能导致程序失败; 超类的构造器是在子类的构造器之前运行的, 所以子类中覆盖版本的方法将会在子类的构造器运行之前就先被调用, 如果该覆盖版本的方法依赖于子类构造器的任何初始化工作, 该方法将不会如预期般执行
```
public class Super {
    // Broken - constructor invokes an overridable method
    public Super() {
        overrideMe();
    }

    public void overrideMe() {}
}

public final class Sub extends Super {
    private final Date date;

    Sub() {
        date = new Date();
    }

    // overriding method invoked by superclass constructor
    @override
    public void overrideMe() {
        System.out.println(date);
    }

    public static void main(String[]  args) {
        Sub sub = new Sub();
        sub.overrideMe();
    }
}
```
在为了继承而设计类的时候, Cloneable 和 Serializable 接口出现了特殊的困难; 如果类是为了继承而被设计的, 无论实现这个其中的那个接口通常都不是好主意, 因为它们把一些实质性的覆盖转嫁到了扩展这个类的程序员身上  
如果决定在一个为了继承而设计的类中实现 Cloneable 或者 Serializable 接口, 就应该意识到因为 clone 和 readObject 方法在行为上非常类似于构造器, 所以类似的限制规则也是适用的: 无论是 clone 还是 readObject 都不可以调用可覆盖的方法, 不管是以直接还是间接的方式; 对于 readObject 方法覆盖版本的方式将在子类的状态被反序列化 (deseriable) 之前先被运行, 对于 clone 方法覆盖版本的方式则是在子类的 clone 方法还有机会修正正在被克隆对象的状态之前先被运行, 无论哪种情形都不可避免导致程序失败; 如果决定在一个为继承而设计的类中实现 Serializable, 并且该类有一个 readResolve 或者 writeReplace 方法, 就必须使得 readResolve 或者 writeReplace 成为受保护的方法而不是私有方法, 如果这些方法是私有的, 那么子类将会忽略掉这两个方法, 这正是 "为了继承, 而把实现细节变成一个类的 API 的一部分" 的情景  
对于为了继承而设计的类, 对于这个类会有一些实质性的限制是容易做到的; 但是对于普通的具体类如何避免被子类化, 一种方法是将这个类声明为 final 的, 另一种方法是把所有的构造器都变成私有的或者包级私有的, 并增加一些公有的静态工厂来代替构造器, 使用包装类扩展功能; 如果允许普通的具体类被子类化, 一种合理的办法是确保这个类不会调用它的任何可覆盖的方法, 即完全消除这个类中可覆盖方法的自用特性, 这样就可以 "安全的子类化" 类, 覆盖方法将永远不会影响其他任何方法的行为; 手动消除类中可覆盖方法的自用特性, 而不改变它的特性的方式是, 将每个可覆盖方法的代码迁移到一个私有的 "辅助方法" 中, 用 "直接调用可覆盖方法的私有辅助方法" 来代替 "可覆盖方法的每一个自用调用"

#### 第 18 条: 接口优于抽象类
Java 语言提供了两种机制用来定义允许多个实现的类型: 接口和抽象类; 这两种机制之间的区别在于, 抽象类允许包含某些方法的实现, 但是接口则不允许 (但 JDK8 支持了 default 方法); 一个更为重要的区别在于, 为了实现抽象类定义的类型, 类必须成为抽象类的一个子类, 而任何一个类只要它定义了所有必要的方法, 并且遵守通用约定, 它就被允许实现一个接口, 并且不用管这个类是处于类层次的那个位置; 因为 Java 只允许但继承, 所以抽象类作为类型定义收到了极大的限制
- 现有的类可以很容易被更新, 以实现新的接口
如果这些方法不存在, 所需要做的就是增加必要的方法, 然后在类的声明中增加一个 implements 子句; 而更新现有的类扩展新的抽象类, 则可能出现不能扩展或者扩展会破坏继承结构等问题
- 接口是定义 minin (混合类型) 的理想选择
mixin 是指这样的类型: 类除了实现它的 "基本类型 (primary type)" 之外, 还可以实现这个 mixin 类型, 以表明它提供了某些可供选择的行为; 接口适合做这样的事而抽象类不适合
- 接口允许构造非层次结构的类型框架
类型层次对于组织某些事物是非常合适的, 但是其他有些事物并不能被整齐地组织成一个严格的层次结构

虽然接口不允许包含方法的实现, 但是使用接口来定义类型并不妨碍提供实现上的帮助; 通过对导出每个重要接口都提供一个抽象的骨架实现类, 把接口和抽象类的优点结合起来; 接口的作用仍然是定义类型, 但是骨架实现类接管了所有与接口实现相关的工作; 按照惯例, 骨架实现类称为 AbstractInterface, Interface 是指实现的接口的名字
