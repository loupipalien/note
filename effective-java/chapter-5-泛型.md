### 泛型

#### 第 23 条: 请不要在新代码中使用原生态类型
声明具有一个或者多个类型参数的类或者接口, 就是泛型 (generic) 类或者接口; 而每个泛型都有一个原生态类型, 即不带任何实际参数的泛型名称, 例如 List 是 List<String> 的原生态类型; 如果不提供类型参数, 使用泛型也仍然是合法的, 但是不应该这样做, 因为使用原生态类型失去了泛型在安全性和表述性方面的所有优势; 在使用中可以将 List<String> 引用传递给类型 List, 但是不能传递给 List<Object>, 因为泛型有子类型化的规则, List<String> 是原生态类型 List 的一个子类型, 而不是 List<String> 的子类型  
由于使用原生类型很危险, Java 提供了一种安全的替代方法, 称作无限制通配符类型 (unbouned wildcard type), 如果要使用泛型, 但不确定或者不关心实际的类型参数, 就可以使用一个问号代替; 无限制通配符类型与原生态类型的区别是: 无限制通配符类型类型是安全的, 原生态类型不安全, 可以将任何元素放入原生态类型的集合中, 但是不能将任何元素 (除了 null) 放入无限制通配符类型的集合中  
不要在新代码中使用原生态类型, 但有两个源于 "泛型信息可以在运行是被擦除" 的例外
- 在类文字中必须使用原生态类型, 规范不允许使用参数化类型 (虽然允许数组类型和基本类型), List.class 是合法的, 但 List<String>.class 是非法的
- 在 instanceof 操作符时使用原生态类型, 参数化类型而非无限制通配符类型上使用 instanceof 操作符是非法的

一些术语介绍
| 术语 |示例|所在条目|
|---|---|---|
|参数化类型|List<String>|第 23 条|
|实际类型参数|String|第 23 条|
|泛型|List<E>|第 23, 26 条|
|形式类型参数|E|第 23 条|
|无限制通配符类型|List<?>|第 23 条|
|原生态类型|List|第 23 条|
|有限制类型参数|List<E extends Number>|第 26 条|
|递归类型限制|List<T extends Comparable<T>>|第 27 条|
|有限制通配符类型|List<? extends Number>|第 28 条|
|泛型方法|static <E> List<E> asList(E[] a)|第 27 条|
|类型令牌|String.class|第 29 条|
