### 对于所有对象都通用的方法
尽管 Object 是一个具体类, 但是设计它主要是为了扩展; 它所有的非 final 方法 (equals, hahsCode, toString, clone, finalize) 都有明确的通用约定 (general contract), 因为它们被设计为要被覆盖的; 任何一个类在覆盖这些方法的时候, 都要遵守这些通用约定, 如果不能做到这一点, 其他依赖于这些约定的类 (如 HashMap 和 HashSet) 就无法结合该类一起正常工作

#### 第 8 条: 覆盖 equals 时请遵守通用约定
覆盖 equals 方法看起来简单但是许多覆盖方式会导致错误; 在不覆盖 equals 方法的情况下, 类的每个实例都只与自身相等; 如果满足了以下任何一个条件, 这就是期望的结果
- 类的每个实例本质上都是唯一的
对于代表活动实体而不是值的类来说却是如此, 例如 Thread; Object 提供的 equals 实现对于这些类来说正是正确的行为
- 不关心类是否提供了 "逻辑相等" 的测试功能
java.util.Random 覆盖了 equals, 以检查两个 Random 实例是否产生相同的随机数序列, 但是设计者并不认为客户需要或者期望这样的功能; 在这样的情况下, Object 提供的 equals 实现已经足够了
- 超类已经覆盖了 equals, 从超类继承过来的行为对于子类也是合适的
如大多数 Set 实现都从 AbstractSet 继承 equals 实现, List 实现从 AbstractList 继承 equals 实现, Map 实现从 AbstractMap 继承 equals 实现
- 类是私有的或是包级私有的, 可以确定它的 equals 方法永远不会被调用
在这种情况下无疑是应该覆盖 equals 方法, 以防它被意外调用

如果类具有自己特有的 "逻辑相等" 的概念 (不等同与对象等同的概念), 而且超类还没有覆盖 equals 以实现期望的行为, 这时我们就需要覆盖 equals 方法; 这通常属于 "值类 (value class)" 的情形, 值类仅仅是一个表示值的类, 例如 Integer 或者 Date, 程序员在利用 equals 方法来比较值对象的引用时, 希望知道它们在逻辑上是否相等, 而不是想了解它们是否指向同一个对象; 为了满足这个需求, 不仅必需覆盖 equals 方法, 而且这样做也使得这个类的实例可以被用做映射表 (map) 的键 (key), 或者集合 (set) 的元素, 使得映射或者集合表现出预期的行为  
有一种 "值类" 不需要覆盖 equals 方法, 即用实例受控 (见第 1 条) 确保 "每个值至多存在一个对象" 的类, 枚举类型 (见第 30 条) 就属于这样的类; 对于这样的类而言, 逻辑相同与对象等同是一回事, 因此 Object 的 equals 方法等同于逻辑意义上的 equals 方法  
在覆盖 equals 方法时必须要遵守以下规定, equals 方法实现了等价关系 (equivalence relation)
- 自反性 (reflexive): 对于任何非 null 的引用值 x, x.equals(x) 必须返回 true
- 对称性 (symmetric): 对于任何非 null 的引用值 x 和 y, 当且仅当 y.equals(x) 返回 true 时, x.equals(y) 必须返回 true
- 传递性 (transitive): 对于任何非 null 的引用值 x, y, z, 如果 x.equals(y) 放回 true, 并且 y.equals(z) 也返回 true, 那么 x.equals(z) 也必须返回 true
- 一致性 (consistent): 对于任何非 null 的引用值 x 和 y, 只要 equals 的比较操作在对象中所用的信息没有被修改, 多次调用 x.equals(y) 就会一致地返回 true, 或者一致的返回 false
- 对于任何非 null 的引用值 x, x.equals(null) 必须返回 false

结合以上所有要求, 得出以下实现高质量 equals 方法的诀窍
- 使用 == 操作符检查 "参数是否为这个对象的引用"
- 使用 instanceof 操作符检查 "参数是否为正确的类型"
- 把参数转换成正确的类型
- 对于该类中的每个 "关键 (significant)" 域, 检查参数中的域是否与该对象中对应的域相匹配
- 当编写完成 equals 方法之后, 应该要问自己三个问题: 它是否是对称, 传递的, 一致的?
  - 覆盖 equals 时总要覆盖 hashCode (见第 9 条)
  - 不要企图让 equals 方法过于智能
  - 不要将 equals 声明中的 Objects 对象替换为其他的类型

#### 第 9 条: 覆盖 equals 时总要覆盖 hashCode
一个很常见的错误根源在于没有覆盖 hashCode 方法, 在每个覆盖了 equals 方法的类中, 也必须覆盖 hashCode 方法; 如果不这样做的话, 就会违反 Object.hashCode 的通用约定, 从而导致该类无法结合所有基于散列的集合一起正常运作, 包括 HashMap, HashSet, HashTable; 以下是摘自 Object 规范的约定内容
- 在应用侧滑盖女婿的执行期间, 只要对象的 equals 方法的比较操作所用到的信息没有被修改, 那么对这同一个对象调用多次, hashCode 方法都必须时钟如一地返回同一个整数; 在同一个应用程序的多次执行过程中, 每次执行所返回的整数可以是不同的
- 如果两个对象根据 equals(Object) 方法的比较是相等的, 那么调用这两个对象中任意一个对象的 hashCode 方法都必须产生相同的整数结果
- 如果两个对象根据 equals(Object) 方法的比较是不相等的, 那么调用这两个对象中任意一个对象的 hashCode 方法, 则不一定要产生不同的整数结果; 但是程序员应该知道, 给不相等的对象产生截然不同的整数结果, 有可能提高散列表的性能

因没有覆盖 hashCode 而违反的关键约定是第二条: 相等的对象必须具有相等的散列码 (hash code); 根据类的 equals 方法, 两个截然不同的实例在逻辑上有可能是相等的, 但是根据 Object 类的 hashCode 方法, 它们仅仅是两个没有任何共同之处的对象, 因此对象的 hasdCode 方法返回两个看起来是随机的整数, 而不是根据第二个约定所要求的那样, 返回两个相等的整数  
一个好的散列函数通常倾向于 "为不相等的对象产生不相等的散列码", 这正是 hashCode 约定中第三条的含义; 理想情况下, 散列函数应该把集合中不相等的实例均匀的分布到所有可能的散列值上, 要达到完全理想的情形是非常困难的, 以下给出一种接近理想情形的解法
- 把某个非零的常数值 (例如 17) 保存在一个名为 result 的 int 类型的变量中
- 对于对象中的每个关键域 f (指 equals 方法中涉及的每一个域), 完成以下步骤
  - 为该域计算 int 类型的散列码 c:
    - 如果该域是 boolean 类型, 则计算 (f ? 1 : 0)
    - 如果该域是 byte, char, short, int 类型, 则计算 (int)f
    - 如果该域是 long 类型, 则计算 (int) (f ^ (f >>> 32))
    - 如果该域是 float 类型, 则计算 Float.floatToIntBits(f)
    - 如果该域是 double 类型, 则计算 Double.doubleToLongBits(f), 然后按 long 类型的步骤计算
    - 如果该域是一个对象引用, 并且该类的 equals 方法通过递归地调用 equals 方式比较这个域, 则同样为这个域递归地调用 hashCode; 如果需要更复杂的比较, 则为这个域计算一个 "范式 (canonical representation)", 然后针对这个范式调用 hashCode, 如果这个域为 null 则返回 0 (或者某个常数, 通常是 0)
    - 如果该域是一个数组, 则要把每一个元素当作单独的域来处理, 也就是说递归地运用上述规则, 对每个重要的元素计算一个散列码, 然后将散列码组合起来; 如果数组域中的每个元素都很重要, 可以利用 JDK1.5 增加的 Arrays.hashCode 方法
  - 按照以下公式, 把以上步骤得到的散列码 c 合并到 result 中
  result = 31 * result + c;
- 返回 result

在散列码的计算过程中, 可以把冗余域 (redundant field) 排除在外, 即一个域的值可以根据参与计算的其他域计算出来, 则可以把这样的域排除在外, 此外必须排除 equals 比较计算中没有用到的域, 否则很有可能违反 hashCode 约定的第二条  
上述步骤中用到了一个非零的初始值, 因此在后续计算的散列值为 0 的那些初始域会影响散列值, 如果初始值为 0 则整个散列值不受这些初始域的影响, 这样会增加冲突的可能性; 初始值 17 是任选的  
乘法部分使得散列值依赖于域的顺序, 如果一个类包含多个相似的域, 乘法部分的运算则会产生一个更好的散列函数; 之所以选择 31 是因为它是一个奇素数; 如果使用偶数, 如果乘法溢出的话信息就会丢失, 因为与 2 相乘等价于移位运算; 而使用素数的好处并不明显, 但习惯上使用素数计算散列结果, 31 有个很好的特性是可以用移位和减法代替乘法提升性能, 31 * i = (i << 5) - i

#### 第 10 条: 始终要覆盖 toString
虽然 java.lang.Object 提供了 toString 方法的一个实现, 但它返回的字符串通常并不是类的用户期望看到的, 它包含类的名称, 以及一个 "@" 符号, 接着是散列码的无符号十六进制表示法; toString 的约定建议所有的子类都覆盖这个方法; 如果对象太大, 或者对象中包含的状态信息难以用字符串来表达, 则可以考虑返回一个摘要信息; toString 方法返回的信息是否遵循指定格式建议在注释中说明

#### 第 11 条: 谨慎地覆盖 clone
TODO

#### 第 12 条: 考虑实现 Comparable 接口
comparaTo 方法并没有在 Object 中声明, 而是 Comparable 接口中的唯一方法, comparaTo 方法不但允许进行简单的等同性比较, 而且允许执行顺序比较; 类实现了 Comparable 接口 就表明它的实例具有内在的排序关系 (natural ordering), 一旦类实现了这个接口, 就可以和许多泛型算法以及依赖该接口的集合实现进行协作  
comparaTo 方法的通用约定与 equals 方法相似: 将这个对象与指定的对象进行比较, 当该对象小于, 等于, 大于指定对象的时候, 分别返回一个负整数, 零或者正整数, 如果由于指定对象的类型而无法与该对象进行比较时, 则抛出 ClassCastException 异常
- 实现者必须确保所有的 x 和 y 都满足 signum(x.comparaTo(y)) == -signum(y.comparaTo(x)), 这也暗示着当且仅当 y.comparaTo(x) 抛异常时, x.comparaTo(y) 才抛出异常
- 实现者还必须确保这个比较关系是可传递的, (x.comparaTo(y) > 0 && y.comparaTo(z) > 0) 暗示着 x.comparaTo(z) > 0
- 实现者必须确保 x.comparaTo(y) == 0 暗示着所有的 z 都满足 signum(x.comparaTo(z)) == signum(y.comparaTo(z))
- 强烈建议 (x.comparaTo(y) == 0) == (x.equals(y)), 但这并非绝对必要; 一般来说任何实现了 Comparable 接口的类, 若违反了这个条件都给与说明; 推荐使用说法: "注意: 该类具有内在的排序功能, 但是与 equals 不一致"

依赖于比较关系的类包括有序集合类 TreeSet 和 TreeMap, 以及工具类 Collections 和 Arrays, 它们内部包含有搜索和排序算法; comparaTo 约定的最后一点是强烈建议, 而不是真正的规则, 只是说明了 comparaTo 方法施加的等同形成测试, 在通常情况下应该返回与 equals 相同的结果, 如果一个类 (例如 BigDecimal 类) 的 comparaTo 方法施加了一个与 equals 方法不一致的顺序关系, 它仍然能够正常工作; 但是当有一个有序集合 (sorted collection) 包含了该类的元素, 这个集合就可能无法遵守相应集合接口 (Collection, Set, Map) 的通用约定, 这是因为这些接口的通用约定是按照 equals 方法来定义的, 但是有序集合使用了**由 comparaTo 方法而不是 equals 方法**所施加的等同性测试; 尽管这种情况不会造成灾难性的后果, 但是应该有所了解  
