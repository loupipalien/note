### 异常
充分发挥异常的优点, 可以提高程序的可读性, 可靠性和可维护性

#### 第 57 条: 只对异常的情况才使用异常
```
// Horrible abuse of exceptions, Dont't ever do this!
try {
    int i = 0;
    while (true) {
        range[i++].climb();
    }
} catch (ArrayIndexOutOfBoundsException e) {}
```
作为一个要对数组元素遍历的实现方式, 这样的写法是非常拙劣的; 当这个循环企图访问数组边界之外的第一个数组元素时, 用抛出捕获忽略的手段来达到终止无限循环的目的; 这种想法有三个错误
- 因为异常机制的设计初衷是用于不正常的情形, 所以很少会有 JVM 实现试图对它们进行优化, 使得与显式的测试一样快速
- 把代码放在 try-catch 块中反而阻止了现在 JVM 实现本来可能要执行的某些特定优化
- 对数组进行遍历的标准模式并不会导致冗余的检查, 有些现代 JVM 实现将会把它们优化掉

实际上, 在现代 JVM 实现上, 基于异常的模式比标准模式要慢得多, 而且基于异常的循环模式不仅模糊了代码的意图, 降低了性能而且还不能保证正常工作! 如果出现了不相关的 Bug, 这个模式会悄悄的失效, 从而掩盖了这个 Bug, 极大的增加了调试过程的复杂性; 假设循环体中的计算过程调用了一个方法, 这个方法执行了对某个不相关数组的越界访问, 如果使用标准的循环模式, 这个 Bug 会产生未被捕捉的异常, 从未导致线程立即结束, 产生完整的堆栈轨迹; 如果使用这个基于异常的循环模式, 与这个 Bug 相关的异常将会被捕捉到, 并且被错误的解释为正常的循环终止条件; 所以异常应该只用于异常的情况下, 它们永远不应该用于正常的控制流  
以上对于 API 设计的启发是: 设计良好的 API 不应该强迫它的客户端为了正常的控制流而使用异常; 如果类具有 "状态相关 (state-dependent)" 的方法, 即只有在特定的不可预知的条件下才可以被调用的方法, 这个类往往也应该有一个单独的 "状态测试 (state-testing)" 方法, 即指示是否可以调用这个状态相关的方法; Iterator 接口有一个 "状态相关" 的 next 方法, 和相应的状态测试方法 hasNext, 这使得利用传统的 for 循环 (以及 for-each 循环, 是在内部使用 hasNext 方法) 对集合进行迭代的标准模式成为可能
```
for (Iterator<Foo> i = collection.iterator(); i.hasNext; ) {
    Foo foo = i.next();
    ...
}
```
另一种提供单独的状态测试方法的做法是, 如果 "状态相关的" 方法被调用时, 该对象处于不适当的状态之中, 它就会返回一个可识别的值, 比如 null; 这种方法对于 Iterator 来说是不适用的, 因为 null 是 next 方法的合法返回值  
对于 "状态测试方法" 和 "可识别的返回值" 这两种做法; 如果对象将在缺少外部同步的情况下被并发访问, 或者可被外界改变状态, 使用可被识别的返回值是很有必要的, 因为在调用 "状态测试" 方法和调用对应的 "状态相关" 方法的时间间隔中, 对象的状态可能会发生变化; 如果单独的 "状态测试" 方法必须重复 "状态相关" 的工作, 就应该使用可被识别的返回值; 如果其他所有方面都是等同的, 那么 "状态测试" 方法则优于可被识别的返回值, 为了提供更好的可读性, 对使用不当的情形, 应抛出相关异常

#### 第 58 条: 对可恢复的情况使用受检异常, 对编程错误使用运行时异常
Java 程序设计语言提供了三种可抛出结构: 受检异常 (checked exception), 运行时异常 (run-time exception), 错误 (error)  
TODO

#### 避免不必要地使用受检的异常
受检的异常是 Java 程序设计语言的一项很好的特性, 与返回代码不同, 它们强迫程序员处理异常的条件, 大大增强了可靠性; 过分使用受检异常会使 API 使用起来非常的不方便, 如果一个方法抛出一个或者多个受检异常, 调用该方法的代码就必须在一个或者多个 catch 块中处理这些异常, 或者它必须声明它抛出的这些异常, 并让它们传播出去, 无论哪种方式都给程序员增添了不可忽视的负担; 如果正确的使用 API 不能阻止这种异常条件的产生, 并且一旦产生异常, 使用 API 的程序员可以立即采取有用的动作, 这种负担就被认为是正当的; 除非这两个条件都不成立, 否则更适合于使用未受检异常

#### 第 60 条: 优先使用标准的异常
重用现有异常有多方面的好处; 它可以使 API 更加易于学习和使用, 因为它与程序员已经熟悉的习惯用法是一致的; 对于用到这些 API 的程序而言, 它们的可读性会更好; 最后 (也是最不重要的) 一点是, 异常类越少意味着内存印迹越少, 装载这些类的时间也就越少; 以下是常用的异常类

| 异常 | 使用场合    |
| :------------- | :------------- |
| IllegalArgumentException | 非 null 的参数值不正确 |
| IllegalStateException | 对于方法调用而言, 对象状态不合适 |
| NullPointerException | 在禁止使用 null 的情况下参数值为 null |
| IndexOutOfBoundsException | 下标参数值越界 |
| ConcurrentModificationException | 在禁止并发修改的情况下, 检测到对象的并发修改 |
| UnsupportedOperationException | 对象不支持用户请求的方法 |

#### 第 61 条: 抛出与抽象相对应的异常
如果方法抛出的异常与它所执行的任务没有明显的联系, 这种情形将会使人不知所措; 当方法传递由底层抽象抛出的异常时, 往往会发生这种现象; 除了使人感到困惑之外, 这也让实现细节污染了更高层的 API; 如果高层的实现在后续的发行版本中发生了变化, 它所抛出的异常也可能会跟着发生比那花, 从而潜在的破坏现有的客户端程序; 为了避免这个问题, 更高层的实现应该捕获底层的异常, 同时抛出可以按照高层抽象进行解释的异常; 这种做法被称为异常转译 (exception translation)
```
// Exception
try {
    // Use lower-level abstraction to do our bidding
    ...
} catch (LowerLevelException e) {
    throw new HigherLevelException(...);
}
```
一种特殊的异常转译形式称为异常链 (exception chaining), 如果底层的异常对于调试导致高层异常的问题非常有帮助, 使用异常链就非常合适, 底层的异常被传递到高层的异常, 高层的异常提供访问方法 (Throwable.getCause) 来获得底层的异常
```
// Exception Chaining
try {
    // Use lower-level abstraction to do our bidding
} catch (LowerLevelException e) {
    throw new HigherLevelException(e);
}
```
尽管异常转译与不加选择地从底层传递异常的做法相比有所改进, 但是它也不饿能被滥用; 如果有可能, 处理来自底层异常的做好做法是, 在调用底层方法之前确保它们会成功执行, 从而避免它们抛出异常; 有时候, 可以在给底层传递参数之前, 检查更高层方法的参数的有效性, 从而避免底层方法抛出异常

#### 第 62 条: 每个方法抛出的异常都要有文档
TODO

#### 第 63 条: 在细节消息中包含能捕获失败的信息
当程序由于未被捕获的异常而失败的时候, 系统会自动地打印出该异常的堆栈信息, 在堆栈信息中包含该异常的字符串表示法 (string representation), 即它的 toString 方法的调用结果, 通常应该包含该异常的类名, 紧随其后的是细节消息; 为了捕获失败, 异常的细节信息应该包含所有 "对该异常有贡献" 的参数和域的值

#### 第 64 条: 努力是失败保持原子性
当对象抛出异常之后, 通常期望这个对象仍然保持在一种定义良好的可用状态之中, 即使失败是发生在执行某个操作的过程中间; 对于受检的异常而言, 这尤为重要, 因为调用者期望能从这种异常中进行恢复; 一般而言, 失败的方法调用应该使对象保持在被调用之前的状态; 具有这种属性的方法被称为具有失败原子性 (failure atomic)  
