### 纵观全局

#### 从 Antlr 元语言开始
语言 (languages) 是由一系列有意义的语句组成的, 语句 (sentence) 是由词组组成的, 词组 (parase) 是由更小的子词组 (subphrase) 和词汇符号 (vocabulary symbol) 组成的; 一般来说, 如果一个程序能够分析计算或 "执行" 语句就称之为解释器 (interpreter), 例如 Python 解释器; 如果一个程序能够将一门语言的语句转换为另外一门语言的语句就称之为翻译器 (translator), 例如 Java 到 C# 的转换器或普通编译器  
为了达到预期的目的, 解释器或翻译器需要识别一门特定语言的所有的有意义的语句, 词组, 子词组; 识别一个词组意味着可以将它从众多的组成部分中辨认和区分出来; 识别语言的程序称为语法分析器 (parser) 或者句法分析器 (syntax analyzer); 句法 (syntax) 是指约束语言中的各个组成部分之间关系的规则, 这里使用 Antlr 语法来指定语言的句法; 语法 (grammar) 是一系列规则的集合, 每条规则表述出一种词汇结构; Antlr 工具能够将其转换为如同经验丰富的开发者手工构建一般的语法分析器 (Antlr 是一个能够生成其他程序的程序); Antlr 语法本身又遵循了一种专门用来描述其他语言的语法, 称之为 Antlr 元语言 (Antlr's meta-language)  
语法分析过程通常会被分解为两个相似但独立的阶段
- 词法分析 (lexical analysis)
这个过程将字符聚集为单词或者符号 (词法符号, token); 将输入的文本转换为词法符号的程序称之为词法分析器 (lexer); 词法分析器可以将相关的词法符号归类, 当语法分析器不关心单个符号而仅关心符号的类型时, 词法分析器就需要将词汇符号归类; 词法符号包含至少两部分信息: 词法符号的类型和该词法符号对应的文本
- 语法分析
这个过程中输入的词法符号被 "消费" 以识别语句结构; 默认情况下,  Antlr 生成的语法分析器会建造一种名为语法分析树 (parse tree) 或者句法树 (syntax tree) 的数据结构, 该结构记录了语法分析器识别出输入语句结构的过程, 以及该结构的各组成部分

以下展示了数据在一个语言类应用程序中的基本流动过程
```
                                                                   语法分析树
 字符流                           词法符号                             stat
sp = 100;  =>  词法分析器  => [sp][=][100][;]  => 语法分析器  =>         |
                                                                 --- assign ---    
                                                                 |   |    |   |
                                                                sp   =   expr ;
                                                                           |
                                                                          100
```
语法分析树的内部节点是词组名, 这些名字用于识别它们的子节点, 并将子节点归类; 根节点是最抽象的一个名字, 即 stat (statement 的简写), 语法分析树的叶子节点永远是输入的词法符号; 由于使用一系列的规则指定语句的词汇结构, 语法分析树的子树的根节点就对应语法规则的名字; 以下语法规则就对应上图中赋值语句子树的第一级
```
assign: ID '=' expr ';' ; // 匹配一个类似 "sp = 100;" 的赋值语句
```
使用和调试 Antlr 语法的第一个基本要求是, 理解 Antlr 是如何将这样的规则转换为人类可阅读的语法分析程序的

#### 实现一个语法分析器
Antlr 工具依据类似之前的 assign 的语法规则, 产生一个递归下降的语法分析器 (recursive-descent parser); 递归下降的语法分析器实际上是若干递归方法的集合, 每个方法对应一条规则; 下降的过程就是从语法分析树的根节点开始, 朝着叶节点 (词法符号) 进行解析的过程; 首先调用的规则, 即语义符号的起始点, 就会成为语法分析树的根节点; 这种解析过程的更广为人知的名字是 "自上而下的解析", 递归下降的语法分析器仅仅是自上而下的语法分析器的一种实现  
下面是一个 Antlr 根据 assign 规则生产的方法, 用于展示递归下降的语法分析器的实现细节
```
// assign: ID '=' expr ';' ;
void assign() {  // 根据 assign 规则生成的方法
    match(ID);   // 将当前的输入符号和 ID 相比较, 然后将其消费掉
    match('=');  
    expr();      // 通过调用方法 expr() 来匹配一个表达式
    match(";");
}
```
递归下降的语法分析器通过 stat(), assign(), expr() 的调用描绘出的调用路线图映射到了语法分析树的节点上, 调用 match() 对应了语法分析树的叶子节点; 在手工构造的语法分析器中, 需要在每条规则对应的方法的开始位置插入 "增加一个新的字树根节点" 的操作, 在 match() 方法中插入 "增加一个新的叶子节点" 的操作  
assign() 方法仅仅验证所有的词汇贵妇好都存在且顺序正确; 当语法分析器进入到 assign() 方法内部时, 仅有一个备选分支 (alternative), 无须做出选择; 一个备选分支指的是规则的右侧定义的多个方案之一; 例如, 除了 assign 之外, stat 规则还可能有其他多种语句
```
// 从当前输入位置开始, 匹配多种语句
stat: assign  // 第一个备选分支 ('|' 是备选分支的分隔符)
    | ifstat
    | whilestat
```
对 stat 语法的解析就像是一个 switch 语句
```
void stat() {
    switch (<< 当前输入的词法符号 >>) {
        CASE ID: assign(); break;
        CASE IF: ifstat(); break;  // IF 是 if 关键字的词法符号类型
        CASE WHILE: whilestat(); break;
        ...
        default: << 抛出无可选方案的异常 >>
    }
}
```
stat() 方法必须通过下一个词法符号来做出语法分析决策 (parsing decision) 或者预测 (prediction); 做出决策的过程实际上就是判断哪一个备选分支是正确的; 前瞻词法符号 (lookahead token) 是下一个输入的词法符号的术语, 即指任何一个在被匹配和消费之前就由语法分析器嗅探出的词法符号, 有时候可能需要很多个前瞻词法符号来判断语义规则的哪个方案是正确的; Antlr 可以完成这些工作, 对其决策过程的理解有助于调试 Antlr 自动生成的语法分析器

#### 你再也不能往核反应堆多加水了
歧义性语句是指存在不止一种语义的语句
