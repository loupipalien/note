### 快速指南

#### 匹配算术表达式的语言
用自然语言来说, 我们的变大时语言组成的程序就是一系列语言, 每个语句都由换行符终止; 一个语句可以是一个表达式, 一个赋值语句, 或者一个空行; 下面是解析这样的复制语句和表达式的 Antlr 语法
```
// Expr.g4
grammar Expr;
// 起始规则, 语法分析的起点
prog: stat+ ;

stat: expr NEWLINE
    | ID '=' expr NEWLINE
    | NEWLINE
    ;

expr: expr ('*'|'/') expr
    | expr ('+'|'-') expr
    | INT
    | ID
    | '(' expr ')'
    ;

ID : [a-zA-Z]+ ;       // 匹配标识符
INT: [0-9]+ ;          // 匹配整数
NEWLINE: '\r'? '\n' ;  // 告诉语法分析器一个新行的开始
WS : [ \t]+ -> skip ;  // 丢弃空白字符
```
Antlr 语法基本标记通常包含以下元素
- 语法包含一系列描述语言的规则, 这些规则即包括 stat 和 expr 这样的描述语法结构的规则, 也包括描述标识符和整数之类的词汇符号 (词法符号) 的规则
- 语法分析器的规则是以小写字母开头
- 词法分析器的规则是以大写字母开头
- 我们使用 | 来分隔同一个语言规则的若干个备选分支, 使用圆括号把一些符号组合成子规则

Antlr 4 的最重要的新功能之一是, 它能够处理 (大部分情况下的) 左递归规则; 左递归规则是指: 在某个备选分支的起始位置调用了自身

TODO

##### 语法导入
将非常大的语法拆分成逻辑单元通常是个好主意, 拆分的方法之一是将词法和语法分为两部分: 语法分析器语法和词法分析器语法; 这是个不错的方案, 因为在不同语言的词法规则中, 有相当大的一部分是重复的, 将词法规则重构并抽取出称为一个 "模块" 意味着可以将它应用于不同的语法分析器; 以下词法语法包含了上面的 "表达式语法" 中所有的词法规则
```
// CommonLexerRules.g4
lexer grammar CommonLexerRules;  // 注意区别, 是 "lexer gramar"

ID : [a-zA-Z]+ ;       // 匹配标识符
INT: [0-9]+ ;          // 匹配整数
NEWLINE: '\r'? '\n' ;  // 告诉语法分析器一个新行的开始
WS : [ \t]+ -> skip ;  // 丢弃空白字符
```
```
// LibExpr.g4
grammar LibExpr;             // 为了和原先的语法区分开, 执行了重命名
import CommonLexerRules;  // 引入 CommonLexerRules.g4 的全部规则

// 起始规则, 语法分析的起点
prog: stat+ ;

stat: expr NEWLINE
    | ID '=' expr NEWLINE
    | NEWLINE
    ;

expr: expr ('*'|'/') expr
    | expr ('+'|'-') expr
    | INT
    | ID
    | '(' expr ')'
    ;
```
构建和测试过程与重构之前相同, 我们不需要对被导入的语法运行 Antlr

##### 处理有错误的输入
Antlr 语法分析器能够自动报告语法错误并从错误中恢复

#### 利用访问器构建一个计算器
开始之前先要对语法做少量的修改, 首先我们需要给备选的分支加上标签 (这些标签可以是任意字符, 只要和规则名不冲突); 如果备选分支上没有标签, Antlr 就只为每条规则生成一个方法; 这里我们希望每个备选分支都有不同的访问器方法, 这样就可以对每种输入获得一个不同的 "事件"; 标签以 # 开头, 放置在一个备选分支的左侧
```
grammar LabeledExpr;
// 起始规则, 语法分析的起点
prog: stat+ ;

stat: expr NEWLINE              # printExpr
    | ID '=' expr NEWLINE       # assgin
    | NEWLINE                   # blank
    ;

expr: expr op=('*'|'/') expr    # MulDiv
    | expr op=('+'|'-') expr    # AddSub
    | INT                       # int
    | ID                        # id
    | '(' expr ')'              # parens
    ;

MUL: '*' ; // 为上述语法使用的 '*' 命名
DIV: '/' ;
ADD: '+' ;
SUB: '-' ;

ID : [a-zA-Z]+ ;       // 匹配标识符
INT: [0-9]+ ;          // 匹配整数
NEWLINE: '\r'? '\n' ;  // 告诉语法分析器一个新行的开始
WS : [ \t]+ -> skip ;  // 丢弃空白字符
```
TODO

#### 利用监听器构建一个翻译程序
TODO

访问器和监听器机制表现出色, 它们使语法分析过程和程序本身高度分离

#### 定制语法分析过程
监听器和访问器机制是一个创举, 这使得自定义的程序代码和语法本身分离开来, 让语法更具有可读性, 避免了将语法和特定的程序混杂在一起; 不过为了极佳的灵活性和可操作性, Antlr 支持将代码片段 (动作) 嵌入语法中; 这些动作将拷贝到 Antlr 自动生成的递归下降语法分析器的代码中

##### 在语法中嵌入任意动作
如果不想承担建立语法分析树的开销, 我们可以在语法分析的过程中计算并打印结果; 里一个方案是在 "表达式语法" 中嵌入一些代码; 后一种实现难度更高, 因为必须要知道嵌入的动作对语法分析器的影响, 以及在哪里放置这些动作

TODO

##### 使用语义判定改变语法分析过程
TODO

#### 神奇的词法分析特性

##### 孤岛语法: 处理相同文件中的不同格式
TODO

##### 重写输入流
TODO

##### 将词法符号送入不同通道
TODO
