### 设计语法
虽然过去的五十年间人们发明了很多种编程语言, 但是相对而言, 基本的语言模式种类并不多; 这种情况的出现, 是因为人们在设计编程语言时, 倾向于将他它们设计的和脑海中的自然语言类似; 我们期望看到有序的词法符号, 也期望看到词法符号间的依赖关系; 在词法层面上, 不同的编程语言也倾向于使用相同的结构, 例如标识符, 整数, 字符串等等  
对单词顺序和单词间依赖关系的限制来源于自然语言, 逐渐发展为以下四种抽象的计算机语言模式
- 序列: 即一列元素, 例如一个数组初始化语句中的值
- 选择: 在多种可选方案中做出选择, 例如编程语言中的不同种类的语句
- 词法符号依赖: 一个词法符号需要和某处的另外一个词法符号配对, 例如左右括号匹配
- 嵌套结构: 一种自相似的语言结构, 例如编程语言中的嵌套算术表达式或嵌套语句块

为实现以上模式, 我们的语法规则只需要可选方案, 词法符号引用, 规则引用即可 (巴克斯-诺尔范式, Backus-Naur-Format, BNF); 尽管如此, 为了方便起见, 我们还是将这些元素划分为子规则; 子规则是用括号包围的内联规则, 我们可以使用以下符号标记子规则, 用于指明其中的语法片段出现的次数: 可选(?), 出现 0 次或多次(\*), 至少一次(+) (扩展巴克斯-诺尔范式, Extended Backus-Naur-Format, EBNF)

#### 从编程语言的范例代码中提取语法
在深入研究语法的细节之前, 一件大有裨益的事情是: 讨论语法的整体结构以及如何建立初始语法框架; 为了给某种编程语言编写语法, 我们要么精通它, 要么有很多具有代表性的由该语言所编写的样例程序, 再或者有该语言的参考手册  
设计良好的语法反映了编程世界中的功能分解或自顶向下的设计, 这意味着我们对语言结构的辨识是从最粗的粒度开始, 一直进行到最详细的层次, 并把它们编写称为语法规则  
设计起始规则的内容实际上就是使用 "伪代码" 来描述输入文本的整体结构; 例如, "一个 CSV 文件就是一系列以换行符为终止的行" (a comma-sepatated-value [CSV] file is a sequence of rows terminated by newlines), 其中 is a 右侧的 file 就是规则名, 右侧的全部内容就是规则定义中的元素
```
file: <<a sequence of rows terminated by newlines>>
```
接着我们降低一个层次, 描述起始规则右侧所指定的那些元素; 它右侧的名称通常是词法符号或者尚未定义的规则, 其中词法符号是哪些可以轻易识别出的单词, 标点符号, 或者预算符; 词法符号是文法的基本元素, 起始规则引用了其他的, 需要进一步细化的语言结构, 例如上面例子中的 "行"  
在降低一个层次, 可以说一个行就是一系列由逗号分隔的字段 (a row is a sequence of fields separated by commas); 再接下来, 一个字段就是一个数字或者字符串 (a fields a number or string); 伪代码如下所示
```
file: <<a sequence of rows terminated by newlines>>
row: <<a sequence of fields separated by commas>>
field: <<number or string>>
```
当完成对规则的定义后, 我们的语言草稿就成型了; 让我们试着有这种方法来描述一下 Java 文件的关键; 在最粗的粒度上, 一个 Java 的编译单元 (compliation unit) 由一个可选的包声明语句 (package specifier) 和一个或多个类定义 (class definition) 组成; 其中类定义由关键字 class 开始, 之后是一个标识符, 可选的父类名 (superclass specifier), 可选的实现语句 (implements clause), 以及类的定义体 (class body); 一个类的定义体就是由花括号包裹的一系列类成员 (class member), 一个类成员可以是内部类定义, 字段或者方法; 然后再描述字段和方法, 再接下来是方法中的语句等等; 从最高层次开始逐渐向下进行, 将像是 Java 类定义这样巨大的语言结构分解为若干条定义的规则; 伪代码如下
