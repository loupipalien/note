### 设计语法
虽然过去的五十年间人们发明了很多种编程语言, 但是相对而言, 基本的语言模式种类并不多; 这种情况的出现, 是因为人们在设计编程语言时, 倾向于将他它们设计的和脑海中的自然语言类似; 我们期望看到有序的词法符号, 也期望看到词法符号间的依赖关系; 在词法层面上, 不同的编程语言也倾向于使用相同的结构, 例如标识符, 整数, 字符串等等  
对单词顺序和单词间依赖关系的限制来源于自然语言, 逐渐发展为以下四种抽象的计算机语言模式
- 序列: 即一列元素, 例如一个数组初始化语句中的值
- 选择: 在多种可选方案中做出选择, 例如编程语言中的不同种类的语句
- 词法符号依赖: 一个词法符号需要和某处的另外一个词法符号配对, 例如左右括号匹配
- 嵌套结构: 一种自相似的语言结构, 例如编程语言中的嵌套算术表达式或嵌套语句块

为实现以上模式, 我们的语法规则只需要可选方案, 词法符号引用, 规则引用即可 (巴克斯-诺尔范式, Backus-Naur-Format, BNF); 尽管如此, 为了方便起见, 我们还是将这些元素划分为子规则; 子规则是用括号包围的内联规则, 我们可以使用以下符号标记子规则, 用于指明其中的语法片段出现的次数: 可选(?), 出现 0 次或多次(\*), 至少一次(+) (扩展巴克斯-诺尔范式, Extended Backus-Naur-Format, EBNF)

#### 从编程语言的范例代码中提取语法
在深入研究语法的细节之前, 一件大有裨益的事情是: 讨论语法的整体结构以及如何建立初始语法框架; 为了给某种编程语言编写语法, 我们要么精通它, 要么有很多具有代表性的由该语言所编写的样例程序, 再或者有该语言的参考手册  
设计良好的语法反映了编程世界中的功能分解或自顶向下的设计, 这意味着我们对语言结构的辨识是从最粗的粒度开始, 一直进行到最详细的层次, 并把它们编写称为语法规则  
设计起始规则的内容实际上就是使用 "伪代码" 来描述输入文本的整体结构; 例如, "一个 CSV 文件就是一系列以换行符为终止的行" (a comma-sepatated-value [CSV] file is a sequence of rows terminated by newlines), 其中 is a 右侧的 file 就是规则名, 右侧的全部内容就是规则定义中的元素
```
file: <<a sequence of rows terminated by newlines>>
```
接着我们降低一个层次, 描述起始规则右侧所指定的那些元素; 它右侧的名称通常是词法符号或者尚未定义的规则, 其中词法符号是哪些可以轻易识别出的单词, 标点符号, 或者预算符; 词法符号是文法的基本元素, 起始规则引用了其他的, 需要进一步细化的语言结构, 例如上面例子中的 "行"  
在降低一个层次, 可以说一个行就是一系列由逗号分隔的字段 (a row is a sequence of fields separated by commas); 再接下来, 一个字段就是一个数字或者字符串 (a fields a number or string); 伪代码如下所示
```
file: <<a sequence of rows terminated by newlines>>
row: <<a sequence of fields separated by commas>>
field: <<number or string>>
```
当完成对规则的定义后, 我们的语言草稿就成型了; 让我们试着有这种方法来描述一下 Java 文件的关键; 在最粗的粒度上, 一个 Java 的编译单元 (compliation unit) 由一个可选的包声明语句 (package specifier) 和一个或多个类定义 (class definition) 组成; 其中类定义由关键字 class 开始, 之后是一个标识符, 可选的父类名 (superclass specifier), 可选的实现语句 (implements clause), 以及类的定义体 (class body); 一个类的定义体就是由花括号包裹的一系列类成员 (class member), 一个类成员可以是内部类定义, 字段或者方法; 然后再描述字段和方法, 再接下来是方法中的语句等等; 从最高层次开始逐渐向下进行, 将像是 Java 类定义这样巨大的语言结构分解为若干条定义的规则; 伪代码如下
```
compliationUnit: <<optional packageSpec then classDefinitions>>;
packageSpec: 'package' identifier ';';
classDefinition: 'class' <<optional superclassSpec optional implementClause classBody>>;
superclassSpec: 'super' identifier;
implementClause: 'implements' <<one or more identifiers separated by comma>>;
classBody: '{' <<zero or more memberss>> '}';
member: <<nested classDefinition or field or method>>;
...
```
但盲目的遵循已经存在的语法规范可能使你误入歧途

#### 以现有的语法规范为指南
不建议从一门语言的参考手册里拷贝语法并粘贴调试, 请把参考手册当作一份指南, 而非一份代码; 处于使语法清晰的目的, 参考手册的范围通常都非常宽泛, 这意味着其中的语法能够匹配很多实际上不合法的语句; 另一个极端是, 参考手册中的语法对语法规则的约束过于严格, 某些规则最好限制语法分析后的结果, 而非限制语言整体的语法结构

#### 使用 Antlr 语法识别常见的语言模式
常见的语言模式有: 序列(sequence), 选择(choice), 词法符号依赖(token dependency), 嵌套结构(nested phrase)

##### 序列模式
它是一个有限长度或者任意长度的序列, 其中元素可以是词法符号或者子规则; 序列模式的变体包括: 带终止符的序列模式和带分隔符的序列模式; CSV 文件同时使用了这两种模式, 伪代码如下
```
file: (row '\n')*;           // 以一个 '\n' 作为终止符的序列
row: field (',' field)*;     // 以一个 ',' 作为分隔符的序列
field: INT;                  // 假设字段都是整数
```

##### 选择模式 (多个备选分支)
我们使用 | 符号作为 "或者" 来表达编程语言中的选择模式, 在 Antlr 的规则中, 它用于分隔多个可选的语法结构 --- 称作备选分支 (alterantives) 或者可生成的结果 (productions); 上述如 CSV 语法假设字段中允许出现整数或字符串, 伪代码如下
```
field: INT
     | STRING
     ;
```

##### 词法符号依赖模式
即在某个语句中看到了某个符号, 就必须在同一个语句中找到和它匹配的那个符号 (例如成对的各种括号); 为了表达出这种语义, 在语法中我们使用一个序列来指明所有配对的符号, 通常这些符号会把其他元素分组或者包裹起来; 例如方法调用的圆括号, 以及数组索引的方括号
```
expr: expr '(' exprList? ')'    // 类似 f(), f(x), f(1,2) 的函数调用
    | expr '[' expr ']'         // 类似 a[i], a[i][j] 的数组索引
    ...
    ;
```

##### 嵌套模式
嵌套的词组是一种自相似的语言结构, 即它的子词组也遵循相同的结构; 表达式是一种典型的自相似语言结构, 它包含多个嵌套的, 以运算符分隔的子表达式
接下来处理这样一个嵌套结构, 一个 while 表达式由一个关键字 while 开始, 后面是一个在括号中的条件表达式, 再后面就是一条语句, 也可以将多个语句放在花括号中, 当作一个代码块语句使用; 对上述规则的语法表述如下
```
stat: 'while' '(' expr ')' stat   // 匹配 WHILE 语句
    | '{' stat* '}'               // 匹配花括号中若干条语句组成的代码块
    ...                           // 其他种类语句
    ;
```
其中, while 中的 stat 是一个循环结构, 它可以是一个语句或者由花括号包裹的一组语句; 因为 stat 规则在前两个备选分支中引用了自身, 我们称之为直接递归 (directly recursive) 的; 如果我们将它的第二个备选分支抽取出来, stat 规则和 block 规则就会互为间接递归 (indirectly recursive) 的
```
stat: 'while' '(' expr ')' stat   // 匹配 WHILE 语句
    | block                       // 匹配一个语句组成的代码块
    ...                           // 其他种类语句
    ;

block: '{' stat* '}'              // 匹配花括号中若干条语句组成的代码块
```

下表是 Antlr 的核心语法标记

| 用法 | 描述 |
| :--- | :--- |
| x | 匹配词法符号, 规则引用或者子规则 x |
| x y ... z | 匹配一列规则元素 |
| (...|...|...) | 一个具有多个备选分支的子规则 |
| x? | 匹配 x 零次或一次 |
| x* | 匹配 x 零次或多次 |
| x+ | 匹配 x 一次或多次 |
| r: ...; | 定义规则 r |
| r: ...|...|...; | 定义具有多个备选分支的规则 r |

下表是常见的计算机语言的模式

| 模式名 | 描述 |
| :--- | :--- |
| 序列模式 | TODO |
| 带终止符的序列模式 | TODO |
| 带分隔符的序列模式 | TODO |
| 选择模式 | TODO |
| 词法符号依赖 | TODO |
| 嵌套模式 | TODO |

#### 处理优先级, 左递归, 结合性
TODO

#### 识别常见的词法结构
和语法分析器一样, 词法分析器也使用规则来描述种类繁多的语言结构; 在 Antlr 中, 我们使用的是几乎完全相同的标记; 唯一的差别在于, 语法分析器通过输入的词法符号流来识别特定的语言结构, 而词法分析器通过输入的字符流来识别特定的语言结构; 由于词法规则和语法规则的结构相似, Antlr 允许二者在同一个语法文件中同时粗在, 不过由于词法分析和语法分析是语言识别过程中的两个不同阶段, Antlr 约定词法规则以大写字母开头, 语法规则以小写字母开头

##### 匹配标识符
在语法的伪代码中, 一个基本的标识符就是一个由大小写字母组成的字符序列; 可以使用之前叙述的 (..)+ 来表达序列模式; 因为序列中的元素可以是大写字母也可以是小写字母, 可表示为如下规则
```
ID: ('a'...'z'|'A'..'Z')+;  // 匹配一个或多个大小写字母
```
此外, Antlr 还支持正则表达式中用于表示字符集的缩写
```
ID: [a-zA-Z]+;  // 匹配一个或多个大小写字母
```
类似 ID 的规则有时候会和其他词法规则或者字符串常量产生冲突, 例如以下示例
```
grammar KeyWordTest:
enumDef: 'enum' '{' ... '}'
...
FOR: 'for'
...
ID: [a-zA-Z]+;  // 不会匹配 'enum' 和 'for'
```
ID 规则也能够匹配类似 enum 和 for 的关键字, 这意味着不止一种规则可以匹配相同的输入字符串;  在 Antlr 中, 对于这种混合了语法规则和词法规则的语法文件的处理机制, Antlr 首先从语法规则中筛选出所有的字符串常量, 并将它们和词法规则放在一起; 'enum' 这样的字符串常量被隐式定义为词法规则, 然后放置在语法规则之后, 显式定义词法规则之前; Antlr 词法解析器解决歧义问题的方法是优先使用位置靠前的词法规则, 这意味着关键字规则会优先于显示定义的词法规则匹配

##### 匹配数字
整数的描述
```
INT: '0'..'9'+;  // 匹配一个或多个数字
```
或者
```
INT: [0-9]+;  // 匹配一个或多个数字
```
浮点数的描述相对复杂, 这里是一个简化的版本
```
FLOAT: DIGIT+ '.' DIGIT*  // 匹配 1.39， 3.1415926 等
     |        '.' DIGIT+  // 匹配 .1, .1415926 等
     ;

fragment
DIGIT: [0-9];  // 匹配单个数字
```
在这里, 我们使用了一条辅助规则 DIGIT, 这样就不用重复书写 [0-9]+ 了; 将一条规则声明为 fragment 可以告诉 Antlr, 该规则本身不是一个词法符号, 它只会被其他的词法规则使用; 这意味着我们不能在语法规则中引用 DIGIT

##### 匹配字符串常量
计算机语言共有的词法符号是类似 "Hello" 的字符串常量; 大多数语言使用双引号, 也有少数语言使用单引号, 无论哪种符号, 我们都使用同一种规则来匹配字符串常量: 识别分界符之间的全部内容; 用语法伪代码表示, 一个字符串就是两个引号之间的任意的字符序列
```
SRING: '"' .*? '"';  / 匹配 "..." 间的任意文本
```
