### 确保 Web 安全的 HTTPS

#### HTTP 的缺点
- 通信使用明文 (不加密), 内容可被窃听
- 不验证通信方的身份, 因此有可能遭遇伪装
- 无法证明报文的完整性, 所以可能遭篡改

##### 通信使用明文可能会被窃听
由于 HTTP 本身不具备加密的功能, 所以也无法做到做通信整体进行加密; 即 HTTP 报文使用明文方式发送
###### TCP/IP 是可能被窃听的网络
因为 TCP/IP 协议族的工作机制, 通信内容在所有的通信线路上都有可能遭到窥视
###### 加密处理防止被窃听
分为通信的加密和内容的加密

##### 不验证通信方的身份就可能遭遇伪装
HTTP 协议中的请求和响应不会对通信方进行确认; 也就是说存在 "服务器是否就是发送请求中的 URI 真正指定的主机, 返回的响应是否真的返回到实际提出请求的客户端" 的问题
###### 任何人都可发起请求
HTTP 协议不论是谁发送过来的请求都会返回响应, 因此不确认通信方, 会存在以下各种隐患
- 无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器; 有可能是伪装的 Web 服务器
- 无法确定响应返回到的客户端是否是真实意图接收响应的那个客户端; 有可能是伪装的客户端
- 无法确定正在通信的对方是否具备访问权限; 因为某些 Web 服务器上保存着重要的信息, 只发给特定用户通信的权限
- 无法判定请求是来自何方, 出自谁手
- 即使是无意义的请求也会照单全收; 无法阻止海量请求下的 DoS 攻击 (Denail of Service, 拒绝服务攻击)
###### 查明对手的证书
虽然使用 HTTP 协议无法确定通信方, 但如果使用 SSL 则可以; SSL 不仅提供加密处理, 而且还使用了一种被称为证书的手段, 可以用于确定通信方; 证书由值得信任的第三方机构颁发, 用以证明服务器和客户端是实际存在的; 另外伪造证书从技术角度来说是异常困难的事

##### 无法证明报文完整性可能已遭篡改
所谓完整性是指信息的准确度; 若无法证明其完整性, 通常也就意味着无法判断信息是否准确
###### 接收到的内容可能有误
由于 HTTP 协议无法证明通信的报文完整性, 因此在请求或响应送出之后直到对方接收之前这段时间, 即使请求或响应的内容遭到篡改, 也没有办法获悉
###### 如何防止篡改
使用 MD5 或 SHA-1 等散列值校验方法确定报文的完整性并不便捷, 而且 MD5 或 SHA-1 的值也存在被篡改的可能; 为放置这些弊端, 有必要使用 HTTPS, SSL 提供认证和加密处理即摘要功能

#### HTTP + 加密 + 认证 + 完整性保护 = HTTPS
##### HTTP 加上加密处理和认证以及完整性保护后即是 HTTPS
添加了加密及认证机制的 HTTP 称为 HTTPS (HTTP Secure)
##### HTTPS 是身披 SSL 外壳的 HTTP
HTTPS 并非是应用层的一种协议; 只是 HTTP 通信接口部分用 SSL (Secure Socket Layer) 和 TLS (Transport Layer Security) 协议代替; 通常 HTTP 直接和 TCP 通信, 当使用 SSL 时则演变为先和 SSL 通信, 再由 SSL 和 TCP 通信了

##### 相互交换密钥的公开密钥加密技术
SSL 采用一种叫做公开密钥加密 (Public-key cryptography) 的加密处理方式
###### 共享密钥加密的困境
加密和解密同用一个密钥的方式称为共享密钥加密 (Common key crypto system), 也叫做对称密钥加密; 但存在的困境是如何安全的发送密钥
###### 使用两把密钥的公开密钥加密
公开密钥加密方式很好的解决了共享密钥加密的困难; 公开密钥加密使用一对非对称的密钥, 一把叫做私有密钥 (private key), 另一把叫做公开密钥 (public key); 使用公开密钥加密方式, 发送密文的一方使用对方的公开密钥进行加密处理, 对方收到被加密的信息后, 在使用自己的私有密钥进行解密
###### HTTPS 采用混合加密机制
HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制, 若密钥能够实现安全交换, 那么可考虑仅使用公开密钥加密来通信, 但是公开密钥加密与共享密钥加密相比, 其处理速度慢; 可将两者的优势结合起来使用, 在交换密钥环节使用公开加密方式, 之后建立通信交换报文阶段则使用共享密钥加密方式

##### 证明公开密钥正确性的证书
但遗憾的是公开密钥加密还是存在一些问题, 即无法证明公开密钥本身就是货真价实的公开密钥; 比如, 正准备和某台服务器建立公开密钥加密方式下的通信时, 如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥, 或许在公开密钥的传输过程中已经被替换了  
为了解决上述问题, 可以使用由数字证书认证机构 (CA, Certificate Authority) 和其相关机关颁发的公开密钥证书; 以下为数字证书认证机构的业务流程
- 首向服务器的运营人员向数字证书认证机构提出公开密钥的申请
- 数字整数认证机构在判明提出申请者的身份之后, 会对已申请的公开密钥做数字签名, 然后分配这个已签名的公开密钥, 并将该公开密钥放入公钥证书后绑定在一起
- 服务器会将这份由数字证书机构颁发的公钥证书发送给客户端, 以进行公开密钥加密方式通信
- 接到证书的客户端使用数字证书认证机构的公开密钥, 对公钥证书上的数字签名进行验证, 一旦验证通过客户端则可明确两件事情, 一是认证服务器的公开密钥的是真实有效的数字证书认证机构, 二是服务器公开密钥是值得信赖的
- 此处认证机关的公开密钥必须安全的转交给客户端; 使用通信方式时安全转交是很困难的事, 因此多数浏览器开放商预置了常用认证机构的公开密钥

###### 可证明组织真实性的 EV SSL 证书
TODO
###### 用以确认客户端的客户端证书
TODO
###### 认证机构信誉第一
TODO
###### 由自认证机构颁发的证书称为自签名证书
TODO

##### HTTPS 的安全通信机制
以下为 HTTPS 的通信步骤
- 客户端通过发送 Client Hello 报文开始 SSL 通信, 报文中包含客户端支持的 SSL 的指定版本, 加密组件 (Cipher Suite) 列表 (所使用的加密算法及密钥长度等)
- 服务器可进行 SSL 通信时, 会以 Server Hello 报文作为应答; 和客户端一样, 在报文中包含 SSL 版本以及加密组件; 服务器的加密组件内容是从接收的客户端加密组件中筛选出来的
- 之后服务器发送 Certificate 报文, 报文中包含公开密钥证书
- 最后服务器发送 Server Hello Done 报文通知客户端, 最初阶段的 SSL 握手协商部分结束
- SSL 第一次握手结束之后, 客户端以 Client Key Exchange 报文作为回应, 报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串; 该报文已用步骤三的公开密钥进行加密
- 接着客户端继续发送 Change Cipher Spec 报文, 该报文会提示服务器, 在此报文之后的通信会采用 Pre-master secret 密钥加密
- 客户端发送 Finished 报文, 该报文包含连接至今全部报文的整体校验值; 这次握手是否成功, 要以服务器是否能够正确解密该报文作为判定标准
- 服务器同样发送 Change Cipher Spec 报文
- 服务器同样发送 Finished 报文
- 服务器和客户端的 Finished 报文交换完毕之后, SSL 连接建立完成; 当然, 通信会受到 SSL 的保护, 从此处开始进行应用层协议的通信, 即发送 HTTP 请求
- 应用层协议通信, 即发送 HTTP 响应
- 最后由客户端断开连接, 断开连接时发送 close_notify 报文

###### SSL 和 TSL
HTTPS 使用 SSL 和 TSL 这两个协议, 主要版本为 SSL3.0 和 TSL1.0

###### SSL 慢
分两种, 一是通信慢, 二是由于大量消耗 CPU 及内存资源导致处理速度变慢
