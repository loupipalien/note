### Git 基础

#### 获取 Git 仓库
通常有两种获取 Git 项目仓库的方式
- 将尚未进行版本控制的本地目录转换为 Git 仓库
- 从其它服务器 克隆 一个已存在的 Git 仓库

两种方式都会在你的本地机器上得到一个工作就绪的 Git 仓库

##### 在已存在目录中初始化仓库
TODO

##### 克隆现有的仓库
TODO

#### 记录每次更新到仓库
Git 仓库工作目录下的每一个文件都不外乎这两种状态: **已跟踪** 或 **未跟踪**
已跟踪的文件是指那些被纳入了版本控制的文件, 在上一次快照中有它们的记录; 在工作一段时间后, 它们的状态可能是未修改, 已修改或已放入暂存区; 简而言之, 已跟踪的文件就是 Git 已经知道的文件  
工作目录中除已跟踪文件外的其它所有文件都属于未跟踪文件, 它们既不存在于上次快照的记录中，也没有被放入暂存区  
![文件的状态变化周期](https://git-scm.com/book/en/v2/images/lifecycle.png)

##### 检查当前文件状态
可以用 `git status` 命令查看哪些文件处于什么状态

##### 跟踪新文件
使用命令 `git add` 开始跟踪一个文件; 所以要跟踪 README 文件, 运行 ```
$ git add README
```
`git add` 命令使用文件或目录的路径作为参数; 如果参数是目录的路径, 该命令将递归地跟踪该目录下的所有文件

##### 暂存已修改的文件
`git add` 命令, 是个多功能命令: 可以用它开始跟踪新文件, 或者把已跟踪的文件放到暂存区, 还能用于合并时把有冲突的文件标记为已解决状态等; 将这个命令理解为 `精确地将内容添加到下一次提交中` 而不是 `将一个文件添加到项目中”要更加合适`

##### 状态简览
`git status` 命令的输出十分详细, 但其用语有些繁琐; 使用 `git status -s` 命令或 `git status --short` 命令, 将得到一种格式更为紧凑的输出
```
$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
```
新添加的未跟踪文件前面有 `??` 标记, 新添加到暂存区中的文件前面有 `A` 标记, 修改过的文件前面有 `M` 标记; 输出中有两栏, 左栏指明了暂存区的状态, 右栏指明了工作区的状态; 例如, 上面的状态报告显示: `README` 文件在工作区已修改但尚未暂存, 而 `lib/simplegit.rb` 文件已修改且已暂存; `Rakefile` 文件已修暂存后又作了修改, 因此该文件的修改中既有已暂存的部分, 又有未暂存的部分

##### 忽略文件
一般我们总会有些文件无需纳入 Git 的管理, 也不希望它们总出现在未跟踪文件列表; 在这种情况下, 可以创建一个名为 `.gitignore` 的文件, 列出要忽略的文件的模式; 文件 `.gitignore` 的格式规范如下
- 所有空行或者以 `#` 开头的行都会被 Git 忽略。
- 可以使用标准的 **glob 模式** 匹配, 它会递归地应用在整个工作区中
- 匹配模式可以以 `/` 开头防止递归
- 匹配模式可以以 `/` 结尾指定目录
- 要忽略指定模式以外的文件或目录, 可以在模式前加上叹号 `!` 取反

所谓的 glob 模式是指 shell 所使用的简化了的正则表达式
- 星号 `*` 匹配零个或多个任意字符
- [abc] 匹配任何一个列在方括号中的字符 (这个例子要么匹配一个 a, 要么匹配一个 b, 要么匹配一个 c)
- 问号 `?` 只匹配一个任意字符
- 如果在方括号中使用短划线分隔两个字符, 表示所有在这两个字符范围内的都可以匹配 (比如 `[0-9]` 表示匹配所有 0 到 9 的数字)
- 使用两个星号 `**` 表示匹配任意中间目录, 比如 `a/**/z` 可以匹配 `a/z`, `a/b/z`, `a/b/c/z` 等

##### 查看已暂存和未暂存的修改
要查看尚未暂存的文件更新了哪些部分, 不加参数直接输入
```
$ git diff
```
此命令比较的是工作目录中当前文件和暂存区域快照之间的差异, 也就是修改之后还没有暂存起来的变化内容   
要查看已暂存的将要添加到下次提交里的内容, 可以用
```
git diff --staged
```
这条命令将比对已暂存文件与最后一次提交的文件差异

##### 提交更新
现在的暂存区已经准备就绪，可以提交了; 每次准备提交前, 先用 `git status` 看下所需要的文件是不是都已暂存起来了, 然后再运行提交命令
```
$ git commit
```
这样会启动你选择的文本编辑器来输入提交说明; 另外也可以在 `commit` 命令后添加 `-m` 选项, 将提交信息与命令放在同一行

##### 跳过使用暂存区域
尽管使用暂存区域的方式可以精心准备要提交的细节, 但有时候这么做略显繁琐; Git 提供了一个跳过使用暂存区域的方式, 只要在提交的时候给 `git commit` 加上 `-a` 选项, Git 就会自动把所有已经跟踪过的文件暂存起来一并提交, 从而跳过 `git add` 步骤

##### 移除文件
要从 Git 中移除某个文件, 就必须要从已跟踪文件清单中移除 (确切地说，是从暂存区域移除), 然后提交; 可以用 `git rm` 命令完成此项工作, 并连带从工作目录中删除指定的文件, 这样以后就不会出现在未跟踪文件清单中了  
如果要删除之前修改过或已经放到暂存区的文件, 则必须使用强制删除选项 `-f` (译注: 即 force 的首字母) 这是一种安全特性, 用于防止误删尚未添加到快照的数据, 这样的数据不能被 Git 恢复  
另外一种情况是, 想把文件从 Git 仓库中删除 (亦即从暂存区域移除), 但仍然希望保留在当前工作目录中; 换句话说, 想让文件保留在磁盘但是并不想让 Git 继续跟踪, 为达到这一目的可使用 `--cached` 选项

##### 移动文件
不像其它的 VCS 系统, Git 并不显式跟踪文件移动操作; 如果在 Git 中重命名了某个文件, 仓库中存储的元数据并不会体现出这是一次改名操作; 不过 Git 非常聪明，它会推断出究竟发生了什么  
运行 `git mv` 就相当于运行了下面三条命令
```
$ mv README.md README
$ git rm README.md
$ git add README
```
如此分开操作, Git 也会意识到这是一次重命名, 所以不管何种方式结果都一样;  两者唯一的区别是, `mv` 是一条命令而非三条命令, 直接用 `git mv` 方便得多

#### 查看提交历史
在提交了若干更新, 又或者克隆了某个项目之后, 也许想回顾下提交历; 完成这个任务最简单而又有效的工具是 `git log` 命令  
不传入任何参数的默认情况下, `git log` 会按时间先后顺序列出所有的提交, 最近的更新排在最上面; 这个命令会列出每个提交的 SHA-1 校验和, 作者的名字和电子邮件地址, 提交时间以及提交说明  
`git log` 命令的 `-p` 或 `--patch` 选项, 它会显示每次提交所引入的差异 (按 **补丁** 的格式输出), 也可以限制显示的日志条目数量, 例如使用 `-2` 选项来只显示最近的两次提交
- --stat 参数
- --pretty 参数
- --graph 参数

##### 限制输出长度
TODO

#### 撤消操作
有时候我们提交完了才发现漏掉了几个文件没有添加, 或者提交信息写错了; 此时可以运行带有 `--amend` 选项的提交命令来重新提交
```
git commit --amend
```
这个命令会将暂存区中的文件提交; 如果自上次提交以来你还未做任何修改 (例如，在上次提交后马上执行了此命令), 那么快照会保持不变, 而你所修改的只是提交信息  
例如, 你提交后发现忘记了暂存某些需要的修改, 可以像下面这样操作
```
$ git commit -m 'initial commit'
$ git add forgotten_file
$ git commit --amend
```
最终你只会有一个提交, 第二次提交将代替第一次提交的结果

##### 取消暂存的文件
使用  `git reset HEAD <file>...` 可以来取消暂存, 所以可以这样来取消已暂存的文件

##### 撤消对文件的修改
`git checkout -- <file>...` 命令可以方便地撤消修改工作区的文件将它还原成上次提交时的样子

#### 远程仓库的使用
远程仓库是指托管在因特网或其他网络中的你的项目的版本库, 你可以有好几个远程仓库, 通常有些仓库对你只读, 有些则可以读写; 与他人协作涉及管理远程仓库以及根据需要推送或拉取数据, 管理远程仓库包括了解如何添加远程仓库, 移除无效的远程仓库, 管理不同的远程分支并定义它们是否被跟踪等等

##### 查看远程仓库
如果想查看你已经配置的远程仓库服务器, 可以运行 `git remote` 命令, 它会列出你指定的每一个远程服务器的简写; 如果你已经克隆了自己的仓, 那么至少应该能看到 `origin`, 这是 Git 给你克隆的仓库服务器的默认名字  
也可以指定选项 `-v`, 会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL

##### 添加远程仓库
运行 `git remote add <shortname> <url>` 添加一个新的远程 Git 仓库, 同时指定一个方便使用的简写  
现在可以在命令行中使用短名称 (假设是 `pb`) 来代替整个 URL, 例如想拉取 URL 指定的仓库中有但你没有的信息, 可以运行 `git fetch pb`

##### 从远程仓库中抓取与拉取
从远程仓库中获得数据, 可以执行
```
$ git fetch <remote>
```
这个命令会访问远程仓库, 从中拉取所有你还没有的数据, 执行完成后, 将会拥有那个远程仓库中所有分支的引用, 可以随时合并或查看  
如果你使用 `clone` 命令克隆了一个仓库, 命令会自动将其添加为远程仓库并默认以 `origin` 为简写; 所以 `git fetch origin` 会抓取克隆 (或上一次抓取) 后新推送的所有工作; 必须注意 `git fetch` 命令只会将数据下载到你的本地仓库, 它并不会自动合并或修改你当前的工作; 当准备好时你必须手动将其合并入你的工作  
如果你的当前分支设置了跟踪远程分支, 那么可以用 `git pull` 命令来自动抓取后合并该远程分支到当前分支, 这或许是个更加简单舒服的工作流程; 默认情况下, `git clone` 命令会自动设置本地 `master` 分支跟踪克隆的远程仓库的 `master` 分支 (或其它名字的默认分支), 运行 `git pull` 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支

##### 推送到远程仓库
当想分享你的项目时, 必须将其推送到上游; 这个命令很简单: `git push <remote> <branch>`; 当你想要将 `master` 分支推送到 `origin` 服务器时, 那么运行这个命令就可以将你所做的备份到服务器
```
$ git push origin master
```
只有当你有所克隆服务器的写入权限, 并且之前没有人推送过时, 这条命令才能生效; 当你和其他人在同一时间克隆, 他们先推送到上游然后你再推送到上游, 你的推送就会毫无疑问地被拒绝,  你必须先抓取他们的工作并将其合并进你的工作后才能推送

##### 查看某个远程仓库
如果想要查看某一个远程仓库的更多信息, 可以使用 `git remote show <remote>` 命令

##### 远程仓库的重命名与移除
可以运行 `git remote rename <old_shortname> <new_shortname>` 来修改一个远程仓库的简写名
可以运行 `git remote remove <shortname>` 来移除一个远程仓库

#### 打标签
像其他版本控制系统 (VCS) 一样, Git 可以给仓库历史中的某一个提交打上标签以示重要

##### 列出标签
在 Git 中列出已有的标签非常简单, 只需要输入 `git tag` (可带上可选的 `-l` 选项 `--list`)

##### 创建标签
Git 支持两种标签: 轻量标签 (lightweight) 与附注标签 (annotated)  
轻量标签很像一个不会改变的分支, 它只是某个特定提交的引用; 而附注标签是存储在 Git 数据库中的一个完整对象, 它们是可以被校验的, 其中包含打标签者的名字, 电子邮件地址, 日期时间, 此外还有一个标签信息, 并且可以使用 GNU Privacy Guard （GPG）签名并验证; 通常会建议创建附注标签, 这样你可以拥有以上所有信息; 但是如果你只是想用一个临时的标签, 或者因为某些原因不想要保存这些信息, 那么也可以用轻量标签

##### 附注标签
在 Git 中创建附注标签十分简单, 最简单的方式是当你在运行 `tag ` 命令时指定 `-a` 选项, `-m` 选项指定了一条将会存储在标签中的信息

##### 轻量标签
另一种给提交打标签的方式是使用轻量标签, 轻量标签本质上是将提交校验和存储到一个文件中, 没有保存任何其他信息

##### 后期打标签
也可以对过去的提交打标签, `git tag -a v1.2 <sha1-sum>`

##### 共享标签
默认情况下, `git push` 命令并不会传送标签到远程仓库服务器上; 在创建完标签后你必须显式地推送标签到共享服务器上, 这个过程就像共享远程分支一样, 你可以运行 `git push origin <tagname>`  
如果想要一次性推送很多标签, 也可以使用带有 `--tags` 选项的 `git push` 命令; 这将会把所有不在远程仓库服务器上的标签全部传送到那里

##### 删除标签
要删除掉你本地仓库上的标签, 可以使用命令 `git tag -d <tagname>`  
注意上述命令并不会从任何远程仓库中移除这个标签, 必须用 `git push <remote> :refs/tags/<tagname>` 来更新远程仓库, 这种操作的含义是, 将冒号前面的空值推送到远程标签名, 从而高效地删除它; 另外一种方式是 `git push origin --delete <tagname>`

##### 检出标签
如果你想查看某个标签所指向的文件版本, 可以使用 `git checkout` 命令, 虽然这会使你的仓库处于 `分离头指针 (detacthed HEAD)` 的状态; 这个状态有些不好的副作用, 在 `分离头指针` 状态下, 如果做了某些更改然后提交它们, 标签不会发生变化, 但你的新提交将不属于任何分支, 并且将无法访问, 除非通过确切的提交哈希才能访问; 因此如果需要进行更改, 比如要修复旧版本中的错误, 那么通常需要创建一个新分支
```
git checkout -b <branchname> <tagname>
```
如果在这之后又进行了一次提交, 新分支就会因为这个改动向前移动, 此时它就会和 v2.0.0 标签稍微有些不同

#### 别名
如果不想每次都输入完整的 Git 命令, 可以通过 git config 文件来轻松地为每一个命令设置一个别名
```
$ git config --global alias.co checkout
$ git config --global alias.br branch
$ git config --global alias.ci commit
$ git config --global alias.st status
```

#### 总结
TODO

>**参考:**
- [Git 基础](https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%8E%B7%E5%8F%96-Git-%E4%BB%93%E5%BA%93)
