### Nginx 服务器架构初探

#### 模块化结构

##### 什么是模块化结构
模块化没有一个统一的概念, 但模块化一般可以从中提出几层含义
- 功能块是对模块的描述, 一个模块就是一个功能块, 应该只负责一个功能, 这对应于设计模式中的单一职责原则
- 如果要体现模块化, 就免不了对程序进行分解,  这对应于设计模式中的自顶向下逐步求精原则
- 一个程序被分解为多个模块, 那么它们之间一定要存在一定的依赖关系, 但是这个依赖不能太强, 需要高内聚低耦合; 这对应于设计模式中的迪米特原则

##### Nginx 模块化结构
Nginx 的模块主要分为五大类
- 核心模块: 如进程管理, 权限控制, 错误日志记录等
- 标准 HTTP 模块: 支持 Nginx 服务器的标准 HTTP 功能
- 可选 HTTP 模块: 支持 Nginx 服务器的扩展标准 HTTP 功能
- 邮件服务模块: 支持 Nginx 的邮件服务
- 第三方模块: 为了扩展 Nginx 服务应用, 完成特殊功能而有第三方机构或个人编写的可编译到 Nginx 中的模块

TODO

#### Nginx 服务器的 Web 请求处理机制
Web 服务器和客户端是一对多的关系, Web 服务必须有能力同时为多个客户端提供服务; 一般来说, 完成并行处理请求工作有三种方式可选择: 多进程方式, 多线程方式, 异步方式

##### 多进程方式 (如 Apache 服务器)
多进程方式是指, 服务器每当接收到一个客户端时, 就由服务器主进程生成一个子进程出来和该客户端建立连接进行交互, 直到连接断开, 该子进程就结束了  
多进程方式的优点在于, 设计和实现相对简单, 各个子进程之间相互独立, 处理客户端请求过程彼此不受到干扰, 并且当一个子进程产生问题时, 不容易将影响蔓延到其他进程中, 这保证了提供服务的稳定性; 当子进程退出时, 其占用资源会被操作系统回收, 也不会留下任何垃圾; 其缺点也是很明显的, 操作系统中生成一个子进程需要进行内存复制等操作, 在资源和时间上会产生一定的额外开销, 因此如果 Web 服务其接收大量并发请求, 就会对系统资源造成压力, 导致系统性能下降

##### 多线程方式 (如 IIS 服务器)
多线程方式和多进程方式相似, 它是值服务器每当接收到一个客户端时, 会由服务器主进程派生一个线程出来和客户端进行交互  
由于操作系统产生一个线程的开销远远小于产生一个进程的开销, 所以多线程方式在很大程度上减轻了 Web 服务器对系统资源的要求; 在线程管理方面, 该方式有一定的不足, 多线程位于同一个进程内, 可以访问同样的内存空间, 彼此之间相互影响; 同时在开发过程中不可避免的要求开发者自己对内存进行管理, 这增加了出错的风险; 服务器需要长时间不停的运行, 错误的逐渐积累可能最终对整个服务器产生重大影响

##### 异步方式
异步方式是和多进程方式和多线程方式完全不同的一种处理客户端请求的方式; 在这之前先了解一下 `同步, 异步, 阻塞, 非阻塞` 这几个概念  
网络通信中的同步机制和异步机制是描述通信模式的概念; 同步机制是指发送方发送请求后, 需要等待接收到接收方发回的响应后, 才接着发送下一个请求; 异步机制和同步机制相反, 在异步机制中, 发送方发出一个请求后, 不等待接收方响应这个请求, 就继续发送下个请求; 在同步机制中, 所有的请求在服务器端得到同步, 发送方和接收方的处理步调是一致的; 在异步机制中, 所有来自发送方的请求形成一个队列, 接收方处理完成后通知发送方  
阻塞和非阻塞用来描述进程处理调用的方式, 在网络通信中, 主要指网络套接字 Socket 的阻塞和非阻塞方式, 而 Socket 的实质也就是 IO 操作; Socket 的阻塞调用方式为, 调用结果返回之前, 当前线程从运行状态被挂起, 一直等到调用结果返回之后, 才进入就绪状态获取 CPU 后继续执行; Socket 的非阻塞调用结果方式和阻塞调用方式相反, 在非阻塞方式中, 如果调用结果不能马上返回, 当前线程也不会别挂起, 而是立即返回执行下一个调用  
这两对概念有一定的区别, 不能混淆; 两队概念的组合, 就会产生四个新的概念: `同步阻塞, 异步阻塞, 同步非阻塞, 异步非阻塞`
- 同步阻塞
发送方向接收方发送请求后, 一直等待响应; 接收方处理请求时进行的 IO 操作如果不能马上得到结果, 就一直等待到返回结果才响应发送方, 期间不能进行其他工作
- 同步非阻塞 (实际中不会使用这种方式)
发送方向接收方发送请求后, 一直等待响应; 接收方处理请求时进行的 IO 操作如果不能马上得到结果, 就立即返回去做其他事情, 但由于没有得到请求处理结果, 不响应发送方, 发送方一直等待; 一直到 IO 操作完成之后, 接收方获得结果响应发送方后, 接收方在进入下一个请求过程
- 异步阻塞 (实际中不会使用这种方式)
发送方向接收方发送请求后, 不用等待响应, 可以接着进行其他工作; 接收方处理请求时进行的 IO 操作如果不能马上得到结果, 就一直等到返回结果后, 才响应发送方, 期间不能进行其他工作
- 异步非阻塞
发送方向接收方发送请求后, 不用等待响应, 可以继续其他工作; 接收方处理请求时进行的 IO 操作如果不能马上得到结果, 也不等待而是马上返回去做其他事情; 当 IO 操作完成之后, 将完成状态和结果通知接收方, 接收方再响应发送方

##### Nginx 服务器如何处理请求
Nginx 服务器的一个显著优势是能够同时处理大量并发请求, 它结合多进程机制和异步机制对外提供服务  
Nginx 服务器启动之后, 可以产生一个主进程和多个工作进程, 其中可以在配置文件中指定产生的工作进程数量  
每个工作进程使用了异步非阻塞方式, 可以处理多个客户端请求; 当某个工作进程接收到客户端的请求后, 调用 IO 进行处理, 如果不能立即得到结果, 就去处理其他请求; 而客户端在此期间也无需等待响应, 可以去处理其他的事情; 当 IO 调用返回结果时, 就会通知此工作进程, 该进程得到通知, 暂时挂起当前处理的事务, 去响应客户端请求

##### Nginx 服务器的时事件处理机制
Nginx 服务器的工作进程调用 IO 后, 就去进行其他工作了, 当 IO 调用返回后, 会通知工作进程; 这里有一个问题, IO 调用是如何把自己的状态通知给工作进程的呢  
一般解决这个问题的方案有两种, 一是让工作进程在进行其他工作的过程中间隔一段时间就去检查一次 IO 的运行状态, 如果完成就去响应客户端, 如果未完成就继续正在进行的工作; 二是 IO 调用在完成后能主动通知工作进程; 对于前者, 虽然工作进程在 IO 调用的过程中没有等待, 但不断的见擦汗仍然在时间和资源上导致了不小的开销, 最理想的解决方案是第二种  
具体来说m select/poll/epoll/kqueue 等这样的系统调用就是用来支持第二种方案的; 这些系统调用也被称为事件驱动模型, 它们提供一种机制, 让进程可以同时处理多个并发请求, 不用关心 IO 调用的具体状态; IO 调用完全由事件驱动模型来管理, 事件准备好之后就通知工作进程事件已经就绪

#### Nginx 服务器的事件驱动模型
事件驱动模型是 Nginx 服务器保障完整功能和具有良好性能的重要机制之一
##### 事件驱动模型概述
事件驱动模型一般是由事件收集器, 事件发送器, 事件处理器三部分基本单元组成
##### Nginx 中的事件驱动模型
在编写服务器处理模型的程序时, 基于事件驱动模型, "目标对象" 中的 "事件处理器" 可以有以下几种办法
- "事件发送器" 每传递过来一个请求, "目标对象" 就创建一个新的进程, 调用 "事件处理器" 来处理该请求
- "事件发送器" 每传递过来一个请求, "目标对象" 就创建一个新的线程, 调用 "事件处理器" 来处理该请求
- "事件发送器" 每传递过来一个请求, "目标对象" 就将其放入一个待处理事件列表, 使用非阻塞 IO 方式调用 "事件处理器" 来处理该请求

第三种方式, 逻辑比前两种复杂但性能优秀, 大多数网络服务器采用了第三种方式, 逐渐形成所谓的 "事件驱动处理库"; 事件驱动处理库又被称为多路 IO 复用方法, 最常见的包括以下三种: select, poll, epoll; 除此之外, Nginx 服务器还支持 rtsig 模型, kqueue 模型, dev/poll 模型, eventport 模型等

##### select 库
select 库是各个版本的 Linux 和 Windows 平台都支持的基本事件驱动模型库, 并且在接口的定义上也基本相同, 只是部分参数的含义略有差异; 使用 select 库的步骤一般是
- 首向, 创建所关注事件的描述符集合, 对于一个描述符, 可以关注上面的读事件, 写事件, 异常发生事件, 所以需要创建三类事件描述符集合, 分别用来收集读事件, 写事件, 异常事件的描述符
- 其次, 调度底层提供的 select() 函数, 等待事件发生; 这里需要注意的时, select 阻塞与否和设置阻塞 IO 是没有关系的
- 最后, 轮询所有事件描述符集合的每一个事件描述符, 检查是否有相应的事件发生, 如果有则进行处理

##### poll 库
poll 库是 Linux 平台的基本事件驱动模型, 在 Linux 2.1.23 中引入, Windows 平台不支持  
poll 和 select 的基本工作方式是相同的, 都是先创建一个关注事件的描述符集合, 再去等待这些事件发生, 最后在轮询描述符集合, 检查有没有事件发生, 如果有就进行处理  
poll 库和 select 库的主要区别在于, select 库需要为 读事件, 写事件, 异常发生事件分别创建一个描述符集合, 因此在最后轮询的时候, 需要分别轮询这三个集合; 而 poll 集合只需要创建一个集合, 在每个描述符对应的结构上分别设置读事件, 写事件, 异常发生事件, 最后轮询时可以同时检查这三种事件是否发生; 可以说 poll 库是 select 的优化实现

##### epoll 库
epoll 库属于 poll 库的一个变种, 在 Lunix 2.5.44 中引入  
poll 和 select 库在实际工作中, 最大的区别在于效率, 它们处理方式都是创建一个待处理时间列表, 然后把这个列表发给内核, 返回的时候再去沦胥检查这个列表, 以判断时间是否发生; 这样在描述符较多的应用中, 效率就显得低下了; 一种好的做法是, 把描述符列表的管理交由内核负责, 一旦有某种事件发生, 内核把发生事件的描述符列表通知给进程, 这样就避免了轮询整个描述符列表; epoll 就是这样的一种模型  
epoll 库通过相关调用通知内核创建一个有 N 个描述符的事件列表, 然后给这些描述符设置所关注的事件, 并把它添加到内核的事件列表中去, 在具体编码过程中也可以通过相关调用对时间列表中的描述进行修改和删除; 在完成设置之后, epoll 库就开始等待内核通知事件发生; 某一事件发生后, 内核将发生事件的描述符列表上报给 epoll 库, 得到事件列表的 epoll 库就可以进行事件处理了

##### rtsig 模型
rtsig 是 Real-Time Signal 是实施信号的缩写; 从严格意义上来说 rtsig 模型并不是常用的事件驱动模型, 但 Nginx 提供了使用实时信号对事件进行响应的支持, 官方文档中将  rtsig 模型与其他事件驱动模型并列  
使用 rtsig 模型时, 工作进程会通过系统内核建立一个 rtsig 队列用于存放标记事件发生 (在 Nginx 中特指客户端请求发生) 的信号; 每个事件发生时, 系统就会产生一个信号存放到 rtsig 队列中等待工作进程的处理; 需要指出的是 rtsig 队列有长度限制 (默认 1024), 超过该长度之后就会发生溢出; 系统各个进程的事件信号队列是由内核统一管理的, 用户可以通过修改内核参数 `/proc/sys/kernel/rtsig-max` 来定义该长度设置 (Linux 2.6.6-mm2 后取消)  
当 rtsig 队列发生溢出时, Nginx 将暂时停止使用 rtsig 模型, 而调用 poll 库处理未处理的事件, 直到  rtsig 信号队列全部清空, 然后再次启动 rstig 模型, 以防止新的溢出发生

##### 其他事件驱动类型
除了以上四种时间驱动模型之外, Nginx 服务器针对特定的 Linux 平台提供了响应的事件驱动模型支持; 主要实现的有以下几种
- kqueue 模型
用于支持 BSD 系列平台的高效时间驱动模型, 该模型是 poll 库的一个变种, 和 epoll 库的处理方式没有本质上的区别, 都是通过避免轮询操作提供效率, 但该模型同时支持条件触发 (level-triggered, 只要满足条件就触发一个事件) 和边缘触发 (edge-triggered, 每当状态变化就触发一个事件)
- /dev/poll 模型
用于支持 Unix 衍生平台的高效事件驱动模型
- eventport 模型
用于支持 Solaris 10 及以上版本平台的高效事件驱动模型

#### 设计架构概览
##### Nginx 服务器架构
Nginx 服务器启动后, 产生一个主进程 (Master process), 主进程执行一系列的工作后产生一个或多个工作进程 (Worker processes); 主进程主要进程 Nginx 配置文件解析, 数据结构初始化, 模块配置和注册, 信号处理, 网络监听生成, 工作进程生成和管理等工作; 工作进程主要进行进程初始化, 模块调用和请求处理工作, 是 Nginx 服务器提供服务的主体  
在客户端请求动态站点的过程中, Nginx 服务器还设计和后端服务器的通信, Nginx 服务器将接收到的 Web 请求通过代理转发到后端服务器, 由后端服务器进行数据处理和页面组织然后将结果返回  
另外, Nginx 服务器为提高对请求的响应效率, 进一步降低网络压力, 采用了缓存机制, 将历史应答数据缓存到本地, 在每次 Nginx 服务器启动后的一段时间内, 会启动专门的进程对本地缓存的内容重建索引

![TODO Nginx 服务器架构示意图]
