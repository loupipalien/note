### 并发
#### 线程, 进程, 程序之间的基本概念
TODO
#### 什么是守护进程
Java 中线程分为两种: 守护线程 (Daemon) 和用户线程 (User)
- 任何瑕疵都可以设置为守护线程和用户线程, 通过 `Thread#setDaemon(true)` 即可把该线程设置为守护线程, 反之则为用户线程
- `Thread#setDaemon(boolean on)` 方法必须在 `Thread#start()` 方法之前调用, 否则运行时会抛出异常

这两者唯一的区别是, JVM 会等待非守护线程完成后关闭, 但 JVM 不会等待守护线程  
>Thrad Dump 打印出来的线程信息, 含有 daemon 字样的线程即为守护进程, 可能会有: 服务守护进程, 编译守护进程, Finalizer 守护进程, Windows 下监听 Ctrl + break 的守护进程, 引用处理守护进行, GC 守护进程

#### 什么是线程组, 为什么不推荐使用 ThreadGroup
TODO

#### 什么是多线程上下文切换
多线程会共同使用一组计算机上的 CPU, 而线程数大于给程序分配的 CPU 的数量时, 为了让各个线程都有执行的机会, 就需要轮转使用 CPU, 不同的线程切换使用 CPU 发生的切换数据, 就是上下文切换
- 在上下文切换的过程中, CPU 会停止处理当前运行的程序, 并保存当前程序运行的具体位置以便之后继续运行; 在程序中, 上下文切换过程中被称作 "切换帧", 页码信息会一直保存到 CPU 的内存中, 直到他们被再次使用
- 上下文切换是存储和恢复 CPU 状态的过程, 它使得线程执行能够从断点恢复执行, 上下文切换是多任务操作系统和多线程环境的基本特征

#### 分时调度模型和抢占式调度模型
- 分时调度模型是指让所有的线程轮流获得 CPU 的使用权, 并且平均分配每个线程占用的 CPU 的时间片
- Java 虚拟机采用抢占式调度模型, 是指优先让可运行池中优先级高的线程占用 CPU, 如果可运行池中的线程优先级相同, 那么就随机选择一个线程, 使其占用 CPU 处于运行状态的线程会一直运行, 直到它不得不放弃 CPU

#### 什么是线程饥饿
一个或多个线程因为种种原因无法获得所需要的资源, 导致一直无法执行的状态; Java 中导致饥饿的原因
- 高级优先级线程吞噬所有的低优先级线程的 CPU 时间
- 线程被永久堵塞在一个等待进入同步快的状态, 因为其他线程总是能在它之前持续的对该同步块进行访问
- 线程在等待一个本身也处于永久等待完成的对象, 例如调用这个对象的 wait 方法, 因为其他线程总是被持续的获得唤醒

#### 线程的生命周期
[线程的生命周期](http://static2.iocoder.cn/04a277229fd3b24e058417f9c571681c)

#### 结束线程的方法
- 使用退出标识, 这个 flag 要多线程可见
- 使用 interrupt 方法, 结合 isInterrupted 方法一起使用

#### 创建线程的方式及实现
- 继承 Thread 类创建线程类
- 通过 runnable 接口创建线程类
- 通过 Callable 和 Future 创建线程  
- 通过线程池创建线程

#### 一个线程运行时发生异常会怎样
如果异常没有被捕获该线程将会停止执行, Thread#UncaughtExceptionHandler 是用于处理未捕获异常造成线程突然中断的情况的一个内嵌接口, 当一个未捕获异常将造成线程中断的时候 JVM 会使用 Thread#getUncaughtExceptionHandler() 方法来查询线程的 UncaughtExceptionHandler 并将线程和异常作为参数传递给 Handler 的 uncaughtException 方法进行处理, 详细可见 [JAVA 多线程之 UncaughtExceptionHandler —— 处理非正常的线程中止](https://blog.csdn.net/u013256816/article/details/50417822)

#### 如何使用 wait/notify 实现通知机制
[Wait / Notify通知机制解](https://juejin.im/entry/5a2bb783f265da43163cff74); 除此之外, Java 多线程间的协作还有其他方式, 详细见 [Java多线程——线程间协作方式总结及使用示例](https://blog.csdn.net/zhoucheng05_13/article/details/78311179)

##### sleep 方法和 wait 方法都可以让线程暂停, 它们之间有什区别
- sleep 方法: 调用此方法会让当前线程暂停执行指定的时间, 将执行机会 (CPU) 让给其他线程, 当依然把持锁, 在休眠时间结束后会自动回复到就绪状态
- wait 方法: 调用此方法会导致当前新城放弃锁 (线程暂停执行), 进入对象的等待池 (wait pool), 只有调用对象的 notify/notifyAll 方法是才会被唤醒从而进入等锁池 (lock pool), 如果线程重新获取锁就可以进入就绪状态

##### sleep 方法和 yield 方法有什么区别
- sleep 方法给其他线程运行机会时不考虑线程的优先级, 因此会给低优先级的线程以运行的机会, yield 方法只会给相同优先级或更高优先级的线程以运行的机会
- 线程执行 sleep 方法后转入等待状态, 执行 yield 方法后转入就绪状态
- sleep 方法声明抛出 InterruptedException 异常, 而 yield 方法没有声明任何异常
- sleep 方法比 yield 方法 (跟操作系统 CPU 调度相关) 具有更好的可移植性

##### sleep(0) 有什么用途
`Thread#sleep(0)` 方法, 并非是真的要现存挂起 0 毫秒, 意义在于这次调用 `Thread#sleep(0)` 方法, 把当前线程确实冻结了一下, 让其他先有机会优先执行; `Thread#sleep(0)` 方法是让线程暂时放弃 CPU, 也就是释放一些未用的时间片给其他线程或进程使用, 相当于一个让位动作

##### interrupt, interrupted, isInterrupted 方法的区别
- interrupt 方法
用于中断线程, 调用该方法的线程的状态将被置为 "中断" 状态; 该方法仅仅是设置的中断状态位, 不会停止线程, 需要用户去监视现象的状态并做处理, 支持线程中断的方法, 一旦检测到线程被置为中断状态, 就会抛出中断异常
- interrupted 方法
Thread#interrupted 属于静态方法, 查询当前线程的中断状态, 并且清除原状态; 如果一个线程被中断了, 第一次调用 #interrupted 方法则返回 true, 第二次和后面就返回 false 了
- isInterrupted 方法
查询指定线程的中断状态, 不会清除原状态

#### 什么叫线程安全
线程安全是编程中的术语, 指某个函数, 函数库在多线程环境中被调用时, 能够正确地处理多个线程之间的共享变量, 是程序功能正确完成

#### 什么是 ThreadLocal 变量
ThreadLocal 是 Java 里一种特殊的变量, 每个线程都有一个 ThreadLocal 就是每个线程都拥有了自己独立的一个变量, 竞争条件被彻底消除了; 它是为创建代价高昂的对象获取线程安全的好方法, 比如可以用 ThreadLocal 让 SimpleDateFormat 变成线程安全的, 因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它, 如果为每个线程提供一个自己独有的变量拷贝, 将大大提高效率
- 首先通过复用减少代价高昂的对象的创建个数
- 其次, 你在没有使用高代价的同步或不变性的情况下获得了线程安全

详细介绍可见 [Java并发编程：深入剖析ThreadLocal](https://www.cnblogs.com/dolphin0520/p/3920407.html) 和 [深入分析 ThreadLocal](http://www.iocoder.cn/JUC/sike/ThreadLocal/?vip)

#### 什么是 Java Timer 类
- `java.util.Timer` 是一个工具类, 可以用于安排一个线程在未来的某个特定时间执行, Timer 类可以用安排一次性任务或周期任务  
- `java.util.TimerTask` 是一个实现了 Runnable 接口的抽象类, 需要去继承这个类来创建定时任务并使用 Timer 去安排它的执行

#### 多线程开发的良好实践
- 给线程命名
- 最小化同步范围
- 优先使用 volatile 而不是 synchronized
- 尽可能使用更高层次的并发工具而非 wait/notify 方法来实现线程通信
- 优先使用并发容器, 而非同步容器
- 考虑使用线程池

#### Java 锁
TODO
