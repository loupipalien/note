### 基础

#### 什么是面向对象
面向对象是一种思想, 世间万物都可以看做为一个对象; Java 是一种支持并发, 基于类和面向对象的计算机编程语言, 面向对象编程 (OOP) 有以下优点
- 代码开发模块化, 更容易维护和修改
- 代码复用性很强
- 增加代码的可靠性和灵活性
- 增强代码的可读性

#### 请说说面向对象的特征
封装, 继承, 多态, 抽象
##### 封装
给对象提供了隐藏内部特性和行为的能力; 对象提供一些能被其他对象访问的方法来改变它内部的数据; 在 Java 中有 4 中修饰符: `default, public, private, protected`, 每种修饰符给其他的位于同一个包或不同包下面的对象设置了不同的访问权限; 以下是封装带来的一些好处
- 通过隐藏对象的属性来保护对象的内部状态
- 提高了代码的可用性和可维护性, 因为对象的行为可以被单独改变或者是扩展
- 禁止对象之间的不良交互提高模块化
##### 继承
给对象提供了从基类获取字段和方法的能力; 继承提供了代码的重用性, 也可以在补修改类的情况下给现存的类添加新特性
##### 多态
是编程语言给不同的底层数据类型做相同的接口展示的一种能力
##### 抽象
是想把类的行为和实现细节分离开的技术, 继承类可以根据需要来实现细节

#### 面向对象和面向过程的区别
面向过程
- 优点: 性能比面向对象高, 因为类调用需要实例化开销较大
- 缺点: 没有面向对象易维护, 易复用, 易扩展

面向对象
- 优点: 由于面向对象有封装, 继承, 多态等特性, 更容易维护, 复用和扩展, 可以设计出低耦合, 高内聚的系统
- 缺点: 性能比面向过程低

#### 重写与重载的区别
| 重写 | 重载 |
| :--- | :--- |
| 子类方法名参数与父类相同, 子类返回类型和抛出异常小于等于父类, 子类访问权限大于等于父类 (两同两小一大) | 方法名相同, 参数类型或个数不同 |
| 发生在继承类中 | 发生在同一个类中 |

#### 什么是构造方法, 什么构造方法重载
- 构造方法
当心对象被创建的时候, 构造方法会被调用, 每个类都有构造方法, 在没有类类提供构造方法的情况下, Java 编译器会给这个类创建一个默认的构造方法
- 构造方法重载
Java 中构造方法重载和方法重载类似, 可以为一个类创建多个构造方法, 每一个构造方法必须有它自己唯一的参数列表

#### JDK, JRE, JVM 分别是什么关系
##### JDK
JDK 即为 Java 开发工具包, 包含编写 Java 程序所必须的编译, 运行等开发工具以及 JRE
- 用于编译 Java 程序的 javac 命令
- 用于启动 JVM 运行的 Java 程序的 java 命令
- 用于生成文档的 javadoc 命令
- 用于打包的 jar 命令

简单的说就是 JDK 包含 JRE 包含 JVM

##### JRE
JRE 即为 Java 运行环境, 提供了运行 Java 应用程序所必须的软件环境, 包含 Java 虚拟机 (JVM) 和丰富的系统类库, 系统类库即为 Java 提前封装好的功能类, 只需拿来直接使用即可, 可以大大的提升开发效率  
简单的说就是 JRE 包含 JVM

##### JVM
JVM 即为 Java 虚拟机, 提供了字节码文件 `.class` 的运行环境支持

#### 为什么 Java 被称作是 "平台无关的编程语言"
Java 虚拟机是一个可以执行 Java 字节码的虚拟机进程
- Java 源文件 `.java` 被编译成能被 Java 虚拟机执行的字节码文件 `.class`
- Java 被设计成允许应用程序可以运行在任意平台上, 而不需要为每一个平台单独重写或者是重新编译; Java 虚拟机让这个变成可能, 因为它知道底层硬件平台的指令长度和其他特性

#### JDK 8 的新特性
TODO (值得写一篇文章)

#### Java 与 C++ 的区别
- 都是面向对象的语言, 都支持封装, 继承, 多态
- Java 不提供指针来直接访问内存, 程序内存更加安全
- Java 的类是单继承的, C++ 支持多重继承, Java 的接口支持多继承
- Java 有自动内存管理机制, 不需要程序员手动释放无用内存

#### 什么是字节码? 采用字节码的好处是什么?
##### 什么是字节码
Java 中引入了虚拟机的概念, 即在机器和编译程序之间加入了一层抽象的虚拟的机器; 这台虚拟的机器在任何平台上都提供给编译程序一个共同的接口  
编译程序只需要面向虚拟机, 生成虚拟机能够理解的代码, 然后由解释器来讲虚拟机代码转换为特定系统的机器码执行; 这种供虚拟机理解的代码叫做字节码 (即扩展名为 `.class` 的文件), 它不面向任何特定的处理器, 只面向虚拟机; 每一种平台的解释器是不同的, 但是实现的虚拟机是相同的; Java 源程序经过编译器编译后变成字节码, 字节码由虚拟机解释执行, 虚拟机将每一条要执行的字节码送给解释器, 解释器将其翻译为特定机器上的机器码, 然后在特定的机器上运行; **这也就是解释了 Java 的编译与解释并存的特点**
```
Java 源代码
=> 编译器 => JVM 可执行的 Java 字节码 (即虚拟指令)
=> JVM => JVM 中的解释器 => 机器可执行的二进制机器码 => 程序运行
```
##### 采用字节码的好处
Java 语言通过字节码的方式, 在一定程度上解决了传统解释型语言执行效率低的问题, 同时又保留了解释型语言可移植的特点; 所以 Java 程序运行时比较高效, 而且由于字节码并不专对一种特定的机器, 因此 Java 程序无须重新编译便可在多种不同的计算机上运行

#### Java 中的基本类型和引用类型
##### 基本类型
- 整数值类型: `byte (8), short (16), int (32), long (64)`
- 浮点类型: `float (32), double (64)`
- 字符型: `char (16)`
- 布尔型: `boolean`

#### 引用类型
除了基本类型其他都是引用类型, 引用声明的变量是指该变量在内存中实际存储的是一个引用地址, 实体在堆中

#### Java 是值传递还是引用传递?
- 值传递: 是对基本类型而言的, 传递的是该变量的一个副本, 改变副本不影响原变量
- 引用传递: 是对于对象型变量而言, 传递的是该对象的一个副本, 并不是原对象本身

TODO Java 是值传递还是引用传递

#### 什么是自动装箱拆箱
自动装箱和拆箱就是基本类型和引用类型之间的转换

TODO [自动装箱中使用的缓存机制](https://www.cnblogs.com/loveyixiang/p/6034844.html)

#### equals 和 hashCode 方法
- 为什么重写 equals 方法后要重写 hashCode 方法
- [为什么 String 的 hashCode 方法选择 31 作为乘子](https://segmentfault.com/a/1190000010799123)

#### final, finally, finalize 的区别
##### final
final 是修饰关键字, 被修饰的类不能被继承, 被修饰的变量和方法不能被改变
##### finally
在异常处理时提供 finally 块来执行清理操作; 在以下四种情况下 finally 不会被执行
- 在 finally 语句块中发生了异常
- 在前面的代码中用了 `System.exit()` 退出程序
- 程序所在的线程死亡
- 关闭 CPU
##### finalize
Java 允许使用 finalize 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作, 这个方法是由垃圾收集器在确定这个对象没有被引用时堆这个对象调用的
- 是在 Object 类中定义的, 因此所有类都继承了它
- 子类覆盖 finalize 方法以整理系统资源或执行其他清理工作
- finalize 方法是在垃圾收集器删除对象之前对这个对象调用的

一般情况下不会实现这个方法, 也不推荐实现这个方法; 更多的是在一些框架中使用, 可见 [Netty Using finalize() to release ByteBufs](https://github.com/netty/netty/issues/4145)

#### 接口和对象有什么区别
TODO

#### 类的实例化顺序
TOOD [Java 类的实例化顺序](https://blog.csdn.net/Vencc__/article/details/52222628)

#### 什么是内部类
TODO

#### 什么是 Java IO?
TODOS

#### 什么是 Java 序列化
TODO

#### 如何实现对象克隆
一般来说, 有两种方式
- 实现 Cloneable 接口, 并重写 Object 类中的 clone 方法, 可以实现浅克隆也可以实现深克隆
- 实现 Serializable 接口, 通过对象的序列化和反序列化实现克隆, 可以实现真正的深克隆

TODO

#### Error 和 Exception
TODO

#### 反射的用途以及实现
TODO

#### 什么是注解
TODO

#### 什么时候用断言?
断言是在软件开发中一种常用的调试方式
- 一般来说, 断言用于保证程序最基本, 关键的正确性, 断言检查通常在开发和测试时开启, 为了保证程序的执行效率, 在软件发布后断言检查通常是关闭的
- 断言是一个包含布尔表达式的语句, 在执行这个语句时假定该表达式为 `true`; 如果表达式的值为 `false`, 那么系统会报告一个 `AssertionError` 错误
- 断言可以有以下两种形式
  - assert 布尔表达式
  - assert 布尔表达式 : 错误信息表达式
- 要在运行时启用断言, 可以在启动 JVM 时使用 `-enableassertions` 或者 `-ea` 标记; 要在运行时选择禁用断言, 可以在启动 JVM 时使用 `-da` 或者 `-disableassertions` 的标记; 要在系统类中启动或禁用断言, 可以使用 `-esa` 或 `-dsa` 标记, 还可以在包的基础上启用或禁用断言

#### Java 对象创建的方式
- 使用 `new` 关键字创建对象
- 使用 Class 类的 newInstance 方法 (反射机制)
- 使用 Constructor 类的 newInstance 方法  
- 使用 clone 方法创建对象
- 使用序列化机制创建对象


>**参考:**
- [精尽 Java 基础面试题](http://svip.iocoder.cn/Java/Core/Interview/)
