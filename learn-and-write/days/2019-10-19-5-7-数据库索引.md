### 数据库索引

#### 索引是什么
索引 (Index) 是帮助 MySQL 高效获取数的数据结构
- 索引能极大的减少存储引擎需要扫描的数据量
- 索引可以帮助服务器避免排序和临时表
- 索引可以将随机 I/O 变成顺序 I/O

#### B-Tree 索引和 Hash 索引的区别
##### B-Tree 索引
谈论索引是没有特别指明默认是指 B-Tree 索引, 它使用 B-Tree 数据结构来存储数据  
B-Tree 通常意味着所有的值都是按顺序存储的, 并且每个叶子页到根的距离是相同的; 下图是 InnoDB 的索引图示
![B-Tree树结构.png](http://ww1.sinaimg.cn/large/d8f31fa4gy1g81tfmvh2nj20qj0f8mxu.jpg)
B-Tree 索引能够加快访问数据的速度, 因为存储引擎不再需要进行全表扫描来获取需要的数据, 取而代之的是从索引的根节点开始进行搜索, 根节点的槽中存放了指向子节点的指针, 存储引擎根据这些指针向下层查找, 通过比较节点页的值和要查找的值可以找到合适的指针进入到下层子节点, 这些指针实际上定义了子节点页中值的上限和下限; 最终存储引擎要么找到对应的值, 要么该记录不存在  
可以使用 B-Tree 索引的查询类型, B-Tree 索引适用于全键值, 键值范围或键前缀查找; 其中键前缀查找值适用于根据最左前缀的查找; 之前所叙述的索引对以下类型查询有效
- 全值匹配
- 匹配最左前缀
- 匹配列前缀
- 匹配范围值
- 精确匹配某一列并范围匹配另一列
- 只访问索引的查询

因为索引树中的节点是有序的, 所以除了按值查找之外, 索引还可以用于查询中 ORDER BY 操作; 以下是 B-Tree 索引的一些限制
- 如果不是按照索引的最左列开始查找, 则无法使用索引
- 不能跳过索引中的列
- 如果查询中有某个列的范围查询, 则其右边所有列都无法使用索引优化查找

所以索引中列的顺序是很重要的, 这些限制都和索引中列的顺序有关

##### 哈希索引
哈希索引基于哈希表实现, 只有精确到匹配索引所有列的查询才有效; 对每一行数据, 存储引擎都会对所有的索引列计算一个哈希码, 这个哈希码是一个较小的值, 并且不同键值的行计算出来的哈希码也不一样, 哈希索引将所有的哈希码存储在索引中, 同时在哈希表中保存指向每个数据行的指针; 在 MySQL 中只有 Memory 引擎显式支持哈希索引; 哈希索引也有它的限制
- 哈希索引只包含哈希值和行指针, 而不存储字段值, 所以不能使用索引中的值来避免读取行
- 哈希索引数据并不是按照索引值顺序存储的, 所以也就无法用于排序
- 哈希索引也不支持部分索引列匹配查找, 因为哈希索引始终是使用索引列的全部内容来计算哈希值的
- 哈希索引只支持等值比较查询, 不支持非等值和范围查询
- 当有哈希冲突时, 存储引擎必须遍历链表中所有的行指针, 逐行进行比较, 直到找到所有符合条件的行
- 如果哈希冲突很多的话, 一些索引维护操作的代价也会很高

InnoDB 引擎有一个特殊的功能叫做 "自适应哈希索引 (adaptive hash index)"; 当 InnoDB 注意到某些索引值被使用的非常频繁时, 它会在内存中基于 B-Tree 索引之上再创建一个哈希索引, 这就让B-Tree 所以也具有哈希索引的一些优点, 但如非有必要建议关闭此功能


#### 聚簇索引和非聚簇索引的区别
##### 聚簇索引
聚簇索引并不是一种单独的索引类型, 而是一种数据存储方式; "聚簇" 表示数据行和相邻的键值紧凑的存储在一起, 因为无法同时把数据行存放在两个不同的地方, 所以一个表只能有一个聚簇索引; 在聚簇索引中, 叶子页包含了行的全部数据, 节点也只包含了索引列
###### 聚簇索引的优点
- 可以把相关数据保存在一起; 例如查询电子邮箱时, 可以根据用户的 ID 来聚集数据, 这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件, 如果没有聚簇索引则每封邮件都可能导致一次磁盘 I/O
- 数据访问更快, 聚簇索引将索引和数据保存在同一个 B-Tree 中, 因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快
- 使用覆盖索引扫描的查询可以直接使页节点中的主键值
- 对于二级索引的叶子节点存储主键值 (聚簇索引), InnoDB 在移动行时无须更新二级索引中的这个 "指针"

###### 聚簇索引的缺点
- 聚簇索引最大限度的提高了 I/O 密集型应用的性能, 但如果数据全部都放在内存中, 则访问顺序就没有那么重要了, 聚簇索引也就没什么优势了
- 插入速度严重依赖于插入顺序; 按照主键的顺序插入是加载数据到 InnoDB 表中速度最快的方式, 但如果不是按照主键顺序加载数据, 那么在加载完成后最好使用 OPTIMIZE TABLE 命令重新组织一下表
- 基于聚簇索引的表在插入新行, 或者主键被更新导致需要移动行的时候, 可能面临 "页分裂" 的问题; 当行的主键值要求必须将这一行插入到某个已满的页中时, 存储引擎会将该页分裂成两个页面来容纳改该行, 这就是一次页分裂操作, 页分裂操作会导致占用更多的磁盘空间
- 聚簇索引可能导致全表扫面变慢, 尤其是行比较稀疏, 或者由于页分裂导致数据存储不连续的时候
- 二级索引 (非聚簇索引) 可能比想象的要更大, 因为二级索引的叶子节点包含了引用行的主键列 (即二级索引叶子节点保存的不是指向行的物理位置的指针, 而是行的主键值), 这就意味着通过二级索引查找行, 存储引擎需要找到二级索引的叶子节点获得对应的主键值, 然后根据这个值去聚簇索引中查找到对应的行, 这里做了重复的工作: 两次 B-Tree 树查找而不是一次

##### 非聚簇索引
非聚簇索引的叶子节点仍然是索引节点, 只不过有指向对应数据块的指针; 将数据存储于索引分开结构, 索引结构的叶子节点指向了数据的对应行

#### B 树, B+ 树, 二叉搜索树, AVL 树, 红黑树有什么区别
TODO
