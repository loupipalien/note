### JVM 的基本结构
![JVM的基本结构.jpg](http://ww1.sinaimg.cn/large/d8f31fa4gy1g8lhavnjnbj20d50d60ud.jpg)  

#### 程序计数器
由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的, 在任何一个确定的时刻, 一个处理器 (对于多核处理器来说是一个内核) 都只会执行一条线程中的指令; 因此, 为了线程切换后能恢复到正确的执行位置, 每条线程都需要有一个独立的程序计数器, 各条线程之间互不影响, 独立存储, 我们称这类内存区域为 "线程私有" 的内存
如果线程正在执行的是一个 Java 方法, 这个计数器记录的是正在执行的虚拟机字节码指令地址

#### 虚拟机栈
Java 虚拟机栈也是线程私有的, 它与线程的生命周期相同; 虚拟机栈描述的是 Java 方法执行的内存模型: 每个方法在执行的同时都会创建一个栈帧 (Stack Frame) 用于存储局部变量表, 操作数, 动态链接, 方法出口等信息; 每一个方法从调用直至执行完成的过程, 就对应着栈帧在虚拟机中入栈到出栈的过程

#### 本地方法栈
本地方法栈与虚拟机栈所发挥的作用是非常相似的, 它们之间的区别不过是虚拟机栈为虚拟机执行 Java 方法服务, 而本地方法栈则为虚拟机使用到的 Native 方法服务

#### 堆
堆是被所有线程共享的一块内存区域,在虚拟机启动时创建; 在内存区域的唯一目的就是存放对象实例以及数组; 堆是垃圾收集器管理的主要区域, 因此很多时候也被称为 "GC 堆"

#### 方法区
与堆一样, 方法区也是各个线程共享的内存区域, 用于存储已被虚拟机加载的类信息, 常量, 静态变量, 即时编译器编译后的代码等数据; 虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分, 但是它却有一个别名叫做 Non-Heap (非堆), 目的是为了与堆区分开来

#### 运行时常量池
运行时常量池是方法区的一部分, Class 文件中除了有类的版本, 字段, 方法, 接口等描述信息外, 还有一项信息是常量池, 用于存放编译期生成的各种字面量和符号引用, 这部分内容将在类加载后进入方法区的运行时常量池中存放; 一般来说, 除了保存 Class 文件中描述的符号引用外, 还会把翻译出来的直接引用也存储在运行时常量池中

#### 直接内存
直接内存并不是虚拟机运行时数据区的一部分, 也不是 Java 虚拟机规范定义的内存区域; 在 JDK 1.4 中加入了 NIO 类, 引入了一种基于通道 (Channel) 和 缓冲区 (Buffer) 的 I/O 方式, 它可以使用 Native 函数库直接分配堆外内存, 然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作, 这样能在一些场景中显著提供性能, 因为避免了 Java 堆和 Native 堆中来回复制数据

>**参考:**
- [JVM结构、GC工作机制详解](https://blog.csdn.net/tonytfjing/article/details/44278233)
- [JVM基本结构](https://www.jianshu.com/p/10091e2a6800)
- [JVM的基本结构](https://blog.csdn.net/sicofield/article/details/78473836)
