### 绪论

#### 计算机和算法
计算 (信息处理): 借助某种工具, 遵照一定的规则, 以明确而机械的形式进行  
计算模型 = 计算机 = 信息处理工具  
算法: 即特定计算模型下, 旨在解决特定问题的指令序列
- 输入: 待处理的信息 (问题)
- 输出: 经处理的信息 (答案)
- 正确性: 的确可以解决指定的问题
- 确定性: 任一算法都可以描述为一个由基本操作组成的序列
- 可行性: 每一个基本操作都可实现, 且在常数时间内完成

##### 古埃及人的绳索
TODO

##### 欧几里得的尺规
TODO

##### 起泡排序
```
void bubblesort1A(int A[], int n) {  // 起泡排序算法 (版本 1A): 0 <= n
    bool sorted = false;  // 整体排序标志, 首先假定尚未排序
    while (!sorted) {  // 在尚未确认已全局排序之前, 逐趟进行扫描交换
        sorted = true;  // 假定已经排序
        for (int i = 1; i < n; i++) {  // 自左至右逐对检查当前范围 A[0. n) 内的各相邻元素
            if (A[I - 1] > A[i]) {  // 一旦 A[I - 1] 和 A[i] 逆序
                swap(A[i - 1], A[i]);  // 则交换之
                sorted = false;  // 因整体排序不能保证, 需要清除排序标志
            }
        }
        n--;  // 至此未元素必然就位, 故可以缩短待排序序列的有效长度
    }
}  // 借助布尔行标志位 sorted, 可及时提前退出, 而不致总是蛮力地做 n - 1 趟扫描
```

##### 算法
算法必须具备以下要素
- 输入输出
- 基本操作, 确定性, 可行性
- 有穷性, 正确性
- 退化和鲁棒性
- 重用性

##### 算法效率
TODO

#### 复杂度度量

##### 时间复杂度
特定算法处理规模为 n 的问题所需的时间可记作 T(n)

##### 渐进复杂度
对于同一问题的两个算法 A 和 B, 通过比较其时间复杂度 $ T_A(n) $ 和 $ T_B(n) $  
小规模问题所需的处理时间本来相对较少, 故此时不同算法的实际效率差异并不明显, 而在处理更大规模的问题时, 效率的些许差异都将对实际执行产生巨大的影响; 这种着眼长远, 更为注重时间复杂度的总体变化趋势和增长速度的策略和方法, 即所谓的渐进分析 (asymptotic analysis)

###### 大 O 记号
出于保守估计, 首先关注 T(n) 的渐进上届, 为此引入所谓的 "大 O 记号"; 即若存在正的常数 c 和函数 f(n), 使得对于任何 n >> 2 都有 $ T(n) \leq c*f(n) $; 则可认为在 n 足够大之后, f(n) 给出了 T(n) 增长速度的一个渐进上届, 记为  $ T(n) = O(f(n)) $; 由这一定义可导出如下性质
- 对于任一常数 c > 0, 有 $ O(f(n)) = O(c*f(n)) $
- 对于任意常数 a > b > 0, 有 $ O(n^a + n^b) = O(n^a) $

前一性质表示在大 O 记号的意义下, 函数各项正的常系数可以忽略并等同于 1; 后一性质则意味着多项式中的低次项均可忽略, 只需保留高次项; 大 O 记号的性质体现了对函数总体渐进增长趋势的关注和刻画

###### 环境差异
TODO

###### 基本操作
将时间复杂度理解为算法中各指令的执行时间之和; 可将 T(n) 定义为算法所执行基本操作的总次数

###### 起泡排序
外循环最多执行 n - 1 次, 因此总共需要执行的基本操作不会超过 $ 2 * (n - 1)^2 $, 则有 $ T(n) = O(2 * (n - 1)^2) = O(2n^2 - 4 * n + 2) = O(2n^2) = O(n^2) $

###### 最坏, 最好, 平均情况
一般更关注最坏的情况

###### 大 $ \Omega $ 记号
对算法的复杂度最好的情况估计

###### 大 $ \Theta $ 记号
对算法的复杂度平均的情况估计

##### 空间复杂度
除了执行时间的长短, 算法所需存储空间的多少也是衡量其性能的一个重要方面, 即空间复杂度

#### 复杂度分析
