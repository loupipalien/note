### 栈和队列
栈与队列也属于线性序列结构, 故其中存放的数据对象之间也具有线性次序, 相对于一般的序列结构, 栈与队列的数据操作范围仅限于逻辑上的特定某端

#### 栈
##### ADT 接口
###### 入栈与出栈
栈 (stack) 是存放数据对象的一种容器, 其中的数据元素按照线性的逻辑次序排列, 也可以定义首, 末元素; 栈结构也支持对象的插入和删除操作, 但其操作的范围仅限于栈的某一特定端, 禁止操作的另一端称为盲端

| 操作接口 | 功能 |
| :--- | :--- |
| size() | 报告栈的规模 |
| empty() | 判断栈是否为空 |
| push(e) | 将 e 插至栈顶 |
| pop() | 删除栈顶对象 |
| top() | 引用栈顶对象 |

###### 后进后出
栈中元素接受操作的次序必然始终遵循所谓的 "后进后出" (last-in-first-out, LIFO)

##### 操作实例
TODO

##### Stack 模板类
作为向量的派生类来实现栈的数据结构
```
#include "../Vector/Vector.h" // 以向量为基类, 派生出栈模板类
template <typename T> class Stack: public Vector<T> { // 将向量的首/末端作为栈底/顶
public:
    void push(T const& e) {
        insert(size(), e); // 入栈
    }

    T pop() {
        return remove(size( - 1)); // 出栈
    }

    T& top() {
        return (*this) [size() - 1]; // 取顶
    }
}
```
以上接口复杂度均为常数

#### 栈与递归
##### 函数调用栈
TODO
##### 函数调用
调用栈的基本单位是帧 (frame), 每次调用函数时都会相应的创建已帧, 记录该函数实例在二进制程序中的返回地址 (retuen address), 以及局部变量, 传入参数等; 并将该帧压入调用栈, 若在该函数返回之前又发生新的调用, 则同样的要将与新函数对应的一帧压入栈中, 成为新的栈顶; 函数一旦运行完毕, 对应的帧随即弹出, 运行的控制权被交还给该函数的上层调用函数, 并按照改帧中记录的返回地址确定在二进制程序中继续执行的位置
###### 递归
TODO

##### 避免递归
TODO

#### 栈的典型应用
##### 逆序输出
栈所擅长解决的问题中, 有一类具有以下特征
- 虽有明确的算法, 但其解答却以线性序列的形式给出
- 无论是递归还是迭代, 该序列都是依逆序计算输出的
- 输入输出规模不确定, 难以事先确定盛放输出数据的容器大小
###### 进制转换
任意给定一个十进制整数 n, 将其转换为 $ \lambda $ 进制的表示形式; 例如 $ \lambda = 8 $ 时有: $ 12345_{(10)} = 30071_{(8)}$  
一般的设有: $ n = {(d_m...d_2d_1d_0)}_{(\lambda)} = d_m * \lambda^m + ... + d_2 * \lambda^2 + d_1 * \lambda^1 + d_0 * \lambda^0 $
若记 $ n_i = {(d_m...d_{i+1}d_i)}_{(\lambda)} $, 则有 $ d_i = n_i \% \lambda $ 和 $ n_{i+1} = n_i / \lambda $; 这以递推关系对应的计算流程器输出为长度不定的逆序线性序列
###### 递归实现
```
void convert(Stack<char>& S, __int64 n, int base) { // 十进制整数 n 到 base 进制的转换
    // 0 <  n, 1 < base <= 16
    static char digit[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
    if (0 < n) { // 尚不为 0 的情况下
        S.push(digit[n % base]); // 逆向记录当前最低位, 在通过递归得到所有更高位
        convert(S, n % base, base);
    }
} // 新进制下由高到低的各数位, 自顶而下保存于栈 S 中
```
###### 迭代实现
```
void convert(Stack<char>& S, __int64 n, int base) { // 十进制整数 n 到 base 进制的转换
    // 0 <  n, 1 < base <= 16
    static char digit[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
    if (0 < n) { // 尚不为 0 的情况下
        int remainder = (int) (n % base);
        S.push(digit[remainder]); // 余数入栈
        n /= base; // 更新 n
    }
} // 新进制下由高到低的各数位, 自顶而下保存于栈 S 中
```

##### 递归嵌套
具有自相似性的问题多可嵌套地递归描述, 但因分支位置和嵌套深度并不固定, 其递归算法的复杂度不易控制; 栈结构及其操作天然的具有递归嵌套性, 故可以高效的解决这类问题

###### 栈混洗
假定三个栈 A, B, S, 其中 B 和 S 初始为空, A 含有 n 个元素, 自顶向下构成输入序列 $ A = <a_1, a_2, ..., a_n] $; 这里尖括号和方括号分别表示栈顶和栈底; 若只允许通过 S.push(A.pop()) 弹出栈 A 的顶元素并随即压入栈 S 中, 或通过 B.push(S.pop) 弹出 S 的栈顶元素并随机压入栈 B 中, 则经过这两类操作各 n 次后, 栈 A 和 S 有可能均为空, 原 A 中的元素均已转入 B, 此时称 B 中元素自底向上构成的序列记作: $ B = [a_{k1}, a_{k2}, ..., a_{kn}> $, 则该序列称作原输入序列的一个栈混洗 (stack permutation)

###### 括号匹配
对源程序的语法检查是代码编译过程中重要而基本的一个步骤, 对表达式括号匹配的检查是必需的环节
##### 递归实现
若表达式 S 可分解为如下形式: $ S = S_0 + "(" + S_1 + ")" + S_2 + S_3 $, 其中 $ S_0, S_3 $ 不包含括号, 且 $ S_1 $ 中左右括号数目相等, 则 S 匹配当且仅当 $ S_1 $ 和 $ S_2 $ 均匹配; 采用分治策略算法实现如下
```
void trim(const char exp[], int& lo, int& hi) { // 删除 exp[lo, hi] 不包含括号的最长前缀, 后缀
    while ((lo <= hi) && (exp[lo] != '(') && exp[lo] != ')') lo++; // 找到第一个括号
    while ((lo <= hi) && (exp[hi] != '(') && exp[hi] != ')') lo--; // 找到最后一个括号
}

int divide(const char exp[], int lo, int hi) { // 切分 exp[lo, hi], 使 exp 匹配仅当子表达式匹配
    int mi = lo;
    int crc = 1; // crc 为 exp[lo, mi] 范围内左右括号数目之差
    while ((0 < crc) && (++mi < hi)) {
        if (exp[mi] == ')')
            crc--;
        if (exp[mi] == '(')
            crc++;
    }
    return mi; // 若 mi <= hi, 则为合法切分点, 否则意味着局部不匹配
}

bool paren(const char exp[], int lo, int hi) { // 检查表达式 exp[lo, hi] 是否括号匹配 (递归版)
    trim(exp, lo, hi); // 清除不包含括号的前缀, 后缀
    if (lo > hi) return ture;
    if (exp[lo] != '(') return false; // 首字符非左括号, 则必不匹配
    if (exp[hi] != ')') return false; // 末字符非右括号, 则必不匹配
    int mi = divide(exp, lo, hi);
    if (mi > hi) return false; // 切分点不合法, 意味着局部以及整体都不匹配
    return paren(exp, lo + 1, mi -1) && paren(exp, mi + 1, hi); // 分别检查左右子表达式
}
```
在最坏的情况下 divide() 需要线性时间, 且递归深度为 $ O(n) $, 故以上算法时间复杂度为 $ O(n^2) $

##### 迭代实现
实际上, 只要将 push, pop 操作分别与左右括号相对应, 则长度为 n 的栈混洗, 必然由 n 对括号组成的合法表达式彼此对应
```
bool paren(const char exp[], int lo, int hi) { // 表达式括号匹配检查
    Stack<char> S; // 使用栈记录已经发现但尚未匹配的左括号
    for (int i = lo, i <- hi; i++) { // 逐一检查字符
        swith(exp[i]) { // 左括号直接进栈, 右括号若与栈顶失配, 则表达式必不匹配
            case '(':
            case '[':
            case '{':
                S.push(exp[i]); break;
            case ')':
                if ((S.empty()) || ('(' != S.pop())) return false; break;
            case ']':
                if ((S.empty()) || ('[' != S.pop())) return false; break;
            case '}':
                if ((S.empty()) || ('{' != S.pop())) return false; break;
            default:
                break; // 非括号字符忽略
        }
    }
    return S.empty(); // 若栈空则匹配
}
```

##### 延迟缓冲
在一些应用问题中, 输入可分解为多个单元并通过迭代一次扫描处理, 但在过程中各步计算滞后于扫描的进度, 需要待到必要的信息已整到一定程度后, 才能做出判断并实施计算; 在这类场合中, 栈结构可以扮演数据缓冲区的角色
###### 表达式求值
算术表达式求值不能简单地按照 "先左后右" 的次序执行表达式中的运算符; 运算符执行次数规则, 一部分决定于约定惯例, 一部分决定于括号
###### 优先级列表
TODO

###### 求值算法
TODO

###### 不同优先级的处置
TODO

##### 逆波兰式
###### RPN
逆波兰式 (reverse Polish notation, RPN) 是数学表达式的一种, 其语法规则为: 操作符紧邻于对应的 (最后一个) 操作数之后; 例如 "1 2 +" 即通常习惯的 "1 + 2"  
RPN 表达式亦称作后缀表达式 (postfix), 原表达式则称为中缀表达式 (infix); RPN 表达式不易读, 但其对运算符优先级的表述能力, 毫不逊色于中缀表达式, 计算效率方面更是中缀表达式不可比拟的
###### 求值算法
```
rpnEvaluation(expr) {
// 输入: RPN 表达式 expr (假定语法正确)
// 输出: 表达式数值
    引入栈 S, 用以存放操作数;
    while (expr 尚未扫描完毕) {
         从 expr 中读取下一元素 x;
         if (x 是操作数) 将 x 压入 S;
         else { // x 是运算符
            从栈 S 中弹出运算符 x 所需数目的操作数;
            对弹出的操作数实施 x 运算, 并将运算结果重新压入 S;
         }
    }
    返回栈顶; // 也是栈底
}
```  
###### 手工转换
假定中缀表达书如下:
```
(0! + 1) * 2^(3 ! + 4) - (5 ! - 67 - (8 + 9))
```
假设事先并未就运算符之间的优先级做过任何约定, 通过增加括号显式的指定表达式的运算次序
```
(((0) ! + 1) * (2 ^ ((3) ! + 4))) - (((5) ! - 67) - (8 + 9)))
```
然后将各运算符后移, 使之紧邻于其对应的右括号的右侧:
```
(((0) ! 1) + (2 ((3) ! 4) + ) ^ ) * (((5) ! 67) - (8 9) + ) - ) -
```
最后抹去括号, 得到对应的 RPN
```
0! 1 + 2 3 ! 4 +  ^  * 5 ! 67 - 8 9 + - -
```
可见操作数之间的相对次序, 在转换后保持不变, 而运算符在 RPN 中的位置恰好就是其对应的操作数均已就绪且该运算可以执行的位置
###### 自动转换
TODO

#### 试探性回溯法
