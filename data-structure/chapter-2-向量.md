### 向量
数据结构是数据项的结构化集合, 其结构性表现为数据项之间的相互联系及作用, 也可以理解为定义于数据项之间的某种逻辑次序; 根据这种逻辑次序的复杂程度, 大致可以将各种数据结构划分为线性结构, 半线性结构, 非线性结构三大类; 在线性结构中, 各数据项按照一个线性次序构成一个整体; 最基本的线性结构统称为序列 (sequence), 根据其中数据项的逻辑次序与其物理存储地址的对应关系不同, 又可进一步的将序列区分为向量 (vector) 和列表 (list); 在向量中, 所有数据项的物理存放位置与其逻辑次序完全吻合, 此时的逻辑次序也称作秩 (rank); 而在列表中, 逻辑上相邻的数据项在物理上未必相邻, 而是采用间接定址的方式通过封装后的位置 (position) 相互引用

#### 从数组到向量

##### 数组
若集合 S 由 n 个元素组成, 且各元素之间具有一个线性次序, 则可将它们存放于起始地址 A, 物理位置连续的一段地址空间, 并统称作数组 (array), 可记作 $ A = \{a_0, a_1, ..., a_{n-1} \} $ 或者 $ A[0.n) = {A[0], A[1], ..., A[n-1]} $; 其中对于任何 $ 0 \leq i < j < n $, A[i] 都是 A[j] 的前驱 (predecessor), A[j] 都是 A[i] 的后继 (successor); 特别的, 对于任何 $ i \geq 1 $, A[i-1] 称作 A[i] 的直接前驱 (immediate predecessor), 对于任何 $ i \leq n -2 $, A[i+1] 称作 A[i] 的直接后继 (immediate successor); 任一元素的所有前驱构成其前缀 (prefix), 所有后继构成其后缀 (suffix); 另外, 若数组 A[] 存放空间的起始地址为 A, 且每个元素占用 s 个单位的空间, 则元素 A[i] 对应的物理位置为: $ A + i * s  $

##### 向量
按照面向对象思想中的数据抽象原则, 可以对以上数组结构做一般性推广, 使得其以上特性更具有普遍性; 向量 (vector) 就像线性数组的一种抽象和泛化, 也是具有线性次序的一组元素构成的集合 $ V = \{v_0, v_1, ..., v_{n-1} \} $, 其中元素分别由秩相互区分; 各元素的秩 (rank) 互异, 即可通过 r 来唯一确定 $ e = v_r $, 这是向量特有的元素访问方式, 称作 "循秩访问 (call-by-rank)"  
经过抽象后, 不再限定同一向量中的各元素都属于同一基本类型, 另外也不保证同时具有某一属性, 故不保证元素之间可以相互比较大小; 以下是定义的向量模板类

| 操作接口 | 功能 | 适用对象 |
| :--- | :--- | :--- |
| size() | 报告向量当前的规模 (元素总数) | 向量 |
| get(r) | 获取秩为 r 的元素 | 向量 |
| put(r, e) | 用 e 替换秩为 r 的元素 | 向量 |
| insert(r, e) | e 作为秩为 r 的元素插入, 原后继元素依次后移 | 向量 |
| remove(r) | 删除秩为 r 的元素, 返回该元素中存放的元素 | 向量 |
| disordered() | 判断所有元素是否已按非降序排序 | 向量 |
| sort() | 调整各元素的位置, 使之按非降序排序 | 向量 |
| find(e) | 查找等于 e 且秩最大的元素 | 向量 |
| search(e) | 查找目标元素 e, 返回不大于 e 且秩最大的元素 | 有序向量 |
| deduplicate() | 删除重复元素 | 向量 |
| uniquify() | 删除重复元素 | 有序向量 |
| traverse() | 遍历向量并统一处理所有元素, 处理方法由函数对象指定 | 向量 |

##### 操作实例
TODO

##### Vector 模板类
TODO

#### 构造与析构
向量结构在内部维护一个元素类型为 T 的私有数组 \_elem[]: 其容量由私有变量 \_capacity 表示, 有效元素的数量则由 \_size 表示

##### 默认构造方法
默认的构造方法是, 首先根据创建者指定的初始容量向系统申请空间, 以创建内部数组 \_elem[]; 若容量未指定, 则使用默认值 DEFAULT_CAPACITY; 忽略分配数组空间的时间, 共需常数时间

##### 基于复制的构造方法
```
template <template T> // 元素类型
void Vector<T>:: copyFrom(T const* A, Rank lo, Rank hi) {  // 以数组区间 A[lo, hi) 为蓝本复制向量
    _elem = new T[_capacity = 2 * (hi - lo)];  // 分配空间
    _size = 0;  // 规模清零
    while (lo < hi) {  // A[lo, hi) 内元素逐一复制至 _elem[0, hi - lo)
          _elem[_size++] = A[lo++];
    }
}
```
忽略开辟新空间所需时间, 运行时间正比于区间宽度, 即 $ O(hi - li) = o(\_size) $

#### 析构方法
TODO

#### 动态空间管理
内部数组占物理空间在向量生命周期内不允许调整, 则称为静态空间管理策略; 但由于容量固定, 则会存在某一时刻无法插入新的元素, 即所谓的上溢 (overflow); 向量实际规模与其内部数组容量的比值 (即 \_size / \_capacity), 称为装填因子 (laod factor), 是衡量空间利用率的重要指标

##### 可扩充向量
当数组 A[] 填充满后, 另外申请一个容量更大的数组, 并将原数组中的成员集体搬迁至新的空间, 此后可顺利的插入新元素而不导致溢出, 最后将原数组所占空间释放

##### 扩容
```
template <template T> void Vector<T>::expand() {  // 向量空间不足时扩容
    if (_size < _capacity) return; // 尚未满员不必扩容
    if (_capacity < DEFAULT_CAPACITY) _capacity = DEFAULT_CAPACITY; // 不低于最小容量
    T* oldElem = _elem;
    _elem = new T[_capacity <<= 1]; // 容量加倍
    for (int i = 0; i < _size; i++)
        _elem[i] = oldElem[i]; // 复制原向量内容 (T 为基本类型, 或已重载复制操作符 "=")
    delete [] oldElem; // 释放原空间
}
```

##### 分摊分析
- 时间代价
每次由 n 到 2n 的扩容, 都需要花费 $ O(n) $ 的时间
- 分摊复杂度
将对可扩充向量的足够多次连续操作, 并将期间所消耗的时间, 分摊至所有的操作时间; 如此分摊平均至单次操作的时间成本, 称为分摊运行时间 (amoritized running time)
- O(1) 分摊时间
假定数组的初始容量为某一常数 N, 向量的初始规模也为 N --- 即将溢出; 假设此后需要连续进行 n 此 insert() 操作, n >> N; 定义如下函数
```
size(n) = 连续插入 n 个元素后向量的规模
capacity(n) = 连续插入 n 个元素后数组的容量
T(n) = 为连续插入 n 个元素而花费于扩容的时间
```
由于始终有 $ size(n) \leq capacity(n) < 2 * size(n) $, 即 $ capacity(n) = \Theta(size(n)) = \Theta(n) $; 容量以 2 为比例按指数增长, 在容量到达 capacity(n) 之前, 共做过 $ \Theta(log_2n) $ 次扩容, 每次扩容所需时间正比与当时容量, 且同样以 2 为比例按指数增长, 因此消耗于扩容的时间累计不超过: $ T(n) = 2N + 4N + 8N + ... + capacity(n) < 2 * capacity(n) = \Theta(n) $, 将其分摊到期间的连续 n 次操作, 单次操作所需的分摊运行时间为 $ O(1) $
- 其它扩容策略
TODO

##### 缩容
导致低效率的另一种情况是, 向量的实际规模远远小于内部数组的容量, 当装填因子低于某一阈值时, 称发生了下溢 (underflow); 尽管下溢不是必须要解决的问题, 但是在格外关注空间利用率的场景, 有必要考虑缩容
```
template <template T> void Vector<T>::shrink() {  // 装填因子过小时压缩向量所占空间
    if (_capacity < DEFAULT_CAPACITY << 1) return; // 不致收缩到 DEFAULT_CAPACITY 以下
    if (_size << 2 > _capacity) retuen; // 以 25% 为界
    T* oldElem = _elem;
    _elem = new T[_capacity >>= 1]; // 容量减半
    for (int i = 0; i < _size; i++)  // 复制原向量内容
        _elem[i] = oldElem[i];
    delete [] oldElem; // 释放原空间
}
```
在实际应用中, 为了避免频繁的交替扩容或者缩容, 可以设置更低的阈值或者是 0 (即禁止缩容); 就单次扩容与缩容的操作而言, 所需时间高达 $ \Omega(n) $, 因此在对单次操作的执行速度极其敏感的应用场景, 以上策略并不适用, 其中缩容可以完全不予考虑

#### 常规向量
##### 直接引用元素
TODO

##### 置乱器
- 置乱算法
```
template <template T> void permute(Vector<T>& V) { // 随机置乱向量, 使各元素等概率出现在各位置上
    for (int i = V.size(); i > 0; i--)  // 自后向前
        swap(V[i-1], V[rand() % i]);  // V[i-1] 与 V[0,i) 中某一随机元素交换
}
```
- 区间置乱接口
TODO

##### 判等器与比较器
TODO

##### 无序查找
