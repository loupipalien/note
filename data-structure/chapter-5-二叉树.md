### 二叉树
线性结构中的元素之间都存在着一个自然的线性约束; 树则不然, 其中的元素并不存在天然的直接后继或直接前驱关系, 但只要附加某种约束, 也可以在树中元素之间确定某种线性次序

#### 二叉树及其表示
##### 树
###### 有根树
从图论的角度来看, 树等价于连通无环图; 与一般图相同, 树也由一组顶点 (vertex) 以及联接与其间的若干条边 (edge) 组成; 往往会在此基础上指定一个特定顶点, 并称之为 (root); 在指定根节点后也称之为有根树 (rooted tree)
###### 深度与层次
由于树的连通性, 每一节点与根之间都有一条路径相联; 而根据树的无环性, 由根通往每个节点的路径必然唯一; 沿每个节点 v 到根 r 的唯一通路所经过的边的数目, 称作 v 的深度 (depth), 记作 depth(v); 约定根节点的深度 depth(r) = 0, 故属于第 0 层
###### 祖先, 后代, 子树
任一节点 v 在通往树根沿途所经过的每个节点都是其祖先 (ancestor), v 是它们的后代 (descendant); 特别的, v 的祖先/后代包括其本身, 而 v 本身以外的祖先/后代称作真祖先 (proper ancestor) / 真后代 (proper descendant)  
节点 v 在每一层次上, v 的祖先至多一个; 若节点 u 是 v 的祖先且恰好比 v 高出一层, 则称 u 是 v 的父亲 (parent), v 是 u 的孩子 (child)  
v 的孩子总数, 称作其度数或度 (degree), 记作 deg(v); 无孩子的节点称作叶节点 (leaf), 包括根在内的其余节点皆为内部节点 (internal node)  
v 所有的后代及其之间的联边称作子树 (subtree), 记作 subtree(v)
###### 高度
树 T 中所有节点深度的最大值称作该树的高度 (height), 记作 height(T); 树的高度总是由其某一叶节点的深度确定的, 特别的, 仅含单个节点的树高度为 0, 空树的高度为 -1; 推而广之, 任一节点 v 所对应的子树 subtree(v) 的高度, 亦称作该节点的高度, 记作 height(v); 特别的, 全树的高度亦即其根节点 r 的高度, height(T) = height(r)

##### 二叉树
二叉树 (binary tree) 中的每个节点的度数均不超过 2, 因此在二叉树中的孩子节点都可以用左右区分, 亦称作有序二叉树 (ordered binary tree); 特别的, 不含一度节点的二叉树称作真二叉树 (proper binary tree)

##### 多叉树
一般的, 树中各节点的孩子数目并不确定, 每个节点的孩子均不超过 k 个的有根树, 称作 k 叉树 (k-ary tree)
###### 父节点
在多叉树中, 根节点以外的任一节点有且仅有一个父节点
```
        |
  ------R------
  |     |     |
--A--   B     C
|   |         |
D   E       --F--
            | | |
            G H K
```
将多叉树的各节点组织为向量或者列表, 其中每个元素除了保存节点本身的信息 (data) 外, 还需要保存父节点 (parent) 的秩或者位置, 可为树根指定一个虚构的父节点 -1 或者 NULL, 以便做统一的判断; 如此在所有向量或列表所占的空间为 O(n), 线性正比于节点总数 n; 时间方面, 确定任一节点的父节点仅需常数时间, 但孩子节点的查找却需要花费 O(n) 的时间
```
   | data   parent
---|--------------
0  |  R      -1
1  |  A       0
2  |  B       0
3  |  C       0
4  |  D       1
5  |  E       1
6  |  F       3
7  |  G       6
8  |  H       6
9  |  K       6
```
###### 孩子节点
若注重孩子节点的快速定位, 则令各节点将其所有的盖子组织为一个向量或列表; 这样对于拥有 r 个孩子的节点, 可以在 O(r + 1) 时间内列举出所有的孩子
```
   | data   children
---|----------------
0  |  A       * ---> [3 | *] ---> [5 | ^]
1  |  B       ^
2  |  C       * ---> [6 | ^]
3  |  D       ^
4  |  R       * ---> [0 | *] ---> [1 | *] ---> [2 | ^]
5  |  E       ^
6  |  F       * ---> [7 | *] ---> [8 | *] ---> [9 | ^]
7  |  G       ^
8  |  H       ^
9  |  K       ^
```
###### 父节点 + 孩子节点
结合父节点表示法和孩子节点表示法, 可令各节点既记录父节点, 同时也维护一个序列以保存所有孩子
```
| data   parent   children
---|----------------------
0  |  A    4         * ---> [3 | *] ---> [5 | ^]
1  |  B    4         ^
2  |  C    4         * ---> [6 | ^]
3  |  D    0         ^
4  |  R    -1        * ---> [0 | *] ---> [1 | *] ---> [2 | ^]
5  |  E    0         ^
6  |  F    2         * ---> [7 | *] ---> [8 | *] ---> [9 | ^]
7  |  G    6         ^
8  |  H    6         ^
9  |  K    6         ^
```
尽管可以如此高效的兼顾父节点和孩子节点的定位, 但在节点插入与删除操作频繁的场合, 为动态维护和更新拓扑结构, 不得不反复遍历和调整一些节点所对应的孩子序列; 然而向量和列表等线性结构都需要耗费大量时间, 势必影响到整体的效率
###### 有序多叉树 = 二叉树
为了保证作为多叉树特例的二叉树有足够的能力表示任何一颗多叉树, 只需要给树增加一项约束条件: 同一节点的所有孩子之间必须具有某一线性次序; 凡符合这一条件的多叉树也称作有序树 (ordered tree)
###### 长子 + 兄弟
有序多叉树中任一非叶节点都有唯一的 "长子", 而且从该 "长子" 出发, 可按照预先约定或指定的次序遍历所有孩子节点; 为每个节点设置两个指针, 分别指向其 "长子" 和下一 "兄弟"
```
|
R
|
A ---> B ---> C
|             |
D ---> E      F
              |
              G ---> H ---> K
```
若将这两个指针分别与二叉树节点的左右孩子指针统一对应起来, 则进一步将具有有序多叉树转换为常规的二叉树
```
                        |
       -----------------R
       |
   --- A ---
   |       |
   D ---   B -------
       |           |
       E       --- C
               |
           --- F
           |
           G ---
               |
               H ---
                   |
                   K
```

#### 编码树
