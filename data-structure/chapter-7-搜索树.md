### 搜索树

#### 查找
##### 循关键码访问
所谓的查找或者搜索, 指从一组数据对象中找出符合特定条件者, 这是构建算法的一种基本而重要的操作; 其中的数据对象, 统一的表示和实现为词条 (entry) 的形式, 不同的词条之间依照各自的关键码 (key) 彼此区分; 这一新的访问方式, 与数据对象的物理位置与逻辑次序均无关, 查找的过程与结果仅仅取决于目标对象的关键码, 这种方式也称作循关键码访问 (call-by-key)

##### 词条
```
template <typename K, typename V> struct Entry { // 词条模板类
    K key; V value; // 关键码, 数据
    Entry(K k = K(), V v = V()): key(k), value(v) {}; // 基于克隆的构造器
    Entry(Entry<K,V> const& e): key(e.key), value(e.value) {}; // 基于克隆的构造函数
    bool operator< (Entry<K,V> const& e) {return key < e.key;} // 比较器: 小于
    bool operator> (Entry<K,V> const& e) {return key > e.key;} // 比较器: 大于
    bool operator== (Entry<K,V> const& e) {return key == e.key;} // 比较器: 等于
    bool operator!= (Entry<K,V> const& e) {return key != e.key;} // 比较器: 不等于
}
```
词条对象拥有成员变量 key 和 value, 前者作为特征, 是词条之间比对和比较的依据, 后者为实际的数据

##### 序与比较器
关键码之间能够相互比较, 这里有一个隐含条件: 所有词条构成一个全序关系, 可以相互比对和比较; 但是这一条件并不是总满足, 优势需要付出有限的代价来维护一个偏序关系

#### 二叉搜索树
##### 顺序性
若二叉树中各节点所对应的词条之间支持大小比较, 则在不致歧义的情况下, 可以不必严格区分树中的节点, 节点所对应的词条以及词条内部所对应的关键码  
在二叉搜索树 (binary search tree) 中, 处处都满足顺序性: ** 任一节点 r 的左 (右) 子树中, 所有节点 (若存在) 均不大于 (不小于) r **
```
        --------- r ---------
        |                   |
       r_L                 r_R
  L-subtree(<=r)       L-subtree(r<=)
```
##### 中序遍历序列
```
                               |
                     --------- 16 ---------
                     |                    |
            --- 10 ---             ------ 25 ------
           |         |             |              |
       --- 5 ----    11 ---    --- 19 ---    --- 28 ---
       |        |         |    |        |    |        |
       2 ---    8     --- 15   17       22   27   --- 37
           |          |                           |
           4          13                          33
二叉搜索树的中序遍历: 2, 4, 5, 8, 10, 11, 13, 15, 16, 17, 19, 22, 25, 17, 18, 33, 37
```
任何一颗二叉树是二叉搜索树, 当且仅当其中序遍历序列单调非降

##### BST 模板类
二叉搜索树是二叉树的特例, 故可以基于 BinTree 类派生出 BST 模板类
```
#include "../BinTree/BinTree.h" // 引入 BinTree

template <typename T> class BST : public BinTree<T> { // 由 BinTree 派生 BST 模板类
    protected:
        BinNodePosi(T) _hot; // "命中" 节点的父亲
        BinNodePosi(T) connect34 ( // 按照 3 + 4 结构, 联接 3 个节点 4 个子树
            BinNodePosi(T), BinNodePosi(T), BinNodePosi(T),
            BinNodePosi(T), BinNodePosi(T), BinNodePosi(T), BinNodePosi(T))
        BinNodePosi(T) rotateAt(BinNodePosi(T) x); // 对 x 及其父亲, 祖父做统一旋转调整
    public: // 基本接口: 以 virtual 修饰, 强制要求所有派生类根据各各自的规则对其重写
        virtual BinNodePosi(T) & search(const T& e); // 查找
        virtual BinNodePosi(T) insert(const T& e); // 插入
        virtual bool remove(const T& e); // 删除
}
```
这些接口的语义均涉及词条的大小和相等关系, 故这里也假定基本元素类型 T 或者直接支持比较和判等操作, 或者已经重载过对应的操作符
##### 查找算法及其实现
###### 算法
二叉搜索树查找算法, 采用减而治之的思路和策略, 其执行过程可描述为: ** 从树根出发, 逐步地缩小范围, 直到发现目标 (成功) 或者缩小至空树 (失败) **  
一般的, 在查找过程中, 一旦发现当前节点为 NULL, 即说明查找范围已经缩小至空, 查找失败; 否则视关键码比较结果, 向左 (更小) 或向右 (更大) 深入, 或者报告成功 (相等)  
对照中序遍历可见, 整个过程与有序向量的二分查找过程等效, 可视为后者的推广
###### searchIn() 算法和 search() 接口
一般的, 在子树 v 中查找关键码 e 的过程, 可实现为如下的 searchIn()
```
// 在以 v 为根的 (AVL, SPLAY, rbTree 等) BST 子树中查找关键码 e
template <typename T> static BinNodePosi(T) & searchIn(BinNodePosi(T) & v, const T& e, BinNodePosi(T) & hot) {
    if (!v || e == v->data) return v; // 递归基, 在节点 v (或假想的通配节点) 处命中
    hot = v; // 一般情况: 先记下当前节点
    return searchIn(((e < v->data) ? v->lc : v->rc), e, hot); // 深入一层, 递归查找
} // 返回时, 返回值指向命中节点, hot 指向器父节点 (退化时为初始值 NULL)
```
通过调用 searchIn() 算法, 可实现二叉搜索树的标准接口 search()
```
// 在 BST 中查找关键码 e
template <typename T> BinNodePosi(T) & BST<T>::search(const T& e) {
    return searchIn(_root, e, _hot = NULL);
} // 返回节点位置, 以便后续插入和删除操作
```
###### 语义约定
searchIn() 和 search() 的返回值都指向一个关键码为 e 且真实存在的节点, 若查找失败, 则返回的数值虽然为 NULL; 对于后一种情况不妨假想的将此空节点转换为一个数值为 e 的哨兵节点, 这样无论成功与否, 查找的返回值总是等效的指向 "命中节点"
###### 效率
在二叉搜索树的每一车, 查找算法最多访问一个节点, 且只需要常数时间, 故总体所需时间线性正比于查找路径长度, 或最终返回节点的深度; 在最好的情况下, 只需 O(1) 的时间; 最最差的情况下, 规模为 n 的二叉搜索树, 深度最坏情况下可达 $ \Omega(n) $; 因此若要控制单次查找在最坏情况下的时间, 必须从二叉搜索树的高度入手

##### 插入算法及其实现
###### 算法
为了在二叉搜索树中插入一个节点, 首先需要利用查找算法 search() 确定插入位置及其方向, 然后才能将新节点作为叶子节点插入, 为保持二叉搜索树的完整性和一致性, 还需要更新祖先的高度
###### 实现
```
// 将关键码 e 插入 BST 树中
template <typename T> BinNodePosi(T) BST<T>::insert(const T& e) {
    BinNodePosi(T) & x = search(e);
    if (x) return x; // 如果目标存在则直接返回
    x = new BinNode<T>(e, _hot); // 创建新节点 x, 以 e 为关键码, 以 _hot 为父
    _size++; // 更新全树规模
    updateHeightAbove(x); // 更新 x 及其历代祖先的高度
    return x; // 新节点的插入必为叶子
} // 无论 e 是否存在于原树中, 返回时总有 x->data = e;
```
###### 效率
节点插入操作所需的时间, 主要消耗在对算法 search() 和 updateHeightAbove() 的调用, 后者与前者相同, 在一层次至多涉及一个节点, 仅消耗 O(1) 时间, 故其时间复杂度同样取决于新节点的深度, 最坏情况下不超过全树的高度

##### 删除算法及其实现
为从二叉搜索树中删除节点, 首先也需要调用算法 BST:search(), 判断目标节点是否的确存在于树中, 若存在, 则返回器位置, 才能相应的具体实施删除操作
###### 单分支情况
将待删除的节点替换为其孩子节点, 释放被删除节点的空间, 更新 \_hot 及其祖先节点的高度; 此场景也覆盖可无分支情况
###### 双分支情况
先调用 BST::succ() 算法找到待删除节点的后继 (该后继节点必无左孩子), 然后交换待删除节点和后继节点的数据项, 从而将问题转换为无分支情况或单分支情况, 继续完成删除节点操作并更新 \_hot 及其祖先节点的高度
###### remove()
```
// 从 BST 树中删除关键码 e
template <typename T> bool BST<T>::remove(const T& e) {
    BinNodePosi(T) & x = search(e);
    if (!x) return false; // 如果目标不存在则返回 false
    removeAt(x, _hot); // 实施删除
    _size++;
    updateHeightAbove(_hot); // 更新 _hot 及其祖先节点的高度
    return ture;
} // 返回是否删除成功
```
###### removeAt()
```
/**********************************************************************************************
* BST 节点删除算法: 删除位置 x 所指的节点 (全局静态模板函数, 适用于 AVL, Splay, RedBlack 等各种 BST)
* 目标 x 在此前经过查找定位, 并确认非 NULL, 故必删除成功, 与 searchIn 不同, 调用之前不必将 _hot 置空
* 返回值指向实际被删除节点的接替者, hot 指向实际被删除节点的父亲, 二者均有可能为 NULL
***********************************************************************************************
template <typename T> static BinNodePosi(T) removeAt(BinNodePosi(T) & x, BinNodePosi(T) & T) {
    BinNodePosi(T) w = x; // 实际被摘除的节点, 初值同 x
    BinNodePosi(T) succ = NULL; // 实际别删除节点的接替者
    if (!HasLChild(*x)) {
        succ = x = x->rc; // 若左子树为空, 直接将 *x 替换为其右子树
    } else if (!HasRChild(*x)) {
        succ = x = x->lc; // 若右子树为空, 直接将 *x 替换为其左子树
    } else { // 若左右子树均存在
        w = w->succ(); // (在右子树中) 找到 *x 的直接后继 *w
        swap(x->data, w->data); // 交换 *x 和 *w 的数据元素
        BinNodePosi(T) u = w->parent;
        ((u == x) ? u->rc : u->lc) = succ = w->rc; // u == x 时, w->rc 替代 u; u != x 时, w-rc 成为 u 的左子树
    }
    hot = w->parent; // 记录实际被删除节点的父亲
    if (succ) succ->parent = hot; // 并将被删除节点的接替者与 hot 相连
    release(w->data);
    release(w);
    return succ; // 释放被摘除节点, 返回接替者
}
```
###### 效率
删除操作所需的时间, 主要消耗于 search(), succ(), updateHeightAbove() 的调用, 在树中的任一高度, 至多消耗 O(1) 的时间, 总体的时间复杂度亦不超过全树高度

#### 平衡二叉搜索树
##### 树高与性能
search(), insert(), remove() 等主要接口的运行时间, 均线性正比于二叉搜索树的高度; 在最坏的情况下, 二叉搜索树可能彻底退化为列表, 此时查找效率线性正比于数据集的规模; 因此, 不能有效的控制二叉树的高度, 较之此前的向量和列表就无法体现出优势
###### 随机生成
将各节点对应于 n 个互异关键码 $\{e_1, e_2, ..., e_n}\ $, 于是按照每一排列组合 $ \sigma  = (e_{i_1}, e_{i_2}, ..., e_{i_n}) $ 可对应二叉搜索树 $ T(\sigma)$, 称作 "随机生成 (randomly generated)"; 以三个关键码 {1, 2, 3} 为例
```
  1 2 3                3 2 1       1 3 2            3 1 2           2 1 3 / 2 1 3
    |                    |           |                |                  |
    1 ---            --- 3           1 ---        --- 3              --- 2 ---
        |            |                   |        |                  |       |
        2 ---    --- 2               --- 3        1 ---              1       3
            |    |                   |                |
            3    1                   2                2
```
显然, 任意的 n 个互异关键码, 都可以构成 n! 种全排序, 若各种排序作为输入序列的概率均等, 将其平均查找长度进行平均, 则在这一随机意义下, 二叉搜素树的平均高度为 $ \Theta(logn) $
###### 随机组成
另一随机策略是, 假定 n 个互异节点同时给定, 在遵守顺序性的前提下, 随机确定它们之间的拓扑联接; 称二叉搜索树由这些节点 "随机组成 (randomly composed)"; n 个互异节点组成的二叉搜索树, 总共可能有 (2n)!/n!/(n + 1)! 颗, 若这些树等概率出现, 则平均查找长度为 $ \Theta(\sqrt{n}) $
###### 比较
前一口径的 $ \Theta(logn) $ 和后一口径的 $ \Theta(\sqrt{n}) $ 之间的不同在于, 排列 (2, 1, 3) 和 (2, 3, 1) 生成的时间上是一颗二叉搜索树
###### 树高和平均树高
在实际中理想分布出现的情况并不多见; 另外, 若 removeAt() 操作总是固定的将待删除的双分支节点与其直接后继交换, 则随着操作次数增加, 二叉搜索树向左侧倾斜的趋势越发明显

##### 理想平衡和适度平衡
###### 理想平衡
理想平衡应尽可能的使兄弟子树高度彼此接近, 即全树尽可能的平衡; 包含 n 个节点的二叉树, 高度不可能小于 $ \lfloor log_2n \rfloor $, 若树恰好为次, 则称作理想平衡树, 完全二叉树和满二叉树均属于此类; 但此条件太过于苛刻, 理想平衡树的情况比例极低
###### 适度平衡
理想平衡难以达到, 所以采取适度平衡的 AVL 树, 后续的伸展树, 红黑树, kd-树都属于适度平衡, 因此都可归入为平衡二叉搜索树 (balanced binary search tree, BBST)

##### 等价交换
###### 等价二叉搜索树
若两棵二叉搜索树的中序遍历序列相同, 则称它们彼此等价, 反之亦然
```
           |                                          |
 --------- 9 --------                       --------- 9 ---------
 |                  |                       |                   |
 5 ---          --- 11 ---                  5 ---           --- 11 ---
     |          |        |                      |           |        |
     8          10   --- 19                     8           10   --- 16 ---
                     |                                           |        |
                     13 ---                                      13       19
                          |
                          16
  5, 8, 9, 10, 11, 13, 16, 19                 5, 8, 9, 10, 11, 13, 16, 19
```
等价二叉搜索树中各节点的垂直高度可能有所不同, 但水平次序完全一致; 这一特点可概括为 "上下可变, 左右不乱"
###### 局部性
平衡二叉搜索树的适度平衡性, 都是通过对树中每一局部增加某种限制条件来保证的; 例如红黑树中, 从根节点到叶节点的通路包含一样多的黑节点; 在 AVL 树中, 兄弟节点的高度相差不过 1; 除了这些适度平衡性, 还具有如下局部平衡性
- 经过单次动态修改操作后, 至多只有 $ O(logn) $ 处局部不再满足限制条件
- 可在 $ O(logn) $ 时间内, 使这 $ O(logn) $ 处局部 (以至全树) 重新满足限制条件

这意味着: 刚刚失去平衡的二叉搜索树必然可以迅速转换为一棵等价的平衡二叉搜索树, 上述转换过程也称等价交换

##### 旋转调整
最基本的修复手段, 就是通过围绕特定节点的旋转, 实现等价前提下的局部拓扑调整
###### zig 和 zag
```
          zig(v)                          zigged
            |        ---                    |
        --- v ---      |                --- c ---
        |       |    <--     ===>       |       |
    --- c ---   z                       x   --- v ---
    |       |                               |       |
    x       y                               y       z
```
以 v 为轴做 zig 旋转, 重新调整这两个节点与三颗子树的联接关系: 将 x 和 v 作为 c 的左右子树, y 和 z 分别作为 v 的左右子树; 尽管局部结构和子树根有变化, 但中序遍历不变, 故 zig 旋转属于等价变换
```
          zaged(v)                          zag(v)
            |                   ---          |
        --- c ---               |        --- v ---
        |       |      <===     -->      |       |
    --- v ---   z                        x   --- c ---
    |       |                                |       |
    x       y                                y       z
```
以 v 为轴做 zag 旋转, 重新调整这两个节点与三颗子树的联接关系: 将 v 和 z 作为 c 的左右子树, x 和 y 分别作为 v 的左右子树; 尽管局部结构和子树根有变化, 但中序遍历不变, 故 zag 旋转属于等价变换
###### 效率与效果
zig 和 zag 旋转均属于局部操作, 仅涉及常数个节点之间的操作, 可在常数时间内完成; 经过一次 zig 或 zag 旋转后, 局部子树 (甚至全树) 的高度可能变化, 但上下幅度均不超过一层

#### AVL 树
