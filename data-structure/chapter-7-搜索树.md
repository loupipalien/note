### 搜索树

#### 查找
##### 循关键码访问
所谓的查找或者搜索, 指从一组数据对象中找出符合特定条件者, 这是构建算法的一种基本而重要的操作; 其中的数据对象, 统一的表示和实现为词条 (entry) 的形式, 不同的词条之间依照各自的关键码 (key) 彼此区分; 这一新的访问方式, 与数据对象的物理位置与逻辑次序均无关, 查找的过程与结果仅仅取决于目标对象的关键码, 这种方式也称作循关键码访问 (call-by-key)

##### 词条
```
template <typename K, typename V> struct Entry { // 词条模板类
    K key; V value; // 关键码, 数据
    Entry(K k = K(), V v = V()): key(k), value(v) {}; // 基于克隆的构造器
    Entry(Entry<K,V> const& e): key(e.key), value(e.value) {}; // 基于克隆的构造函数
    bool operator< (Entry<K,V> const& e) {return key < e.key;} // 比较器: 小于
    bool operator> (Entry<K,V> const& e) {return key > e.key;} // 比较器: 大于
    bool operator== (Entry<K,V> const& e) {return key == e.key;} // 比较器: 等于
    bool operator!= (Entry<K,V> const& e) {return key != e.key;} // 比较器: 不等于
}
```
词条对象拥有成员变量 key 和 value, 前者作为特征, 是词条之间比对和比较的依据, 后者为实际的数据

##### 序与比较器
关键码之间能够相互比较, 这里有一个隐含条件: 所有词条构成一个全序关系, 可以相互比对和比较; 但是这一条件并不是总满足, 优势需要付出有限的代价来维护一个偏序关系

#### 二叉搜索树
##### 顺序性
若二叉树中各节点所对应的词条之间支持大小比较, 则在不致歧义的情况下, 可以不必严格区分树中的节点, 节点所对应的词条以及词条内部所对应的关键码  
在二叉搜索树 (binary search tree) 中, 处处都满足顺序性: ** 任一节点 r 的左 (右) 子树中, 所有节点 (若存在) 均不大于 (不小于) r **
```
        --------- r ---------
        |                   |
       r_L                 r_R
  L-subtree(<=r)       L-subtree(r<=)
```
##### 中序遍历序列
```
                               |
                     --------- 16 ---------
                     |                    |
            --- 10 ---             ------ 25 ------
           |         |             |              |
       --- 5 ----    11 ---    --- 19 ---    --- 28 ---
       |        |         |    |        |    |        |
       2 ---    8     --- 15   17       22   27   --- 37
           |          |                           |
           4          13                          33
二叉搜索树的中序遍历: 2, 4, 5, 8, 10, 11, 13, 15, 16, 17, 19, 22, 25, 17, 18, 33, 37
```
任何一颗二叉树是二叉搜索树, 当且仅当其中序遍历序列单调非降

##### BST 模板类
二叉搜索树是二叉树的特例, 故可以基于 BinTree 类派生出 BST 模板类
```
#include "../BinTree/BinTree.h" // 引入 BinTree

template <typename T> class BST : public BinTree<T> { // 由 BinTree 派生 BST 模板类
    protected:
        BinNodePosi(T) _hot; // "命中" 节点的父亲
        BinNodePosi(T) connect34 ( // 按照 3 + 4 结构, 联接 3 个节点 4 个子树
            BinNodePosi(T), BinNodePosi(T), BinNodePosi(T),
            BinNodePosi(T), BinNodePosi(T), BinNodePosi(T), BinNodePosi(T))
        BinNodePosi(T) rotateAt(BinNodePosi(T) x); // 对 x 及其父亲, 祖父做统一旋转调整
    public: // 基本接口: 以 virtual 修饰, 强制要求所有派生类根据各各自的规则对其重写
        virtual BinNodePosi(T) & search(const T& e); // 查找
        virtual BinNodePosi(T) insert(const T& e); // 插入
        virtual bool remove(const T& e); // 删除
}
```
这些接口的语义均涉及词条的大小和相等关系, 故这里也假定基本元素类型 T 或者直接支持比较和判等操作, 或者已经重载过对应的操作符
##### 查找算法及其实现
###### 算法
二叉搜索树查找算法, 采用减而治之的思路和策略, 其执行过程可描述为: ** 从树根出发, 逐步地缩小范围, 直到发现目标 (成功) 或者缩小至空树 (失败) **  
一般的, 在查找过程中, 一旦发现当前节点为 NULL, 即说明查找范围已经缩小至空, 查找失败; 否则视关键码比较结果, 向左 (更小) 或向右 (更大) 深入, 或者报告成功 (相等)  
对照中序遍历可见, 整个过程与有序向量的二分查找过程等效, 可视为后者的推广
###### searchIn() 算法和 search() 接口
一般的, 在子树 v 中查找关键码 e 的过程, 可实现为如下的 searchIn()
```
// 在以 v 为根的 (AVL, SPLAY, rbTree 等) BST 子树中查找关键码 e
template <typename T> static BinNodePosi(T) & searchIn(BinNodePosi(T) & v, const T& e, BinNodePosi(T) & hot) {
    if (!v || e == v->data) return v; // 递归基, 在节点 v (或假想的通配节点) 处命中
    hot = v; // 一般情况: 先记下当前节点
    return searchIn(((e < v->data) ? v->lc : v->rc), e, hot); // 深入一层, 递归查找
} // 返回时, 返回值指向命中节点, hot 指向器父节点 (退化时为初始值 NULL)
```
通过调用 searchIn() 算法, 可实现二叉搜索树的标准接口 search()
```
// 在 BST 中查找关键码 e
template <typename T> BinNodePosi(T) & BST<T>::search(const T& e) {
    return searchIn(_root, e, _hot = NULL);
} // 返回节点位置, 以便后续插入和删除操作
```
###### 语义约定
searchIn() 和 search() 的返回值都指向一个关键码为 e 且真实存在的节点, 若查找失败, 则返回的数值虽然为 NULL; 对于后一种情况不妨假想的将此空节点转换为一个数值为 e 的哨兵节点, 这样无论成功与否, 查找的返回值总是等效的指向 "命中节点"
###### 效率
在二叉搜索树的每一车, 查找算法最多访问一个节点, 且只需要常数时间, 故总体所需时间线性正比于查找路径长度, 或最终返回节点的深度; 在最好的情况下, 只需 O(1) 的时间; 最最差的情况下, 规模为 n 的二叉搜索树, 深度最坏情况下可达 $ \Omega(n) $; 因此若要控制单次查找在最坏情况下的时间, 必须从二叉搜索树的高度入手

##### 插入算法及其实现
###### 算法
为了在二叉搜索树中插入一个节点, 首先需要利用查找算法 search() 确定插入位置及其方向, 然后才能将新节点作为叶子节点插入, 为保持二叉搜索树的完整性和一致性, 还需要更新祖先的高度
###### 实现
```
// 将关键码 e 插入 BST 树中
template <typename T> BinNodePosi(T) BST<T>::insert(const T& e) {
    BinNodePosi(T) & x = search(e);
    if (x) return x; // 如果目标存在则直接返回
    x = new BinNode<T>(e, _hot); // 创建新节点 x, 以 e 为关键码, 以 _hot 为父
    _size++; // 更新全树规模
    updateHeightAbove(x); // 更新 x 及其历代祖先的高度
    return x; // 新节点的插入必为叶子
} // 无论 e 是否存在于原树中, 返回时总有 x->data = e;
```
###### 效率
节点插入操作所需的时间, 主要消耗在对算法 search() 和 updateHeightAbove() 的调用, 后者与前者相同, 在一层次至多涉及一个节点, 仅消耗 O(1) 时间, 故其时间复杂度同样取决于新节点的深度, 最坏情况下不超过全树的高度

##### 删除算法及其实现
为从二叉搜索树中删除节点, 首先也需要调用算法 BST:search(), 判断目标节点是否的确存在于树中, 若存在, 则返回器位置, 才能相应的具体实施删除操作
###### 单分支情况
将待删除的节点替换为其孩子节点, 释放被删除节点的空间, 更新 \_hot 及其祖先节点的高度; 此场景也覆盖可无分支情况
###### 双分支情况
先调用 BST::succ() 算法找到待删除节点的后继 (该后继节点必无左孩子), 然后交换待删除节点和后继节点的数据项, 从而将问题转换为无分支情况或单分支情况, 继续完成删除节点操作并更新 \_hot 及其祖先节点的高度
###### remove()
```
// 从 BST 树中删除关键码 e
template <typename T> bool BST<T>::remove(const T& e) {
    BinNodePosi(T) & x = search(e);
    if (!x) return false; // 如果目标不存在则返回 false
    removeAt(x, _hot); // 实施删除
    _size++;
    updateHeightAbove(_hot); // 更新 _hot 及其祖先节点的高度
    return ture;
} // 返回是否删除成功
```
###### removeAt()
```
/**********************************************************************************************
* BST 节点删除算法: 删除位置 x 所指的节点 (全局静态模板函数, 适用于 AVL, Splay, RedBlack 等各种 BST)
* 目标 x 在此前经过查找定位, 并确认非 NULL, 故必删除成功, 与 searchIn 不同, 调用之前不必将 _hot 置空
* 返回值指向实际被删除节点的接替者, hot 指向实际被删除节点的父亲, 二者均有可能为 NULL
***********************************************************************************************
template <typename T> static BinNodePosi(T) removeAt(BinNodePosi(T) & x, BinNodePosi(T) & T) {
    BinNodePosi(T) w = x; // 实际被摘除的节点, 初值同 x
    BinNodePosi(T) succ = NULL; // 实际别删除节点的接替者
    if (!HasLChild(*x)) {
        succ = x = x->rc; // 若左子树为空, 直接将 *x 替换为其右子树
    } else if (!HasRChild(*x)) {
        succ = x = x->lc; // 若右子树为空, 直接将 *x 替换为其左子树
    } else { // 若左右子树均存在
        w = w->succ(); // (在右子树中) 找到 *x 的直接后继 *w
        swap(x->data, w->data); // 交换 *x 和 *w 的数据元素
        BinNodePosi(T) u = w->parent;
        ((u == x) ? u->rc : u->lc) = succ = w->rc; // u == x 时, w->rc 替代 u; u != x 时, w-rc 成为 u 的左子树
    }
    hot = w->parent; // 记录实际被删除节点的父亲
    if (succ) succ->parent = hot; // 并将被删除节点的接替者与 hot 相连
    release(w->data);
    release(w);
    return succ; // 释放被摘除节点, 返回接替者
}
```
###### 效率
删除操作所需的时间, 主要消耗于 search(), succ(), updateHeightAbove() 的调用, 在树中的任一高度, 至多消耗 O(1) 的时间, 总体的时间复杂度亦不超过全树高度

#### 平衡二叉搜索树
##### 树高与性能
search(), insert(), remove() 等主要接口的运行时间, 均线性正比于二叉搜索树的高度; 在最坏的情况下, 二叉搜索树可能彻底退化为列表, 此时查找效率线性正比于数据集的规模; 因此, 不能有效的控制二叉树的高度, 较之此前的向量和列表就无法体现出优势
###### 随机生成
将各节点对应于 n 个互异关键码 $\{e_1, e_2, ..., e_n}\ $, 于是按照每一排列组合 $ \sigma  = (e_{i_1}, e_{i_2}, ..., e_{i_n}) $ 可对应二叉搜索树 $ T(\sigma)$, 称作 "随机生成 (randomly generated)"; 以三个关键码 {1, 2, 3} 为例
```
  1 2 3                3 2 1       1 3 2            3 1 2           2 1 3 / 2 1 3
    |                    |           |                |                  |
    1 ---            --- 3           1 ---        --- 3              --- 2 ---
        |            |                   |        |                  |       |
        2 ---    --- 2               --- 3        1 ---              1       3
            |    |                   |                |
            3    1                   2                2
```
显然, 任意的 n 个互异关键码, 都可以构成 n! 种全排序, 若各种排序作为输入序列的概率均等, 将其平均查找长度进行平均, 则在这一随机意义下, 二叉搜素树的平均高度为 $ \Theta(logn) $
###### 随机组成
另一随机策略是, 假定 n 个互异节点同时给定, 在遵守顺序性的前提下, 随机确定它们之间的拓扑联接; 称二叉搜索树由这些节点 "随机组成 (randomly composed)"; n 个互异节点组成的二叉搜索树, 总共可能有 (2n)!/n!/(n + 1)! 颗, 若这些树等概率出现, 则平均查找长度为 $ \Theta(\sqrt{n}) $
###### 比较
前一口径的 $ \Theta(logn) $ 和后一口径的 $ \Theta(\sqrt{n}) $ 之间的不同在于, 排列 (2, 1, 3) 和 (2, 3, 1) 生成的时间上是一颗二叉搜索树
###### 树高和平均树高
在实际中理想分布出现的情况并不多见; 另外, 若 removeAt() 操作总是固定的将待删除的双分支节点与其直接后继交换, 则随着操作次数增加, 二叉搜索树向左侧倾斜的趋势越发明显

##### 理想平衡和适度平衡
###### 理想平衡
理想平衡应尽可能的使兄弟子树高度彼此接近, 即全树尽可能的平衡; 包含 n 个节点的二叉树, 高度不可能小于 $ \lfloor log_2n \rfloor $, 若树恰好为次, 则称作理想平衡树, 完全二叉树和满二叉树均属于此类; 但此条件太过于苛刻, 理想平衡树的情况比例极低
###### 适度平衡
理想平衡难以达到, 所以采取适度平衡的 AVL 树, 后续的伸展树, 红黑树, kd-树都属于适度平衡, 因此都可归入为平衡二叉搜索树 (balanced binary search tree, BBST)

##### 等价交换
###### 等价二叉搜索树
若两棵二叉搜索树的中序遍历序列相同, 则称它们彼此等价, 反之亦然
```
           |                                          |
 --------- 9 --------                       --------- 9 ---------
 |                  |                       |                   |
 5 ---          --- 11 ---                  5 ---           --- 11 ---
     |          |        |                      |           |        |
     8          10   --- 19                     8           10   --- 16 ---
                     |                                           |        |
                     13 ---                                      13       19
                          |
                          16
  5, 8, 9, 10, 11, 13, 16, 19                 5, 8, 9, 10, 11, 13, 16, 19
```
等价二叉搜索树中各节点的垂直高度可能有所不同, 但水平次序完全一致; 这一特点可概括为 "上下可变, 左右不乱"
###### 局部性
平衡二叉搜索树的适度平衡性, 都是通过对树中每一局部增加某种限制条件来保证的; 例如红黑树中, 从根节点到叶节点的通路包含一样多的黑节点; 在 AVL 树中, 兄弟节点的高度相差不过 1; 除了这些适度平衡性, 还具有如下局部平衡性
- 经过单次动态修改操作后, 至多只有 $ O(logn) $ 处局部不再满足限制条件
- 可在 $ O(logn) $ 时间内, 使这 $ O(logn) $ 处局部 (以至全树) 重新满足限制条件

这意味着: 刚刚失去平衡的二叉搜索树必然可以迅速转换为一棵等价的平衡二叉搜索树, 上述转换过程也称等价交换

##### 旋转调整
最基本的修复手段, 就是通过围绕特定节点的旋转, 实现等价前提下的局部拓扑调整
###### zig 和 zag
```
          zig(v)                          zigged
            |        ---                    |
        --- v ---      |                --- c ---
        |       |    <--     ===>       |       |
    --- c ---   z                       x   --- v ---
    |       |                               |       |
    x       y                               y       z
```
以 v 为轴做 zig 旋转, 重新调整这两个节点与三颗子树的联接关系: 将 x 和 v 作为 c 的左右子树, y 和 z 分别作为 v 的左右子树; 尽管局部结构和子树根有变化, 但中序遍历不变, 故 zig 旋转属于等价变换
```
          zaged(v)                          zag(v)
            |                   ---          |
        --- c ---               |        --- v ---
        |       |      <===     -->      |       |
    --- v ---   z                        x   --- c ---
    |       |                                |       |
    x       y                                y       z
```
以 v 为轴做 zag 旋转, 重新调整这两个节点与三颗子树的联接关系: 将 v 和 z 作为 c 的左右子树, x 和 y 分别作为 v 的左右子树; 尽管局部结构和子树根有变化, 但中序遍历不变, 故 zag 旋转属于等价变换
###### 效率与效果
zig 和 zag 旋转均属于局部操作, 仅涉及常数个节点之间的操作, 可在常数时间内完成; 经过一次 zig 或 zag 旋转后, 局部子树 (甚至全树) 的高度可能变化, 但上下幅度均不超过一层

#### AVL 树
在渐进意义下, AVL 树 (AVL tree) 可始终将其高度控制在 O(logn) 以内, 从而保证每次查找, 插入或删除操作均可在 O(logn) 的时间内完成

##### 定义与性质
###### 平衡因子
任一节点 v 的平衡因子 (balance factor) 定义为左右子树的高度差, 即 balFac(v) = height(lc(v)) - height(rc(v)); AVL 树即是平衡因子受限的二叉搜索树, 其中各节点平衡因子的绝对值不超过 1
###### 接口定义
基于 BST 模板类派生
```
#include "../BST/BST.h"
template <typename T> class AVL : public BST<T> {
    public:
        BinNodePosi(T) insert(const T& e); // 插入 (重写)
        bool remove(const T& e); // 删除 (重写)
        // 其余接口沿用 BST 模板类
}
```
为简化对节点平衡性的判断, 算法实现可使用以下宏定义
```
#define Balanced(x) (stature(x.lc) == stature(x.rc)) // 理想平衡条件
#define BalFac(x) (stature(x.lc) - stature(x,rc)) // 平衡因子
#define AvlBalanced(x) (-2 < BalFac(x)) && (BalFac(x) < 2)
```
###### 平衡性
TODO
总而言之, 高度为 h 的 AVL 树的确至少包含 fib(h + 3) - 1 个节点, 包含 n 个节点的 AVL 树的高度应该为 O(logn)
###### 失衡与重平衡
二叉搜索树的 BST::insert() 插入节点和 BST::remove() 删除节点往往会造成树失衡
```
         (a)                         (b)                          (c)
          |                           |                            |
      --- G- ------      <===     --- G- ------       ===>     --- G- ------
      |           |    remove(Y)  |           |    insert(M)   |           |
  --- E+      --- R+          --- E+      --- R+ ---       --- E+      --- R+ ---
  |           |               |           |        |       |           |        |
  B       --- N+              B       --- N+       Y       B       --- N+       Y
          |                           |                            |
          K                           K                            K- ---
                                                                        |
                                                                        M
```                      
因节点 x 的插入或删除而暂时失衡的节点, 构成失衡节点集, 记作 UT(x); 若 x 为被摘除的节点, 则 UT(x) 仅含单个节点; 但若 x 为被引入的节点, 则 UT(x) 可能包含多个节点
##### 节点插入
###### 失衡节点集
新引入节点 x 后, UT(x) 中的节点都是 x 的祖先, 且高度不低于 x 的祖父; 将其中的最深者记作 g(x), 在 x 与 g(x) 之间的通路上, 设 p 为 g(x) 的孩子, v 为 p 的孩子; 既然 g(x) 不低于 x 的祖父, 则 p 必是 x 的真祖先
###### 重平衡
首先需要找到如上定义的 g(x), 为此可从 x 出发沿 parent 指针逐层上行并核对平衡因子, 首次遇到的失衡祖先即为 g(x); 由于原树是平衡的, 故这一过程只需 O(logn) 的时间  
由于 g(x) 是因为 x 的引入而失衡的, 则 p 和 v 的高度均不会低于其各自兄弟, 借助以下宏可反过来由 g(x) 找到 p 和 v
```
/***************************************************
* 在左右孩子中取更高者
* 在 AVL 平衡调整前, 借此确定重构方案
****************************************************
#define talllerChild(x) (
    stature(x->lc) > stature(x->rc) ? x->lc : ( // 左高
        stature(x->rc) > stature(x->lc) > x->rc : ( // 右高
            IsLChild(*x) ? x->lc : x->rc // 等高于父亲 x 同侧者优先
        )    
    )
)
```
###### 单旋
```                        
     |               zag(g)                   |
 --- g ---            ===>             ------ p ------   
 |       |                             |             |
 T0  --- p ---                     --- g ---     --- v ---
     |       |                     |       |     |       |
     T1  --- v ---                 T0      T1   T2(x)  T3(x)
         |       |
       T2(x)   T3(x)
```
如上图所示, v 是 p 的右孩子, p 是 g(x) 的左孩子; 这种情况下, 必是由于在子树 v 中刚插入了节点 x, 而使 g(x) 不再平衡; 做逆时针旋转的 zag(g(x)) 可得到平衡的等价的二叉搜索树; 不难验证, 通过 zig(g(x)) 可以处理对称的失衡
###### 双旋
```
    |               zig(p)         |                    zag(g)             |
--- g ------         ===>      --- g ------              ===>       ------ v ------
|          |                   |          |                         |             |
T0     --- p ---              T0      --- v ------              --- g ---     --- p ---
       |       |                      |          |              |       |     |       |
   --- v ---   T3                    T1(x)   --- p ---         T0      T1(x) T2(x)    T3
   |       |                                 |       |
  T1(x)   T2(x)                             T2(x)   T3
```
如上图所示, v 是 p 的左孩子, p 是 g(x) 的右孩子; 这种情况下, 在子树 v 中插入了新节点 x, 而导致 g(x) 不再平衡; 可先做 zig(p), 再做 zag(g) 得到平衡的等价的二叉搜索树; 不难验证, 通过 zag(p) 和 zig(p) 可以处理对称的失衡
###### 高度复原
经过局部调整后, 不仅 g(x) 能够重获平衡, 而且局部子树的高度也必将复原, g(x) 所有祖先的平衡因子也将复原; 这就是说, 在 AVL 树中插入新节点后, 仅需不超过两次旋转即可使整树恢复平衡
###### 实现
```
// 将关键码 e 插入 AVL 树中
template <typename T> BinNodePosi(T) AVL<T>::insert(const T& e) {
    BinNodePosi(T) & x = search(e);
    if (x) return x; // 目标存在则直接返回
    BinNodePosi(T) xx = x = new BinNode(e, _hot);
    _size++; // 创建新节点 x
    // 此时 x 的父亲增高, 则其祖父有可能失衡
    for (BinNodePosi(T) g = _hot; g ; g = g->parent) { // 从 x 之父出发向上, 逐层检查各代祖先 g
        if (AvlBalanced(*g)) { // 一旦发现失衡, 采用 3 + 4 算法使之复衡
            FromParentTo(*g) = rotateAt(talllerChild(talllerChild(g)));
            break; // g 复衡后, 局部子树高度必然复原, 其祖先也是如此
        } else {
            updateHeight(g); // 更新器高度 (未失衡但可能高度增加)
        }
    }
    return xx; // 返回新节点位置
} // 无论 e 是否存在于原树中, 总有 AVL::insert(e)->data == e
```
###### 效率
该算法使用 O(logn) 时间插入新节点 x, 使用 O(logn) 时间查找 g(x), 如果有必要再至多旋转两次复衡; 所以 AVL 树的节点插入操作可在 O(logn) 时间内完成

##### 节点删除
###### 失衡节点集
与插入操作不同, 在摘除节点 x 后, 以及随后的调整过程中, 失衡节点集 UT(x) 始终至多只含有一个节点; 若该节点 g(x) 存在, 其高度必与失衡前相同; 另外还有一点差异是, g(x) 有可能是 x 的父亲
###### 重平衡
与插入操作同理, 从 \_hot 节点触发沿 parent 指针上行, 经过 O(logn) 时间即可确定 g(x) 位置; 作为失衡节点 g(x), 在不包含 x 的一侧, 必有一个非空孩子 p, 且 p 的高度至少为 1; 于是, 可按如下规则从 p 的两个孩子 (其一可能为空) 中选出节点 v: 若两个孩子不等高, 则取 v 为其中更高者, 否则优先取 v 与 p 同向者  
不妨假定失衡后的 g(x) 的平衡因子为 +2 (为 -2 的情况完全对称); 可根据祖孙三代节点 g(x), p, v 的位置关系, 以 g(x) 或 p 为轴适当旋转, 同样可以使得这一局部恢复平衡
###### 单旋
T3 中删除了节点而致使 g(x) 不再平衡, 但 p 的平衡因子非负时, 通过以 g(x) 为轴顺时针旋转一次可恢复即部的平衡
```
              |               zig(g)                   |
          --- g ---            ===>             ------ p ------   
          |       |                             |             |
      --- p ---   T3                        --- v ---     --- g ---
      |       |                             |       |     |       |
  --- v ---   T2                           T0      T1    T2       T3
  |       |
 T0      T1
```
###### 双旋
g(x) 失衡时若 p 的平衡因子为 -1, 则经过以 p 为轴的一次逆时针旋转之后, 变为可单旋的情况, 接着再以 g(x) 为轴顺时针旋转, 可使之恢复平衡
```
            |          zag(p)            |               zig(g)                   |
        --- g ---       ===>         --- g ---            ===>             ------ p ------   
        |       |                    |       |                             |             |
    --- p ---   T3               --- p ---   T3                        --- v ---     --- g ---
    |       |                    |       |                             |       |     |       |
    T0  --- v ---            --- v ---   T2                           T0      T1    T2       T3
        |       |            |       |
        T1      T2          T0      T1
```
###### 失衡传播
与插入不同, 在删除该节点后, 尽管可以通过单旋或者双旋的调整使得局部子树恢复平衡; 但是恢复之后, 局部子树的高就全局而言仍然可能再次失衡; 设 g(x) 复衡后, 局部子树的高度的确降低, 此时若 g(x) 原本就属于某一更高祖先的更短分支, 删除节点复衡后由进一步缩短, 从而会导致祖先失衡; 这种由于底层失衡节点的重平衡而导致的高层祖先失衡的现象, 称作 "失衡传播"  
失衡传播必然自底而上, 而不会影响后代节点; 在复衡过程中的任一时刻, 至多只有一个失衡的节点: 高层的某一节点由平衡转为失衡, 只可能发生在下层节点恢复平衡之后; 因此可以沿 parent 指针逐层遍历祖先, 每找到一个失衡的祖先节点, 即可套用单旋或者双旋使之恢复平衡
###### 实现
```
// 从 AVL 树中删除关键码 e
template <typename T> bool AVL<T>::remove(const T& e) {
    BinNodePosi(T) & x = search(e);
    if (!x) return false; // 不存在则直接返回 false
    removeAt(x, _hot);
    _size--; // 按 BST 规则先删除
    for (BinNodePosi(T) g = _hot; g; g = g->parent) { // 从 _hot 出发逐层检查祖先 g
        if (!AvlBalanced(*g)) { // 一旦失衡, 则使用 3 + 4 算法使之复衡
            g = FromParentTo(*g) = rotateAt(talllerChild(talllerChild(g))); // 原父亲
        }
        updateHeight(g); // 更新其高度 (即便为失衡, 高度也有可能变化)
    }
    return true; // 删除成功
} // 若目标节点存在且被删除, 返回 true, 否则返回 false
```
###### 效率
需要重平衡的都是 x 的祖先, 故 AVL 树的节点删除操作总体时间复杂度为 O(logn)

#### 统一平衡算法
 上述重平衡方法, 需要根据失衡节点, 其孩子节点, 孙子节点的相对位置关系, 分别做单旋或这双旋调整, 但如此调整代码复杂, 以下引入一种更加简明的方法  
 无论对于插入或者删除操作, 也是需要从刚发生修改的位置 x 出发逆行而上, 直至遇到最低的失衡节点 g(x); 于是在 g(x) 更高一侧的子树内, 其孩子节点 p 和孙子节点 v 必然存在, 而且这一局部必然可以 g(x), p, v 为界, 分解为四颗子树, 按照中序遍历的次序重命名为 T0, T1, T2, T3; 同样按照中序遍历次序, 重新排列 g(x), p, v, 并将其重命名为 a, b, c; 则这一局部的中序遍历序列为: {T0, a, T1, b, T2, c, T3}; 这一局部等价于以下子树, 由于四颗子树的高度彼此相差不超过一层, 所以将这三个节点和四颗子树重新 "组装" 起来恰好是一颗 AVL 树
 ```
                     |
              ------ b ------
              |             |
          --- a ---     --- c ---
          |       |     |       |
          T0      T1    T2      T3
 ```
这一理解覆盖了前两节所有的单旋和双旋的情况, 相应的重构过程仅涉及局部的三个节点及其四颗子树, 故称 "3 + 4" 重构
```
/****************************************************************************
* 按照 "3 + 4" 结构联接 3 个节点及四棵子树, 返回重组之后的局部子树根节点位置 (即 b)
* 子树根节点与上层节点之间的双向联接, 均须由上层调用者完成
* 可用于 AVL 和 RedBlack 的局部平衡调整
*****************************************************************************
template <typename T> BinNodePosi(T) BST<T>::connect34 (BinNodePosi(T) a, BinNodePosi(T) b, BinNodePosi(T) c, BinNodePosi(T) T0, BinNodePosi(T) T1, BinNodePosi(T) T2, BinNodePosi(T) T3) {
    a->lc = T0; if (T0) T0->parent = a;
    a->rc = T1; if (T1) T1->parent = a; updateHeight(a);
    c->lc = T2; if (T2) T2->parent = c;
    c->rc = T3; if (T3) T3->parent = c; updateHeight(c);
    b->lc = a; a->parent = b;
    b->rc = c; c->parent = c;
    return b; // 返回该子树的根节点
}
```
利用以上 connect34() 算法, 视不同情况按如下具体方法完成重平衡
```
/************************************************************************
* BST 节点旋转变换统一算法 (3 节点 + 4 子树), 返回调整之后局部子树根节点的位置
* 注意: 尽管子树根会正确指向上层节点 (如果存在), 但反向的联接须由上层函数完成
*************************************************************************
template <typename T> BinNodePosi(T) BST<T>::rotateAt(BinNodePosi(T) v) { // v 为非空孙辈节点
    BinNodePosi(T) P = v->parent; // 视 v, p, g 的相对位置分四种情况
    BinNodePosi(T) g = p->parent;
    if (IsLChild(*p)) { // zig
        if (IsLChild(*v)) { // zig-zig
            p->parent = g->parent; // 向上联接
            return connect34(v, p, g, v->lc, v->rc, p->rc, g->rc);
        } else { // zig-zag
            v->parent = g->parent; // 向上联接
            return connect34(p, v, g, p->lc, v->lc, v->rc, g->rc);
        }
    } else { // zag
        if (IsRChild(*p)) { // zag-zag
            p->parent = g->parent; // 向上联接
            return connect34(g, p, v, g->lc, p->lc, v->lc, v->rc);
        } else { // zag-zig
            v->parent = g->parent; // 向上联接
            return connect34(g, v, p, g->lc, v->lc, v->rc, p->rc);
        }
    }
}
```
