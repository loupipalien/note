### 单元测试

#### TDD 三定律
- 在编写不能通过的单元测试前, 不可编写生成代码
- 只可编写刚好无法通过的单元测试, 不能编译也算不通过
- 只可编写刚好足以通过当前失败测试的生产代码

#### 保持测试整洁
测试代码和生成代码一样重要, 测试代码也需要被思考, 被设计和被照料, 应该像生产代码一般保持整洁

##### 测试带来一切好处
如果测试不能保持整洁, 就会失去它们; 没有了测试, 就会失去保证生产代码可扩展的一切要素; 正是单元测试让代码可扩展, 可维护, 可复用

#### 整洁的测试
整洁的测试有三个要素: 可读性, 可读性, 可读性; 在单元测试中可读性甚至比在生产代码中还重要, 在测试代码中做到明确, 简洁, 以及足够的表达力; 在测试中, 要以尽可能少的文字表达大量内容

##### 面项特定领域的测试语言
不直接使用程序员用来对系统进行操作的 API, 而是构建一套包装这些 API 的函数和工具代码, 这样就能更方便的编写测试代码, 写出来的测试也更便于阅读, 这正是一种测试语言

##### 双重标准
在某种意义上, 测试 API 中的代码与生产代码相比, 的确有一套不同的工程标准; 测试代码应当简单, 精悍, 具有表达力, 而且应该和生产代码一样有效; 但毕竟是在测试环境而非生产环境中运行, 有些事大概永远不会在生产环境中做, 而在测试环境中做却完全没问题; 这就是双重标准

#### 每一个测试一个断言
有流派认为, JUnit 中每个测试函数都应该有且只有一个断言语句, 其好处为可将测试都归结为一个可快速方便理解的结论; 单个断言是个好准则, 但是也接受多个断言同时存在也更便于测试; 最好的说法是单个测试中的断言数量应该最小化

##### 每个测试一个概念
减少断言数量, 每个测试只测试一个概念, 减少多个测试项混杂即减少测试工作量

#### F.I.R.S.T
整洁的测试还遵循以下 5 条规则
- 快速 (Fast): 测试应该足够快; 测试应该能快速的运行, 测试运行缓慢, 就不会想频繁的运行它; 如果不频繁的运行测试, 就不能尽早的发现问题, 也无法轻易修正, 从而也不能轻而易举的清理代码; 最终代码就会腐坏
- 独立 (Independent): 测试应该相互独立; 某个测试不应为下一个测试设定条件, 应该可以单独运行每个测试, 及以任何顺序运行测试; 当测试互相依赖时, 头一个没通过就会导致一连串的测试失败, 是问题诊断变得困难, 隐藏了下级错误
- 可重复 (Repeatable): 测试应当可在任何环境中重复通过; 应该能够在生产环境, 质检环境中运行测试, 也能够在无网络的列车上用笔记本电脑运行测试; 如果测试不能在任何环境中国重复, 就总会有个解释其失败的借口; 当环境条件不具备时, 也会无法运行测试
- 自足验证 (Self-Validating): 测试应该有布尔值输出; 无论通过或失败, 不应该查看日志文件来确认测试是否通过, 不应该手工比对两个不同文本文件来确认测试是否通过; 如果测试不能自足验证, 对失败的判断就会变得依赖主观, 而运行测试也需要更长的手工操作时间
- 及时 (Timely): 测试应即使编写; 单元测试应该恰好在使期通过的生产代码之前编写; 如果在编写生产代码之后编写测试, 会发现生产代码难以测试; 导致认为某些生成代码本身难以测试, 而不会去想如何设计可测试的代码

#### 小结
测试代码与生产代码同样重要
