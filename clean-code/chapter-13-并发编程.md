### 并发编程
编写整洁的并发程序很难

#### 为什么要并发
并发是一种解耦策略, 帮助把做什么 (目的) 和何时 (时机) 分解开, 解耦目的与时机能明显的改进应用程序的吞吐量和结构; 但并发编程很难, 很容易搞出不堪的代码; 以下是在编写并发程序时需要注意的几点
- 并发并非总能改进性能
并发有时能改进性能, 但只在多个线程和处理器之间能分享大量等待时间时有用
- 编写并发程序需要修改设计
并发算法的设计有可能与单线程系统的设计极不相同, 目的与时机的解耦往往对系统结构产生巨大的影响
- 有关编写并发软件的中肯说法
  - 并发会在性能和编写额外代码上增加一些开销
  - 正确的并发是复杂的, 即使对于简单的问题也是如此
  - 并发缺陷并非总能重现, 所以常被看作偶发事件被忽略, 未被当作真的缺陷来对待
  - 并发常常需要对设计策略进行根本性的修改

#### 挑战
```
public class X {
    private int lastUsed;
    public int getNextId() {
        return ++lastUsed;
    }
}
```
创建 X 的一个实体, 将 lastUsed 设置为 42, 在两个线程中共享这个实体, 假定都调用 getNextId 这个方法, 结果则可能有三种输出
- 线程一得到值 43, 线程二的得到值 44, lastUsed 为 44
- 线程一得到值 44, 线程二的得到值 43, lastUsed 为 44
- 线程一得到值 43, 线程二的得到值 43, lastUsed 为 43

第三种结果令人惊异, 当两个线程互相影响时就会出现类似情况, 这时因为线程在执行那行 Java 代码时有许多可能路径可行; 对于 getNextId 方法中执行的那两个线程有 12870 种不同的可能执行路径; 如果 lastUsed 的类型变为 long, 则可能路径的数量将增至 2704156 种; 当然多数路径能得到正确结果, 但问题是其中一些得不到正确结果

#### 并发防御原则

##### 单一权责原则
单一权责原则 (SRP) 认为, 方法/类/组件应当只有一个修改理由; 并发设计自身足够复杂到成为修改的理由, 所以也该从其他代码中分离出来
- 并发相关代码有自己的开发, 修改, 调优的生命周期
- 开发相关代码有自己要对付的挑战, 和非并发相关代码不同, 而且往往更为困难
- 即便没有周边应用程序增加负担, 写不好的并发代码可能出错的方式数量已经足具挑战性

##### 推论: 限制数据作用域
两个线程修改共享对象的同一字段时可能互相干扰, 导致未与预期的行为; 解决方法之一是使用 synchronized 关键字在代码中保护一块使用共享对象的临界区; 更新共享数据的地方越多就可能出现以下情况
- 忘记保护一个或多个临界区, 导致破坏了修改共享数据的代码
- 得多花力气保证一切都受到有效防护 (破坏了 DRY 原则)
- 很难找到错误源, 也很难判断错误源

##### 推论: 使用数据副本
避免共享数据的方法之一就是一开始就避免共享数据, 代码会大大减少导致错误的可能; 假使使用对象副本能避免代码同步执行, 则因避免了锁定而省下的价值有可能补偿得上额外的创建成本和垃圾收集开销

##### 推论: 线程应尽可能的独立
让每个线程在自己的世界中存在, 不与其他线程共享数据; 每个线程处理一个客户端请求, 从不共享的源头接纳所有请求数据, 存储为本地变量; 这样每个线程都像是 JVM 中唯一的线程, 没有同步的需要

#### 了解 Java 库
