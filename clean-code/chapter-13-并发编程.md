### 并发编程
编写整洁的并发程序很难

#### 为什么要并发
并发是一种解耦策略, 帮助把做什么 (目的) 和何时 (时机) 分解开, 解耦目的与时机能明显的改进应用程序的吞吐量和结构; 但并发编程很难, 很容易搞出不堪的代码; 以下是在编写并发程序时需要注意的几点
- 并发并非总能改进性能
并发有时能改进性能, 但只在多个线程和处理器之间能分享大量等待时间时有用
- 编写并发程序需要修改设计
并发算法的设计有可能与单线程系统的设计极不相同, 目的与时机的解耦往往对系统结构产生巨大的影响
- 有关编写并发软件的中肯说法
  - 并发会在性能和编写额外代码上增加一些开销
  - 正确的并发是复杂的, 即使对于简单的问题也是如此
  - 并发缺陷并非总能重现, 所以常被看作偶发事件被忽略, 未被当作真的缺陷来对待
  - 并发常常需要对设计策略进行根本性的修改

#### 挑战
```
public class X {
    private int lastUsed;
    public int getNextId() {
        return ++lastUsed;
    }
}
```
创建 X 的一个实体, 将 lastUsed 设置为 42, 在两个线程中共享这个实体, 假定都调用 getNextId 这个方法, 结果则可能有三种输出
- 线程一得到值 43, 线程二的得到值 44, lastUsed 为 44
- 线程一得到值 44, 线程二的得到值 43, lastUsed 为 44
- 线程一得到值 43, 线程二的得到值 43, lastUsed 为 43

第三种结果令人惊异, 当两个线程互相影响时就会出现类似情况, 这时因为线程在执行那行 Java 代码时有许多可能路径可行; 对于 getNextId 方法中执行的那两个线程有 12870 种不同的可能执行路径; 如果 lastUsed 的类型变为 long, 则可能路径的数量将增至 2704156 种; 当然多数路径能得到正确结果, 但问题是其中一些得不到正确结果

#### 并发防御原则

##### 单一权责原则
单一权责原则 (SRP) 认为, 方法/类/组件应当只有一个修改理由; 并发设计自身足够复杂到成为修改的理由, 所以也该从其他代码中分离出来
- 并发相关代码有自己的开发, 修改, 调优的生命周期
- 开发相关代码有自己要对付的挑战, 和非并发相关代码不同, 而且往往更为困难
- 即便没有周边应用程序增加负担, 写不好的并发代码可能出错的方式数量已经足具挑战性

##### 推论: 限制数据作用域
两个线程修改共享对象的同一字段时可能互相干扰, 导致未与预期的行为; 解决方法之一是使用 synchronized 关键字在代码中保护一块使用共享对象的临界区; 更新共享数据的地方越多就可能出现以下情况
- 忘记保护一个或多个临界区, 导致破坏了修改共享数据的代码
- 得多花力气保证一切都受到有效防护 (破坏了 DRY 原则)
- 很难找到错误源, 也很难判断错误源

##### 推论: 使用数据副本
避免共享数据的方法之一就是一开始就避免共享数据, 代码会大大减少导致错误的可能; 假使使用对象副本能避免代码同步执行, 则因避免了锁定而省下的价值有可能补偿得上额外的创建成本和垃圾收集开销

##### 推论: 线程应尽可能的独立
让每个线程在自己的世界中存在, 不与其他线程共享数据; 每个线程处理一个客户端请求, 从不共享的源头接纳所有请求数据, 存储为本地变量; 这样每个线程都像是 JVM 中唯一的线程, 没有同步的需要

#### 了解 Java 库
- 使用类库提供的线程安全群集
- 使用 executor 框架执行无关任务
- 尽可能使用非锁定解决方案
- 部分类并不是线程安全的

##### 线程安全群集
在 JDK 中 java.util.concurrent 包中的类对于多线程解决方案是安全的, 且执行良好; 例如在几乎所有情况下,ConcurrentHashMap 实现都比 HashMap 表现得好, 它还支持同步并发读写, 也拥有支持非线程安全的合成操作的方法; 建议阅读 java.util.concurrent, java.util,concurrent.atomic, java.util.concurrent.locks 包中的类, 以下是部分为支持高级并发设计的类

|类名|说明|
|--|--|
|ReentranctLock|可在一个方法中获取, 在另一个方法中释放的锁|
|Semaphore|经典的 "信号" 的一种实现, 有计数器的锁|
|CountDownLatch|在释放所有等待的线程之前, 等待指定数量事件发生的锁|

#### 了解执行模型
在并发应用中有几种切分行为的途径, 在讨论之前需了解以下基础定义

|基础概念|说明|
|--|--|
|限定资源|并发环境中有着固定尺寸或数量的资源, 例如数据库连接和固定尺寸的读写缓存等|
|互斥|每一时刻仅有一个线程能访问共享数据或共享资源|
|线程饥饿|一个或一组线程在很长时间内或永久的被禁止|
|死锁|两个或多个线程互相等待执行结束, 每个线程都拥有其他线程需要的资源, 得不到其他线程拥有的资源, 就无法终止|
|活锁|执行次序一致的线程, 每个都想要起步, 但发现其他线程已经 "在路上" 了; 由于竞步的原因, 线程会持续尝试起步, 但很在很长时间内都无法如愿, 甚至永远无法启动|

在实际中遇到的并发问题, 往往是以下三种的变种, 研究并使用这些算法为处理并发问题做好准备

##### 生产者 - 消费者模型
一个或多个生产线程创建某些工作, 并置于缓存或队列中; 一个或多个消费者线程从队列中获取并完成这些工作; 生产者和消费者之间的队列是一种限定资源

##### 读者 - 写者模型
当存在一个主要为读者线程提供信息源, 但只偶尔被写者线程更新的共享资源, 吞吐量就会是一个问题; 增加吞吐量会导致线程饥饿和过时信息的积累, 更新又会影响吞吐量; 协调读者线程, 不去读写者线程正在更新的信息, 是一种辛苦的平衡工作; 写者线程倾向于长期锁定许多读者线程, 从而导致吞吐量问题; 挑战之处在于平衡读写线程与写者线程的需求, 实现正确操作, 提供合理的吞吐量, 避免线程饥饿

##### 宴席哲学家
一群哲学家环坐在圆桌旁, 每个哲学家的左手边都放了一把叉子, 桌面中央摆着一大碗意大利面; 每个人都要拿起叉子吃饭, 但除非手上有两把叉子, 否则就无法进食; 如果左边或右边的哲学家已经用了一把叉子, 中间的哲学家就得等到别人吃完放回叉子; 每位哲学家吃完后将两把叉子放回桌面, 直到肚子再俄  
用线程代替哲学家, 用资源代替叉子, 就变成了应用中并发时线程竞争资源的问题; 这种竞争式系统会遭遇死锁, 活锁, 吞吐量和效率降低等问题, 需要用心设计

#### 警惕同步方法之间的依赖
