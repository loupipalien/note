### 并发编程
编写整洁的并发程序很难

#### 为什么要并发
并发是一种解耦策略, 帮助把做什么 (目的) 和何时 (时机) 分解开, 解耦目的与时机能明显的改进应用程序的吞吐量和结构; 但并发编程很难, 很容易搞出不堪的代码; 以下是在编写并发程序时需要注意的几点
- 并发并非总能改进性能
并发有时能改进性能, 但只在多个线程和处理器之间能分享大量等待时间时有用
- 编写并发程序需要修改设计
并发算法的设计有可能与单线程系统的设计极不相同, 目的与时机的解耦往往对系统结构产生巨大的影响
- 有关编写并发软件的中肯说法
  - 并发会在性能和编写额外代码上增加一些开销
  - 正确的并发是复杂的, 即使对于简单的问题也是如此
  - 并发缺陷并非总能重现, 所以常被看作偶发事件被忽略, 未被当作真的缺陷来对待
  - 并发常常需要对设计策略进行根本性的修改

#### 挑战
```
public class X {
    private int lastUsed;
    public int getNextId() {
        return ++lastUsed;
    }
}
```
创建 X 的一个实体, 将 lastUsed 设置为 42, 在两个线程中共享这个实体, 假定都调用 getNextId 这个方法, 结果则可能有三种输出
- 线程一得到值 43, 线程二的得到值 44, lastUsed 为 44
- 线程一得到值 44, 线程二的得到值 43, lastUsed 为 44
- 线程一得到值 43, 线程二的得到值 43, lastUsed 为 43

第三种结果令人惊异, 当两个线程互相影响时就会出现类似情况, 这时因为线程在执行那行 Java 代码时有许多可能路径可行; 对于 getNextId 方法中执行的那两个线程有 12870 种不同的可能执行路径; 如果 lastUsed 的类型变为 long, 则可能路径的数量将增至 2704156 种; 当然多数路径能得到正确结果, 但问题是其中一些得不到正确结果

#### 并发防御原则

##### 单一权责原则
单一权责原则 (SRP) 认为, 方法/类/组件应当只有一个修改理由; 并发设计自身足够复杂到成为修改的理由, 所以也该从其他代码中分离出来
- 并发相关代码有自己的开发, 修改, 调优的生命周期
- 开发相关代码有自己要对付的挑战, 和非并发相关代码不同, 而且往往更为困难
- 即便没有周边应用程序增加负担, 写不好的并发代码可能出错的方式数量已经足具挑战性

##### 推论: 限制数据作用域
两个线程修改共享对象的同一字段时可能互相干扰, 导致未与预期的行为; 解决方法之一是使用 synchronized 关键字在代码中保护一块使用共享对象的临界区; 更新共享数据的地方越多就可能出现以下情况
- 忘记保护一个或多个临界区, 导致破坏了修改共享数据的代码
- 得多花力气保证一切都受到有效防护 (破坏了 DRY 原则)
- 很难找到错误源, 也很难判断错误源

##### 推论: 使用数据副本
避免共享数据的方法之一就是一开始就避免共享数据, 代码会大大减少导致错误的可能; 假使使用对象副本能避免代码同步执行, 则因避免了锁定而省下的价值有可能补偿得上额外的创建成本和垃圾收集开销

##### 推论: 线程应尽可能的独立
让每个线程在自己的世界中存在, 不与其他线程共享数据; 每个线程处理一个客户端请求, 从不共享的源头接纳所有请求数据, 存储为本地变量; 这样每个线程都像是 JVM 中唯一的线程, 没有同步的需要

#### 了解 Java 库
- 使用类库提供的线程安全群集
- 使用 executor 框架执行无关任务
- 尽可能使用非锁定解决方案
- 部分类并不是线程安全的

##### 线程安全群集
在 JDK 中 java.util.concurrent 包中的类对于多线程解决方案是安全的, 且执行良好; 例如在几乎所有情况下,ConcurrentHashMap 实现都比 HashMap 表现得好, 它还支持同步并发读写, 也拥有支持非线程安全的合成操作的方法; 建议阅读 java.util.concurrent, java.util,concurrent.atomic, java.util.concurrent.locks 包中的类, 以下是部分为支持高级并发设计的类

|类名|说明|
|--|--|
|ReentranctLock|可在一个方法中获取, 在另一个方法中释放的锁|
|Semaphore|经典的 "信号" 的一种实现, 有计数器的锁|
|CountDownLatch|在释放所有等待的线程之前, 等待指定数量事件发生的锁|

#### 了解执行模型
在并发应用中有几种切分行为的途径, 在讨论之前需了解以下基础定义

|基础概念|说明|
|--|--|
|限定资源|并发环境中有着固定尺寸或数量的资源, 例如数据库连接和固定尺寸的读写缓存等|
|互斥|每一时刻仅有一个线程能访问共享数据或共享资源|
|线程饥饿|一个或一组线程在很长时间内或永久的被禁止|
|死锁|两个或多个线程互相等待执行结束, 每个线程都拥有其他线程需要的资源, 得不到其他线程拥有的资源, 就无法终止|
|活锁|执行次序一致的线程, 每个都想要起步, 但发现其他线程已经 "在路上" 了; 由于竞步的原因, 线程会持续尝试起步, 但很在很长时间内都无法如愿, 甚至永远无法启动|

在实际中遇到的并发问题, 往往是以下三种的变种, 研究并使用这些算法为处理并发问题做好准备

##### 生产者 - 消费者模型
一个或多个生产线程创建某些工作, 并置于缓存或队列中; 一个或多个消费者线程从队列中获取并完成这些工作; 生产者和消费者之间的队列是一种限定资源

##### 读者 - 写者模型
当存在一个主要为读者线程提供信息源, 但只偶尔被写者线程更新的共享资源, 吞吐量就会是一个问题; 增加吞吐量会导致线程饥饿和过时信息的积累, 更新又会影响吞吐量; 协调读者线程, 不去读写者线程正在更新的信息, 是一种辛苦的平衡工作; 写者线程倾向于长期锁定许多读者线程, 从而导致吞吐量问题; 挑战之处在于平衡读写线程与写者线程的需求, 实现正确操作, 提供合理的吞吐量, 避免线程饥饿

##### 宴席哲学家
一群哲学家环坐在圆桌旁, 每个哲学家的左手边都放了一把叉子, 桌面中央摆着一大碗意大利面; 每个人都要拿起叉子吃饭, 但除非手上有两把叉子, 否则就无法进食; 如果左边或右边的哲学家已经用了一把叉子, 中间的哲学家就得等到别人吃完放回叉子; 每位哲学家吃完后将两把叉子放回桌面, 直到肚子再俄  
用线程代替哲学家, 用资源代替叉子, 就变成了应用中并发时线程竞争资源的问题; 这种竞争式系统会遭遇死锁, 活锁, 吞吐量和效率降低等问题, 需要用心设计

#### 警惕同步方法之间的依赖
同步方法之间的依赖会导致并发代码中的狡猾依赖; Java 语言中有 synchronized 关键字, 可以用来保护单个方法; 但如果在同一共享类中有多个同步方法, 系统就可能写的不太正确了; 应尽量避免使用一个共享对象的多个方法, 如果必须使用则考虑以下三种方式
- 基于客户端的锁定: 客户端代码在调用第一方法锁定服务端, 确保所的范围覆盖了调用最后一个方法的代码
- 基于服务端的锁定: 在服务端内创建锁定服务端的方法, 调用所有方法, 然后解锁： 让客户端代码调用新的方法
- 适配服务端: 创建执行锁定的中间层, 这是一种基于服务端锁定的例子, 但不修改原始服务端代码

#### 保持同步区域微小
关键字 synchronized 制造了锁, 同一个锁维护的所有代码区域在任一时刻保证只有一个线程执行; 锁是昂贵的, 因为带来了延迟和额外开销, 而另一方面, 临界区应该被保护起来; 所以应该尽可能少的设计临界区, 当同步延展到最小临界区范围之外, 会增加资源争用, 降低执行效率

#### 很难编写正确的关闭代码
编写永远运行的系统与编写运行一段时间后平静关闭的系统是两码事; 平静关闭很难做到, 常见问题与死锁有关, 线程一直等待永远不会到来的信号; 例如, 一个系统中父线程分裂出数个子线程, 父进程等待所有子线程结束, 然后释放资源关闭, 如果其中一个子线程发生死锁, 则父线程则一直等待下去, 系统就不能正确关闭; 所以尽可能的考虑关闭问题, 尽早令其正常工作

#### 测试线程代码
证明代码的正确性不切实际, 测试并不能确保正确性, 但好的测试能尽量降低风险, 这对于所有单线程解决方案都是正确的; 当有两个或多个线程使用同一代码段和共享数据, 测试就变得复杂了, 以下是一些精炼的建议
- 将伪失败看作可能的线程问题
- 先使非线程代码可工作
- 编写可插拔的线程代码
- 编写可调整的线程代码
- 运行多余处理器处理的线程
- 在不同平台上运行
- 调整代码并强迫错误发生

##### 将伪失败看作可能的线程问题
线程代码中的缺陷可能在一千次或一百万次执行中才会显现出一次, 重复执行想要复现的问题令人沮丧, 所以最好假设这种偶发事件归于系统错误; 如果偶发事件被忽略的越久, 代码就越有可能搭建于不完善的基础之上

##### 先使非线程代码可工作
确保线程之外的代码可工作, 不要同时追踪非线程缺陷和线程缺陷

##### 编写可插拔的线程代码
编写可在数个配置环境下运行的线程代码
- 单线程与多线程在执行时不同的情况
- 线程代码与实物或测试替身互动
- 用运行快速, 缓慢, 变动的测试替身执行
- 将测试配置为能运行一定数量的迭代

##### 编写可调整的线程代码
要获得良好的线程平衡需要试错; 一开始就在不同配置环境下监测系统性能, 要允许线程数量可调整, 在系统运行时允许线程发生变动, 允许线程依据吞吐量和系统使用率自我调整

##### 运行多于处理器数量的线程
系统在切换任务时会发生一些事情; 为了促使任务交换的发生, 运行多于处理器或处理器核心数量的线程, 任务交换的越频繁, 越有可能找到错过临界区或导致死锁的代码

##### 在不同平台上运行
在不同系统环境中, 多线程代码的行为也不一样

##### 装置试错代码
并发代码中的缺陷往往很难暴露, 常常隐藏在一般处理过程中难以复现; 为了抓到导致 BUG 的代码, 可以装置代码, 增加对 Object.wait(), Object.sleep(), Object.yield(), Object.priority() 等方法的调用, 改变代码的执行顺序; 增加可侦测到缺陷的可能性, 有问题的代码最好尽早的通不过测试; 装置代码的方法通常有两种: 硬编码和自动化

##### 硬编码
手工向代码中插入 wait(), sleep(), yield() 和 priority() 的调用
```
public sychronized String nextUrlOrNull() {
    if(hasNext()) {
        String url = urlGenerator.next();
        Thread.yield(); // inserted for testing
        updateHasNext();
        return url;
    }
    return null
}
```
插入 yield() 的调用将改变代码路径, 由此可能导致之前未遇到的失败; 如果代码出错那么并非是插入了 yield() 导致的, 而是真正的原因; 这种方法有许多毛病
- 得手工找到合适的地方来插入对方法的调用
- 知道在那里插入调用, 插入什么调用
- 不必要在生产环境留下这些代码, 会拖慢代码执行速度
- 这是一种无的放矢的手段, 你也可能找不到缺陷


##### 自动化
可以使用 Aspect-Oriented Framework, CGLIB 或 ASM 之类工具通过编程来装置代码
```
public class ThreadJigglePoint {
    public static void jiggle() {}
}

public sychronized String nextUrlOrNull() {
    if(hasNext()) {
        ThreadJigglePoint.jiggle();
        String url = urlGenerator.next();
        ThreadJigglePoint.jiggle();
        updateHasNext();
        ThreadJigglePoint.jiggle();
        return url;
    }
    return null
}
```  
ThreadJigglePoint 类有两种实现, 第一种什么都不做, 在生成环境中使用; 第二种实现生成一个随机数, 在睡眠, 让步, 径直执行间做选择

#### 小结
并发代码很难写正确, 加入多线程和共享数据之后, 简单的代码也会变成噩梦; 要编写并发代码, 就得严格编写整洁的代码, 否则将面临微细和不频繁发生的失败
