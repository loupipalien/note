## 引论
### 目录    
- [1.1 本书讨论的内容](#11-本书讨论的内容)
- [1.2 数学知识复习](#12-数学知识复习)
  - [1.2.1 指数](#121-指数)
  - [1.2.2 对数](#122-对数)
  - [1.2.3 级数](#123-级数)
  - [1.2.4 模运算](#124-模运算)
  - [1.2.5 证明方法](#125-证明方法)
- [1.3 递归简论](#13-递归简论)

### 1.1 本书讨论的内容
写出一个可以工作的程序并不够。在输入的数据集巨大时,如何估计程序运行的时间,尤其是如何在尚未具体编码的情况下比较两个程序的运行时间,以及如何确定程序运行瓶颈和彻底改进程序运行速度。

### 1.2 数学知识复习
#### 1.2.1 指数
$$ X^AX^B = X^{A+B} $$
$$ \frac{X^A}{X^B} = X^{A-B} $$
$$ (X^A)^B = X^{AB} $$
$$ X^N + X^N =2X^N \neq X^{2N} $$
$$ 2^N + 2^N = 2^{N+1} $$

#### 1.2.2 对数
在计算机科学中(除非有特别声明),所有的对数都是以2为底的  
$$ \log_AB = \frac{\log_CB}{\log_CA} $$
**证明:**  
令$ X = \log_CB, Y = \log_CA, Z = \log_AB $ 。由对数定义可得:$ C^X = B, C^Y = A, A^Z = B $, 联合三个等式则有: $ (C^Y)^Z = C^X = B $ 。因此,$ Z = \frac{X}{Y} , \log_AB = \frac{\log_CA}{\log_CB} $ 得证 。
$$ \log AB = \log A + \log B $$
$$ \log \frac{A}{B} = \log A - \log B $$
$$ \log (A^B) = B\log A $$
$$ \log X < X (对于所有的X > 0 都成立) $$
$$ \log 1 = 0, \log 2 = 1, \log 1024 = 10, \log 1048576 = 20 $$

#### 1.2.3 级数
$$ \sum_{i=0}^NA^i = \frac{A^{N+1} - 1}{A - 1} $$
此为几何级数(即表示等比数列的前N项和, 又称等比级数)。如果 0 < A < 1, 则有 $ \sum_{i=0}^NA^i = \frac{1}{1 - A} $ , 当N趋近于 $ \infty $ 时该和趋向于 $ \frac{1}{1 - A} $
$$ \sum_{i=1}^Ni = \frac{N(N + 1)}{2} $$
此为算术级数(即表示等差数列的前N项和, 又称等差级数)
$$ \sum_{i=1}^Ni^2 = \frac{N(N + 1)(N + 2)}{6} \approx \frac{N^3}{3} $$
$$ \sum_{i=1}^Ni^k = \frac{N^{k+1}}{\mid k + 1 \mid} \quad, k \neq -1$$
当 k = -1 时, 后一个公式不成立。此时需要下面的公式, 此公式在计算机科学中的使用要远比在数学等其他学科中使用得多。
$$ H_N = \sum_{i=1}^N\frac{1}{i} \approx \log_eN $$
此为调和级数。上近似式误差趋向于 $ \gamma \approx 0.57721566 $ ,这个值称为[欧拉常数](https://baike.baidu.com/item/%E6%AC%A7%E6%8B%89%E5%B8%B8%E6%95%B0)

#### 1.2.4 模运算
如果N整除A-B,那么就说A与B模N同余,记为 $ A \equiv B (mod \; N) $ 。即意味着无论是A还是B被N去除,所得余数都是相同的。于是, $ 81 \equiv 61 (mod \; 10) $ 。如同等号的情形一样, 若 $ A \equiv B (mod \; N)$ , 则有 $ A + C \equiv B + C (mod \; N) , AD \equiv BD (mod \; N) $

#### 1.2.5 证明方法
**归纳法:**  
**反证法:**  

### 1.3 递归简论
**四条基本准则**
- 基准情形: 必须总有些基准情形,即无须递归就能解出
- 不断推进: 对于那些需要递归求解的情形,每一次递归调用都必须要使求解状况朝着基准情形的方向进行
- 设计法则: 假设所有的递归调用都能运行
- 合成效益法则: 在求解一个问题的同一实例时,切勿在不同的递归调用中做重复性的工作
