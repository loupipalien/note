### 聚合数据模型
本书中的数据模型通常表示数据库组织数据的方式, 它的正式名称是 "元数据" (metamodel)  
NoSQL 技术与传统的关系数据库相比, 一个最明显的转变就是抛弃了关系模型; 每种 NoSQL 解决方案的模型都不同, 本书把 NoSQL 生态系统中广泛使用的模型分为四类: "键值", "文档", "列族", "图"; 前三类数据模型有一个共同特征, 称其为 "面向聚合" (aggregate orientation)

#### 聚合
关系模型把待存储的信息分隔成元组 (行); 元组是种受限的数据结构: 它只能包含一系列的值, 因此不能在元组中嵌套另一个元组, 也不能包含由值或元组所组成的列表; 这种简单的数据结构支撑着关系模型: 所有的操作都必须以元组为目标, 而且其返回值也必须是元组  
面向聚合所用的方式与之不同, 通常操作数据时所用的单元, 其结构都比元组集合复杂的多, 能够用这种复杂的结构来存放列表或嵌套其他记录结构本书中称之为 "聚合" (aggregate)  

##### 关系模型与聚合模型示例
TODO
##### 面向聚合的影响
虽然关系映射能够很好的捕捉各种数据元素及其关系, 但是它却没有 "聚合实体" (aggregate entity) 这一概念; 在领域语言 (domain language) 中, 可以说订单由订单项, 收货地址, 付款信息组成; 在关系模型中, 可以使用外键 (foreign key) 来表达这种关系, 但是那样做无法区分某个关系是否表示聚合; 因此数据库无法使用聚合结构来帮助其存储和分布数据  
多种数据建模都提供了其标记聚合 (aggregate) 结构或组合 (composite) 结构的方式; 然而问题是, 建模者很少会提供一种语义 (sematic) 来描述各类聚合关系之间的区别; 就算提供了这些建模技术所用的语义也各不相同; 如果使用面向聚合的数据库, 那么通过考虑与数据存储交互时所用的单位, 就能得出一种更为清晰的语义; 然而它并不是数据的逻辑属性, 只是描述了应用程序使用数据的方式, 而这一事项通常不属于数据建模的范畴  
关系型数据库的数据模型中, 没有 "聚合" 这一概念, 因此称之为 "聚合无知" (aggregate-ignorant); NoSQL 领域中的 "图数据库" 也是聚合无知的; 这一特征并不是坏事, 聚合的边界一般都很难正确划分出来, 当不同场景要使用同一份数据时更是如此  
对于某些数据交互有用的数据结构, 可能会阻碍另一些数据交互, 若是采用 "聚合无知模型", 那么很容易就能以不同的方式来查看数据, 因此在操作数据时, 如果没有一种占主导地位的结构, 那么选用此模型效果会更好   
选用面向聚合模型的决定性因素, 就在于它非常适合在集群上运行, 在集群上运行时, 需要把采集数据时所需节点数降至最小, 如果在数据库中明确包含了聚合结构, 那么它就可以根据这一重要信息, 知道哪些数据需要一起操作了, 而且这些数据应该放在同一个节点中  
关系型数据库允许把任意表格中的任意行组结合起来, 放在一个事务中操作, 这种事务就叫 "ACID 事务", 它可以保证在单一操作中更新跨越来越多张表的数个行, 该操作要么完全成功, 要么彻底失败, 而且并发执行的多个操作之间是彼此隔离的, 它们不可能看到某个尚未全部完成的更新操作  
NoSQL 数据库通常情况下, 面向聚合的数据库确实不支持跨越多个聚合的 ACID 事务, 取而代之的是它每次只能在一个聚合结构上执行原子操作, 也就是说想以原子方式操作多个聚合, 那么就必须自己组织应用程序的代码; 所以在实际应用中, 大多数原子操作都可以局限于某个聚合结构内部, 而且在将数据划分为聚合时, 这也是要考虑的因素之一; 图数据库和其他一些 "聚合无知式数据库" 都支持与关系型数据库类似的 ACID 操作

#### 键值数据模型与文档数据模型
键值数据库和文档数据库都特别面向聚合, 数据库主要是通过聚合来构建的, 这两类数据库都包含大量聚合, 每个聚合中都有一个获取数据所用鞥带 ID; 这两种模型的区别是: 键值数据库的聚合不透明 (指某个数据结构不需要知道其内部实现细节即可为外部程序使用), 只包含一些没有太多意义的大块信息; 与此相反, 在文档数据库的聚合中, 可以看到其结构, 不透明的优势在于聚合中可以存储任意数据, 数据库可能会限制聚合的总大小, 而文档数据库则要限制其中存放的内容, 它定义了其允许的结构和数据类型, 而这样做的好处是能够更加灵活的限制访问数据  
在键值数据库中, 要访问聚合内容, 只能通过键来查找; 而使用文档数据库时, 则可以用聚合中的字段查询, 可以只获取一部分聚合, 而不用获取全部内容, 此外数据库还可以按照聚合内容创建索引

#### 列族存储
大部分数据库都以行为单元存储数据, 尤其是在需要提高写入性能的场合更是如此, 然而有些情况下写入操作执行的很少, 但是经常需要一次读取若干行中的很多列, 在这种情况下, 将所有行的某一组列作为基本数据存储单元, 效果会更好; "列存储数据库" 一词正是由此得名  
理解列族模型的最好方式也许就是将其视为两级聚合结构 (two-level aggregate structure), 与 "键值存储" 相同, 第一个键通常代表行标识符, 可以用它来获取想要的聚合; 列族结构与 "键值存储" 的区别在于其  "行聚合" (row aggregate) 本身又是一个映射, 其中包含一些更为详细的值, 这些 "二级值" (second-level value) 就叫做 "列"; 与整体访问某行数据一样, 也可以操作特定的列; 因此可以用 `get('1234', 'name')` 可以获取图中客户的名字  
![以列族结构表示客户信息.png](http://ww1.sinaimg.cn/large/d8f31fa4gy1g8l6bqmtcsj20g30alwf6.jpg)   
列族数据将列组织成列族, 每一列必须是某个列族的一部分, 而且访问数据的单元也得是列, 这样设计的前提是, 某个列族中的数据经常需要一起访问; 于是有两种数据组织方式
- 面向行 (row-oriented): 每一行都是一个聚合 (例如 ID 为 1234 的顾客就是一个聚合), 该聚合内部存有一些包含有数据块 (客户信息, 订单记录) 的列族
- 面向列 (column-oriented): 每个列族都定义了一种记录类型 (例如客户信息), 其中每行都表示一条记录; 可以将数据库中大 "行" 理解为列族中每个短行记录的串接  

Cassandra 有 "宽", "瘦" 两个术语, 瘦行的列不多, 但是很多行都会出现相同的列, 在这种情况下, 列族定义了一种记录类型, 每行都是一条记录, 没一列都是一个字段; 而 "宽行" 则有很多列, 然而各个行中的列差别很大, 宽列族模型反映了一个列表, 其中每列都是列表中的一个元素  
虽然将列族根据器性质区分为 "宽", "瘦" 两类比较有用, 然而从技术角度来讲, 列族也不是不能同时包含 "字段式的列" 与 "列表式的列", 只是这样会给排序带来麻烦

#### 面向聚合数据库总结
三种不同风格面向聚合数据模型的共同点是都使用了聚合这一概念, 而且聚合中都有一个可以查找器内容的索引键, 在集群上运行时聚合是中心环节, 因为数据库必须保证将聚合内的数据存放在同一个节点上, 聚合还是更新操作的最小数据单位, 对事务控制来说, 以聚合为操作单元其大小正合适  
在聚合的概念下, 三者之间还是有一些差别; 键值数据模型将聚合看作不透明度的整体, 这意味只能根据键来查出整个聚合, 而不能仅仅值查询其中的一部分; 文档数据模型的聚合对数据库透明, 可以只查询并获取其中一部分数据, 由于文档没有模式, 因此在想优化才能出并获取聚合中的部分内容时, 数据库不太好调整文档结构; 列族数据模型把聚合分为列族, 让数据库将其视为行聚合内的一个数据单元, 此类聚合的结构有某种限制, 但是数据库可利用这一优点来提高其易访问性
#### 延伸阅读
TODO
#### 要点
TODO
