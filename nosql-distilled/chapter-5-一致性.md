### 一致性

#### 更新一致性
在并发环境模式下维护数据一致性所用的方式, 通常分为悲观方式和乐观方式; 悲观方式就是避免发生冲突, 而乐观方式则是先让冲突发生, 然后检测冲突并对发生冲突的操作排序; 在处理更新冲突时, 最常见的悲观方式就是采用写入锁, 这样的话在修改某个值之前, 必须先获得写入锁, 系统确保某一时刻只有一个客户能够获得这把锁; 乐观方式通常采用条件更新, 也就是任意客户在执行更新操作之前, 都要先测试数据的当前值和其上一次读入的值是否相同  
以上悲观和乐观的方式, 都有一个先决条件, 那就是更新操作的顺序必须一致; 在分布式系统的并发问题中, 说的顺序一致性 (sequential consistency), 也就是所有节点都要保证以相同次序执行操作

#### 读取一致性
有一个能够保持更新一致性的数据库, 只是解决了一方面的问题, 它未必能保证客户端所提交的访问请求总是能得到内容一致的响应; 当顺序更新两个有关联的聚合数据时, 由其他客户端在两个更新中间读取了这两个聚合那么就会导致逻辑不一致性, 这是由于读写冲突导致的; 面向聚合的数据库通常只支持单一聚合的原子更新, 但各个聚合的更新不能如关系数据库一样有事务保证; 在执行影响多个聚合的更新操作时的中间空当, 有可能让客户端读出逻辑不一致的数据, 存在不一致风险的时间长度称之为不一致窗口 (inconsistency window)

#### 放宽 "一致性" 约束
一致性是个好东西, 不过有时必须舍弃它, 在设计系统时, 总是尽可能避免 "不一致" 现象, 但要正真做到这一点, 通常需要放弃系统中的一些其他特性, 而那些特性却是必不可少的

##### CAP 定理
CAP 定理的基本表述是: 给定一致性 (Consistency), 可用性 (Availability), 分区容错性 (Partition tolerance) 这三个属性, 只能同时满足其中两个属性

#### 放宽 "持久性" 约束
TODO

#### 仲裁
TODO

#### 延伸阅读
TODO

#### 要点
- 当两个客户端试图同时修改一份数据时, 会发生 "写入冲突"; 而当客户端在另一个客户端执行写入操作的过程中读取数据, 则会发生 "读写冲突"
- 悲观方式以锁定数据记录来避免冲突, 而乐观方式则在事后检测冲突并将其修复
- 在分布式系统中, 如果某些节点收到了更新数据, 而另外一些节点却尚未收到, 那么这种情况就视为 "读写冲突", 若写入操作已经传播到所有节点, 则此刻的数据库就具备 "最终一致性"
- 客户端通常希望具备 "照原样读出所写内容" 的一致性, 也就是说客户端在执行万写入操作后, 要能够立刻看到新值; 如果读取写入操作分别发生在不同节点, 那么想保证这一点会比较困难
- 想取得较好的 "一致性", 就要用许多节点来执行数据操作, 而这又会增大延迟; 所以经常需要在一致性和延迟之间权衡
- 由 CAP 定理可知, 当出现网络分区现象时, 必须在数据的可用性和一致性之间权衡
- 可以舍弃一部分持久性以减少延迟, 如果想让数据库在复制数据出错的情况下依然可用, 那么更应该考虑这种权衡方式
- 在采用复制技术的分布式模型中执行数据操作时, 无需联系所有副本, 只要有足够多的副本所认可, 就能保持强一致性了 
