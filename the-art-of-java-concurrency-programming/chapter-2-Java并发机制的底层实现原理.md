### Java 并发机制的底层实现原理
Java 中使用的并发机制依赖于 JVM 的实现和 CPU 的指令

#### volatile 的应用
volatile 是轻量级的 synchronized, 它在多处理器开发中保证了共享变量的 "可见性"; 可见性意味着当一个线程修改一个共享变量时, 另一个线程也能读到这个修改的值, 如果 volatile 变量修饰符使用恰当的话, 比 synchronized 的使用和执行成本更低, 因为它不会引起线程上下文的切换和调度

##### volatile 的定义和实现原理
Java 语言规范第 3 版中对 volatile 的定义如下: Java 编程语言允许线程访问共享变量, 为了确保共享变量能被准确和一致的更新, 线程应该确保通过排他锁单独获得这个变量; Java 语言提供了 volatile, 在某些情况下比锁更要方便, 如果一个字段被声明为了 volatile, Java 线程内存模型确保所有线程看到这个变量的值是一致的; 以下是实现原理相关的 CPU 术语与说明

| 术语 | 英文单词 | 描述 |
| :------------- | :------------- | :------------- |
| 内存屏障 | memory barriers | 是一组处理器命令, 用于实现对内存操作的顺序限制 |
| 缓冲行 | cache line | CPU 高速缓存中可以被分配的最小单位, 处理器在填写缓冲行时会加载整个缓冲行, 现代 CPU 需要执行几百次 CPU 指令 |
| 原子操作 | atomic operations | 不可中断的一个或一系列操作 |
| 缓冲行填充 | cache line fill | 当处理器识别到从内存中读取操作数是可缓存的, 处理器读取整个高速缓存行到适当的缓存 (L1, L2, L3 的或者所有) |
| 缓存命中 | cache hit | 如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时, 处理器从缓存中读取操作数, 而不是从内存中读取 |
| 写命中 | write hit | 当处理器将操作数写回到一个内存缓存的区域时, 它首先会检查这个缓存的内存地址是否在缓存行中, 如果存在一个有效的缓存行, 则处理器将这个操作数写回到缓存中, 而不是写回到内存中, 这个操作被称为写命中 |
| 写缺失 | write misses the cache | 一个有效的缓存行被写入不存在的内存区域 |

查看 JIT 编译器生成的汇编指令, 在对 volatile 声明的变量进行写操作时, CPU 做以下事情
```
// Java 代码
volatile instance = new Singleton();
// 汇编代码
0x01a3de1d: movb $0*0, 0*1104800(%esi); 0x01a3de24: lock addl $0*0, (%esp);
```
有 volatile 变量修饰的共享变量进行写操作的时候会多出第二行汇编代码, 通过 IA-32 架构手册可以, Lock 前缀的指令在多核处理器下会引发两件事情
- 将当前处理器缓存行的数据写回到系统内存
- 这个写回内存的操作会使在其他 CPU 缓存了该内存地址的数据无效
为了提高处理速度, 处理器不直接和内存进行通信, 而是先将系统内存的数据读到内存缓存 (L1, L2 或其他) 后再进行操作, 但操作不知道何时会写到内存; 如果对声明了 volatile 的变量进行写操作, JVM 就会向处理器发送一条 Lock 前缀的指令, 将这个变量在缓存行的数据写回到系统内存; 但是就算写回到系统内存, 如果其他处理器缓存的值还是旧的, 再执行计算操作就会有问题; 所以在多处理器下, 为了保证各个处理器的缓存是一致的, 就会实现缓存一致性协议, 每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了, 当处理器发现自己缓存行对应的内存地址被修改, 就会将当前处理器的缓存行设置成无效状态, 当处理器对这个数据进行修改操作的时候, 会重新从系统内存中把数据读到处理器缓存中

##### volatile 的使用优化
TODO

#### synchronized 的实现原理与应用
在多线程并发编程中 synchronized 一直是被认为是重量级锁, 随着 JDK 6 对 synchronized 进行了优化之后, 有些情况下它并没有那么重了; synchronized 实现同步的基础是 Java 中的每一个对象都可以作为锁, 具体表现为以下三种形式
- 对于普通同步方法, 锁是当前实例对象
- 对于静态同步方法, 锁是当前类的 Class 对象
- 对于同步方法块, 锁是 synchronized 括号里配置的对象

当一个线程试图访问同步代码块时, 它首先必须得到锁, 退出或者抛出异常时必须释放锁; JVM 基于进入和退出 Monitor 对象来实现方法同步和代码块同步, 但两者的实现细节不一样; 代码块同步是使用 monitorenter 和 monitorexit 指令实现的, 而 JVM 规范中并没有说方法同步是如何实现的, 但是也可以使用这两个指令实现; monitorenter 指令是在编译后插入到同步代码块的开始位置, 而 monitorexit 是插入到到方法结束处和异常处, JVM 要保证每个 monitorenter 必须有对应的 monitorexit 与之配对, 任何对象都有一个 monitor 与之关联, 当且一个 monitor 被持有后, 它将处于锁定状态; 线程执行到 monitorenter 指令时, 将会尝试获取对象对应的 monitor 的所有权, 即尝试获得对象的锁

##### Java 对象头
synchronized 用的锁是存在 Java 对象头里的, 如果对象是数组类型, 则虚拟机用 3 个字宽存储对象头, 如果对象是非数组类型, 则用 2 个字宽存储对象头; 在 32 位机中 1 字宽等于 8 bit, 即 32 bit

| 长度 | 内容 | 说明 |
| :------------- | :------------- |:------------- |
| 32/64bit | Mark Word | 存储对象的 hashCode 或锁信息等 |
| 32/64bit | Class Metadata Address | 存储到对象类型数据的指针 |
| 32/64bit | Array Length | 数组的长度(如果当前对象是数组) |

Java 对象头里的 Mark Word 里默认存储对象的 HashCode, 分代年龄, 锁标记位; 32 位 JVM 的 Mark Word 的默认存储结构如下表

| 锁状态 | 25 bit | 4 bit | 1 bit 是否是偏向锁 | 2 bit 锁标志位 |
| :------------- | :------------- |:------------- |:------------- |:------------- |
| 无锁状态 | 对象的 hashCode | 对象分代年龄 | 0 | 01 |

在运行期间, Mark Word 里存储的数据会随着锁标志位的变化而变化, Mark Word 可能变化为存储以下 4 种数据

| 锁状态 | 25 bit (23bit + 2 bit) | 4 bit | 1 bit 是否是偏向锁 | 2 bit 锁标志位 |
| :------------- | :------------- | :------------- | :------------- | :------------- |
| 轻量级锁 | 指向栈中锁记录的指针 |-|-|00|
| 轻量级锁 | 指向互斥量 (重量级锁) 的指针 |-|-|10|
| GC 标记 | 空 |-|-|11|
| 偏向锁 | 线程 ID | Epoch + 对象分代年龄 |1|11|

在 64 虚拟机下, Mark Word 是 64 位的

| 锁状态 | 25 bit | 31 bit | 1 bit (cms_free) | 4 bit (分代年龄) | 1 bit (偏向锁) | 2 bit (锁标志位) |
| :------------- | :------------- |:------------- |:------------- |:------------- |:------------- |:------------- |
| 无锁 | unuse | hashCode | - | - |0 | 01 |
| 偏向锁 | ThreadID(54 bit) + Epoch (2bit) | - | - | - |0 | 01 |

##### 锁的升级和对比
JDK 6 为了减少获得锁和释放锁带来的性能消耗, 引入了 "偏向锁" 和 "轻量级锁", 锁一共有 4 种状态, 级别从低到高依次是: 无锁状态, 偏向锁状态, 轻量级锁状态, 重量级锁状态, 这几个状态会随着竞争情况逐渐升级, 锁可以升级但不能降级, 意味着偏向锁升级为轻量级锁后不能反向降级为偏向锁; 这种锁升级但不能降级的策略, 是为了提高获得锁和释放锁的效率
###### 偏向锁
在大多数情况下, 锁不仅不存在多线程竞争, 而且总是又同一线程多次获得, 为了让线程获得锁的代价更低而引入了偏向锁, 当一个线程访问同步块并获取锁时, 会在对象头和栈帧中的锁记录里存储锁偏向的线程 ID, 以后该线程在进入和退出同步块时不需要进行 CAS 操作来加锁和解锁, 只需简单的测试以下对象头的 Mark Word 里是否存储着指向当前线程的偏向锁; 如果测试成功, 表示线程已经获得了锁, 如果测试失败, 则需要再测试一下 Mark Word 中偏向锁的标识是否设置成 1 (表示是偏向锁): 如果没有设置, 则使用 CAS 竞争锁, 如果设置了则尝试使用 CAS 将对象头的偏向锁指向当前线程
- 偏向锁的撤销
偏向锁使用了一种等到竞争出现才释放锁的机制, 所以当其他线程尝试竞争偏向锁时, 持有偏向锁的线程才会释放锁; 偏向锁的撤销需要等待全局安全点 (在这个时间点上没有执行的字节码); 它首先暂停拥有偏向锁的线程, 然后检查持有偏向锁的线程是否还活着, 如果线程不处于活动状态, 则将对象头设置成无锁状态; 如果线程还或者, 拥有偏向锁的栈会被执行, 遍历偏向对象的锁记录, 栈中的锁记录和对象头的 Mark Word 要么重新偏向于其他线程, 要么恢复到无锁或者标记对象不适合作为偏向锁, 最后唤醒暂停的线程
-  关闭偏向锁
偏向锁在 JDK 6 和 7 中是默认开启的, 但是它在应用程序启动后几秒钟才会被激活, 可以使用 -XX: BiasedLockingStartupDelay = 0 关闭延迟, 如果确定应用程序里所有的通常情况下处于竞争状态, 可以通过参数 -XX: -UseBiasedLocking = false 关闭, 这样 JVM 默认会使用轻量级锁

###### 轻量级锁
- 轻量级锁加锁
线程在执行同步块之前, JVM 会先在当前线程的栈帧中创建用于存储所记录的空间, 并将对象头中的 Mark Word 复制到锁记录中, 称为 Displace Mark Word; 然后线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针; 如果成功, 当前线程获得锁, 如果失败, 表示其他线程竞争锁, 当前线程便尝试使用自旋来获取锁
- 轻量级锁解锁
轻量级锁解锁时会使用原子的 CAS 操作将 Displace Mark Word 替换回原来的对象头, 如果成功则表示没有竞争发生; 如果失败则表示当前锁存在竞争, 锁就会膨胀为重量级锁; 因为自旋会消耗 CPU, 为了避免无用的自旋 (例如获取锁的线程被阻塞住了), 一旦锁升级为重量级锁, 就不会再恢复到轻量级锁状态; 当锁处于这个状态下时, 其他线程试图获取锁时就会被阻塞住, 当持有锁的线程释放锁之后会唤醒这些线程进行新一轮的锁争夺

###### 锁的优缺点对比

| 锁 | 优点 | 缺点 | 适用场景 |
| :------------- | :------------- |:------------- |:------------- |
| 偏向锁 | 加锁和解锁不需要额外的消耗, 和执行非同步方法相比仅有纳秒级的差距 | 如果线程间存在锁竞争, 会带来额外的锁撤销的消耗 | 适用于只有一个线程访问同步块场景 |
| 轻量级锁 | 竞争的线程不会阻塞, 提高了程序的响应速度 | 如果始终得不到锁竞争的线程, 使用自旋会消耗 CPU | 追求响应时间, 同步块执行速度非常快 |
| 重量级锁 | 线程竞争不使用自旋, 不会消耗 CPU | 线程阻塞, 响应时间缓慢 | 追求吞吐量, 同步块执行速度较长 |

#### 原子操作的实现原理
原子操作意为 "不可被中断的一个或一系列操作"

##### 术语定义

| 述语名称 | 英文 | 解释 |
| :------------- | :------------- |:------------- |
| 缓存行 | Cache Line | 缓存的最小操作单位 |
| 比较并交换 | Compare and Swap | CAS 操作需要输入两个数值, 一个旧值 (期望操作前的值) 和一个新值, 在操作期间先比较旧值有没有发生变化, 如果没有发生变化才交换为新值, 发生了变化则不交换 |
| CPU 流水线 | CPU Pipeline | CPU 流水线的工作方式就像工业生产上的装配流水线, 在 CPU 上由 5 ~ 6 个不同功能的电路单元组成一条指令处理流水线, 然后将一条 X86 指令分成 5 ~ 6 步后再由这些电路单元分别执行, 这样就能实现一个 CPU 时钟周期完成一条指令, 从而提高 CPU 的运算速度 |
| 内存顺序冲突 | MEmory order violation | 内存顺序冲突一般是由假共享引起的, 假共享是指多个 CPU 同时修改同一个缓存行的不同部分而引起其中一个 CPU 操作无效, 当出现这个内存顺序冲突时, CPU 必须清空流水线 |

##### 处理器如何实现原子操作
处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性

###### 使用总线锁定保证原子性
如果多个处理器同时对共享变量进行读改写操作, 那么共享变量就会被多个处理器同时进行操作, 这样读改写操作就不是原子的, 操作后的共享变量的值会和期望的不一致; 那么要保证读改写共享变量的操作是原子的, 就必须保证一个 CPU 在读改写共享变量的时候, 其他 CPU 不能操作缓存了该共享变量内存地址的缓存; 处理器使用总线锁来解决这个问题, 所谓的总线锁就是使用处理器提供的一个 LOCK # 信号, 当一个处理器在总线上输出此信号时, 其他处理器的请求将被阻塞住, 那么该处理器可以独占共享内存

###### 使用缓存锁保证原子性
同一时刻, 只需保证对某个内存地址的操作是原子性的, 但总线锁定把 CPU 和内存之间的通信锁住了, 这使得锁定期间, 其他处理器不能操作其他内存地址的数据, 所以总线锁定的开销比较大; 频繁使用的内存会缓存在处理器的 L1, L2, L3 高速缓存里, 那么原子操作就可以直接在处理器内存缓存中进行, 并不需要声明总线; 所谓 "缓存锁定" 是指内存区域如果被缓存在处理器的缓存行中, 并且在 LOCK 操作期间被锁定, 那么它当执行锁操作回写到内存时, 处理器不再总线上声言 LOCK # 信号, 而是修改内部的内存地址, 并且允许它的缓存一致性机制来保证操作的原子性, 当其他处理器回写已被锁定的缓存行的数据时, 会使缓存行无效; 但是有两种情况下处理器不会使用缓存锁定
- 当操作的数据不能被缓存在处理器内部, 或操作的数据跨在多个缓存行时, 则处理器会调用总线锁定
- 有些处理器不支持缓存锁定

##### Java 如何实现原子操作
在 Java 中可以通过锁和循环 CAS 的方式来实现原子操作

###### 使用循环 CAS 实现原子操作
JVM 中的 CAS 操作正是利用了处理器提供的 CMPXCHG 指令实现的; 自旋 CAS 实现的基本思路就是循环进行 CAS 操作直到成功为止
```Java
public class Counter {
    private AtomicInteger atomicI = new AtomicInteger(0);
    private int i;

    public static void main(String[] args) {
        final Counter cas = new Counter();
        List<Thread> ts = new ArrayList<>(600);
        long start = System.currentTimeMillis();
        for (int j = 0; j < 100; j++) {
            Thread t = new Thread(() -> {
                for (int i = 0; i < 10000; i++) {
                    cas.count();
                    cas.safaCount();
                }
            });
            ts.add(t);
        }

        for (Thread t : ts) {
            t.start();
        }

        // 等待所有线程执行完
        for (Thread t : ts) {
            try {
                t.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        System.out.println(cas.i);
        System.out.println(cas.atomicI.get());
        System.out.println(System.currentTimeMillis() - start);
    }

    /**
     * 使用 CAS 实现的线程安全计数器
     */
    private void safaCount() {
        for (;;) {
            int i = atomicI.get();
            boolean suc = atomicI.compareAndSet(i, ++i);
            if (suc) {
                break;
            }
        }
    }

    /**
     * 非线程安全计数器
     */
    private void count() {
        i++;
    }
}
```
从 JDK 1.5 开始, 并发包里提供了一些类支持原子操作

###### CAS 实现原子操作的三大问题
在 Java 并发包中有一些并发框架也使用了自旋 CAS 的方式来实现原子操作, 比如 LinkedTransferQueue 类的 xfer 方法; CAS 虽然高效的解决了原子操作, 但是 CAS 仍然存在三大问题
- ABA 问题
CAS 需要在操作值的时候, 检查值有没有发生变化, 如果有发生变化则更新, 但是如果原来的值是 A, 变成了 B, 又变回了 A, 那么使用 CAS 进行检查时会发现值没有发生变化, 但实际上却是变化了; ABA 问题的解决思路是使用版本号, 在变量前面追加版本号, A -> B -> A 变成 1A -> 2B -> 3A; JDK 1.5 开始 Atomic 包提供了 Atomic StampedReference 来解决 ABA 问题, 这个类的 compareAndSet 方法的作用是首先检查当前引用时候等于预期引用, 并且检查当前标志时候等于预期标志, 如果全部相等, 则以原子的方式将该引用和该标志的值设置为给定的更新值
- 循环时间长开销大
自旋 CAS 如果长时间不成功, 会给 CPU 带来非常大的执行开销
- 只能保证一个共享变量的原子操作
对一个共享变量可以使用循环 CAS 的方式保证原子操作, 但对多个共享变量时循环 CAS 无能为力; 一种方式是使用锁, 另一种是将多个变量 "合并" 为一个变量

###### 使用锁实现原子操作
锁机制保证了只有获得锁的线程才能够操作锁定的内存区域, JVM 内部实现了偏向锁, 轻量级锁, 互斥锁, 除了偏向锁之外, 其余锁的实现都用了循环 CAS, 即当一个线程想进入同步块的时候使用循环 CAS 的方式获取锁, 退出同步块时使用循环 CAS 释放锁
