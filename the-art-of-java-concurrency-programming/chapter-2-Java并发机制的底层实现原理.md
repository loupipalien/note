### Java 并发机制的底层实现原理
Java 中使用的并发机制依赖于 JVM 的实现和 CPU 的指令

#### volatile 的应用
volatile 是轻量级的 synchronized, 它在多处理器开发中保证了共享变量的 "可见性"; 可见性意味着当一个线程修改一个共享变量时, 另一个线程也能读到这个修改的值, 如果 volatile 变量修饰符使用恰当的话, 比 synchronized 的使用和执行成本更低, 因为它不会引起线程上下文的切换和调度

##### volatile 的定义和实现原理
Java 语言规范第 3 版中对 volatile 的定义如下: Java 编程语言允许线程访问共享变量, 为了确保共享变量能被准确和一致的更新, 线程应该确保通过排他锁单独获得这个变量; Java 语言提供了 volatile, 在某些情况下比锁更要方便, 如果一个字段被声明为了 volatile, Java 线程内存模型确保所有线程看到这个变量的值是一致的; 以下是实现原理相关的 CPU 术语与说明

| 术语 | 英文单词 | 描述 |
| :------------- | :------------- | :------------- |
| 内存屏障 | memory barriers | 是一组处理器命令, 用于实现对内存操作的顺序限制 |
| 缓冲行 | cache line | CPU 高速缓存中可以被分配的最小单位, 处理器在填写缓冲行时会加载整个缓冲行, 现代 CPU 需要执行几百次 CPU 指令 |
| 原子操作 | atomic operations | 不可中断的一个或一系列操作 |
| 缓冲行填充 | cache line fill | 当处理器识别到从内存中读取操作数是可缓存的, 处理器读取整个高速缓存行到适当的缓存 (L1, L2, L3 的或者所有) |
| 缓存命中 | cache hit | 如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时, 处理器从缓存中读取操作数, 而不是从内存中读取 |
| 写命中 | write hit | 当处理器将操作数写回到一个内存缓存的区域时, 它首先会检查这个缓存的内存地址是否在缓存行中, 如果存在一个有效的缓存行, 则处理器将这个操作数写回到缓存中, 而不是写回到内存中, 这个操作被称为写命中 |
| 写缺失 | write misses the cache | 一个有效的缓存行被写入不存在的内存区域 |

查看 JIT 编译器生成的汇编指令, 在对 volatile 声明的变量进行写操作时, CPU 做以下事情
```
// Java 代码
volatile instance = new Singleton();
// 汇编代码
0x01a3de1d: movb $0*0, 0*1104800(%esi); 0x01a3de24: lock addl $0*0, (%esp);
```
有 volatile 变量修饰的共享变量进行写操作的时候会多出第二行汇编代码, 通过 IA-32 架构手册可以, Lock 前缀的指令在多核处理器下会引发两件事情
- 将当前处理器缓存行的数据写回到系统内存
- 这个写回内存的操作会使在其他 CPU 缓存了该内存地址的数据无效
为了提高处理速度, 处理器不直接和内存进行通信, 而是先将系统内存的数据读到内存缓存 (L1, L2 或其他) 后再进行操作, 但操作不知道何时会写到内存; 如果对声明了 volatile 的变量进行写操作, JVM 就会向处理器发送一条 Lock 前缀的指令, 将这个变量在缓存行的数据写回到系统内存; 但是就算写回到系统内存, 如果其他处理器缓存的值还是旧的, 再执行计算操作就会有问题; 所以在多处理器下, 为了保证各个处理器的缓存是一致的, 就会实现缓存一致性协议, 每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了, 当处理器发现自己缓存行对应的内存地址被修改, 就会将当前处理器的缓存行设置成无效状态, 当处理器对这个数据进行修改操作的时候, 会重新从系统内存中把数据读到处理器缓存中

##### volatile 的使用优化
TODO

#### synchronized 的实现原理与应用
在多线程并发编程中 synchronized 一直是被认为是重量级锁, 随着 JDK 1.6 对 synchronized 进行了优化之后, 有些情况下它并没有那么重了; synchronized 实现同步的基础是 Java 中的每一个对象都可以作为锁, 具体表现为以下三种形式
- 对于普通同步方法, 锁是当前实例对象
- 对于静态同步方法, 锁是当前类的 Class 对象
- 对于同步方法块, 锁是 synchronized 括号里配置的对象

当一个线程试图访问同步代码块时, 它首先必须得到锁, 退出或者抛出异常时必须释放锁; JVM 基于进入和退出 Monitor 对象来实现方法同步和代码块同步, 但两者的实现细节不一样; 代码块同步是使用 monitorenter 和 monitorexit 指令实现的, 而 JVM 规范中并没有说方法同步是如何实现的, 但是也可以使用这两个指令实现; monitorenter 指令是在编译后插入到同步代码块的开始位置, 而 monitorexit 是插入到到方法结束处和异常处, JVM 要保证每个 monitorenter 必须有对应的 monitorexit 与之配对, 任何对象都有一个 monitor 与之关联, 当且一个 monitor 被持有后, 它将处于锁定状态; 线程执行到 monitorenter 指令时, 将会尝试获取对象对应的 monitor 的所有权, 即尝试获得对象的锁

##### Java 对象头
synchronized 用的锁是存在 Java 对象头里的, 如果对象是数组类型, 则虚拟机用 3 个字宽存储对象头, 如果对象是非数组类型, 则用 2 个字宽存储对象头; 在 32 位机中 1 字宽等于 8 bit, 即 32 bit

| 长度 | 内容 | 说明 |
| :------------- | :------------- |:------------- |
| 32/64bit | Mark Word | 存储对象的 hashCode 或锁信息等 |
| 32/64bit | Class Metadata Address | 存储到对象类型数据的指针 |
| 32/64bit | Array Length | 数组的长度(如果当前对象是数组) |

Java 对象头里的 Mark Word 里默认存储对象的 HashCode, 分代年龄, 锁标记位; 32 位 JVM 的 Mark Word 的默认存储结构如下表

| 锁状态 | 25 bit | 4 bit | 1 bit 是否是偏向锁 | 2 bit 锁标志位 |
| :------------- | :------------- |:------------- |:------------- |:------------- |
| 无锁状态 | 对象的 hashCode | 对象分代年龄 | 0 | 01 |

在运行期间, Mark Word 里存储的数据会随着锁标志位的变化而变化, Mark Word 可能变化为存储以下 4 种数据

| 锁状态 | 25 bit (23bit + 2 bit) | 4 bit | 1 bit 是否是偏向锁 | 2 bit 锁标志位 |
| :------------- | :------------- | :------------- | :------------- | :------------- |
| 轻量级锁 | 指向栈中锁记录的指针 |-|-|00|
| 轻量级锁 | 指向互斥量 (重量级锁) 的指针 |-|-|10|
| GC 标记 | 空 |-|-|11|
| 偏向锁 | 线程 ID | Epoch + 对象分代年龄 |1|11|

在 64 虚拟机下, Mark Word 是 64 位的

| 锁状态 | 25 bit | 31 bit | 1 bit (cms_free) | 4 bit (分代年龄) | 1 bit (偏向锁) | 2 bit (锁标志位) |
| :------------- | :------------- |:------------- |:------------- |:------------- |:------------- |:------------- |
| 无锁 | unuse | hashCode | - | - |0 | 01 |
| 偏向锁 | ThreadID(54 bit) + Epoch (2bit) | - | - | - |0 | 01 |

##### 锁的升级和对比
