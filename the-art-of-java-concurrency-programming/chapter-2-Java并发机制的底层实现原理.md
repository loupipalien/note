### Java 并发机制的底层实现原理
Java 中使用的并发机制依赖于 JVM 的实现和 CPU 的指令

#### volatile 的应用
volatile 是轻量级的 synchronized, 它在多处理器开发中保证了共享变量的 "可见性"; 可见性意味着当一个线程修改一个共享变量时, 另一个线程也能读到这个修改的值, 如果 volatile 变量修饰符使用恰当的话, 比 synchronized 的使用和执行成本更低, 因为它不会引起线程上下文的切换和调度

##### volatile 的定义和实现原理
Java 语言规范第 3 版中对 volatile 的定义如下: Java 编程语言允许线程访问共享变量, 为了确保共享变量能被准确和一致的更新, 线程应该确保通过排他锁单独获得这个变量; Java 语言提供了 volatile, 在某些情况下比锁更要方便, 如果一个字段被声明为了 volatile, Java 线程内存模型确保所有线程看到这个变量的值是一致的; 以下是实现原理相关的 CPU 术语与说明

| 术语 | 英文单词 | 描述 |
| :------------- | :------------- | :------------- |
| 内存屏障 | memory barriers | 是一组处理器命令, 用于实现对内存操作的顺序限制 |
| 缓冲行 | cache line | CPU 高速缓存中可以被分配的最小单位, 处理器在填写缓冲行时会加载整个缓冲行, 现代 CPU 需要执行几百次 CPU 指令 |
| 原子操作 | atomic operations | 不可中断的一个或一系列操作 |
| 缓冲行填充 | cache line fill | 当处理器识别到从内存中读取操作数是可缓存的, 处理器读取整个高速缓存行到适当的缓存 (L1, L2, L3 的或者所有) |
| 缓存命中 | cache hit | 如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时, 处理器从缓存中读取操作数, 而不是从内存中读取 |
| 写命中 | write hit | 当处理器将操作数写回到一个内存缓存的区域时, 它首先会检查这个缓存的内存地址是否在缓存行中, 如果存在一个有效的缓存行, 则处理器将这个操作数写回到缓存中, 而不是写回到内存中, 这个操作被称为写命中 |
| 写缺失 | write misses the cache | 一个有效的缓存行被写入不存在的内存区域 |

查看 JIT 编译器生成的汇编指令, 在对 volatile 声明的变量进行写操作时, CPU 做以下事情
```
// Java 代码
volatile instance = new Singleton();
// 汇编代码
0x01a3de1d: movb $0*0, 0*1104800(%esi); 0x01a3de24: lock addl $0*0, (%esp);
```
有 volatile 变量修饰的共享变量进行写操作的时候会多出第二行汇编代码, 通过 IA-32 架构手册可以, Lock 前缀的指令在多核处理器下会引发两件事情
- 将当前处理器缓存行的数据写回到系统内存
- 这个写回内存的操作会使在其他 CPU 缓存了该内存地址的数据无效
为了提高处理速度, 处理器不直接和内存进行通信, 而是先将系统内存的数据读到内存缓存 (L1, L2 或其他) 后再进行操作, 但操作不知道何时会写到内存; 如果对声明了 volatile 的变量进行写操作, JVM 就会向处理器发送一条 Lock 前缀的指令, 将这个变量在缓存行的数据写回到系统内存; 但是就算写回到系统内存, 如果其他处理器缓存的值还是旧的, 再执行计算操作就会有问题; 所以在多处理器下, 为了保证各个处理器的缓存是一致的, 就会实现缓存一致性协议, 每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了, 当处理器发现自己缓存行对应的内存地址被修改, 就会将当前处理器的缓存行设置成无效状态, 当处理器对这个数据进行修改操作的时候, 会重新从系统内存中把数据读到处理器缓存中

##### volatile 的使用优化
