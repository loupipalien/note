### Java 内存模型

#### Java 内存模型的基础
##### 并发编程模型的两个关键问题
在并发编程中需要处理两个关键问题: 线程之间如何通信以及线程之间如何同步; 通信是指线程之间以何种机制来交换信息, 在命令式编程中, 线程之间的通信机制有两种: 共享内存和消息传递  
在共享内存的并发模型里, 线程之间共享程序的公共状态, 通过读写内存中的公共状态进行隐式通信; 在消息传递的并发模型里, 线程之间没有公共状态, 线程之间必须通过发送消息来显示进行通信  
同步是值程序中用于控制不同线程间操作发生相对顺序的机制, 在共享内存并发模型里, 同步是显式进行的; 在消息传递的模型里, 由于消息的发送必须在消息接收之前, 因此同步是隐式进行的  
Java 的并发采用的是共享内存模型, Java 线程之间的通信是隐式进行的

##### Java 内存模型的抽象结构
在 Java 中所有的实例域, 静态域, 数组元素都存储在堆内存中, 堆内存在线程之间共享; 局部变量, 方法定义参数, 异常处理器参数不会在线程之间共享, 因此不会有内存可见性问题, 也不受内存模型的影响  
Java 线程之间的通信由 Java 内存模型 (JMM) 控制, JMM 决定了一个线程对共享变量的写入何时对另一个线程可见; JMM 定义了线程和主内存之间的抽象关系: 线程之间的共享变量存储在主内存 (Main Memory) 中, 每个线程都有一个私有的本地内存 (Local Memory), 本地内存中存储了该线程以读/写共享变量的副本 (本地内存只是一个抽象, 并不存在)
```
-----------                   -----------
|  线程 A  |                  |  线程 B  |
-----------                   -----------
    |                              |
    V                              V
-------------                 -------------
|本地内存 A  |                 |本地内存 B  |
|共享变量副本|                 |共享变量副本 |  
-------------                 -------------    
    |                              |
    V                              V
--------------------------------------------
|                 主内存                    |
|                共享变量                   |
--------------------------------------------
```
如果线程 A 和线程 B 要通信的话, 必须通过以下两个步骤
- 线程 A 把本地内存 A 更新过的共享变量刷新到主内存中去
- 线程 B 到主内存中读取线程 A 之前更新过的变量
从整体上来看, 以上两个步骤实质上是线程 A 向线程 B 发消息, 而且这个通信必须经过主内存; JMM 通过控制主内存与每个线程的本地内存之间的交互, 来为 Java 程序提供内存可见性

##### 从源代码到指令序列的重排序
在执行程序时, 为了提高性能, 编译器和处理器常会对指令做重新排序, 分以下三种
- 编译器优化的重排序
- 指令级并行的重排序
- 内存系统的重排序
对于编译器, JMM 的编译器重排序规则会禁止特定类型的编译器重排序; 对于处理器, JMM 的处理器重排序规则会要求 Java 编译器在生成指令序列时, 插入特定类型的内存屏障指令, 同步内存屏障指令来禁止特定类型的处理器重排序; JMM 属于语言级的内存模型, 确保在不同的编译器和不同的处理器平台上, 通过禁止特定类型的编译器和处理器重排序, 提供一致的内存可见性保证

##### 并发编程模型的分类
