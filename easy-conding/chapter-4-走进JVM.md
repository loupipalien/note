### 走进 JVM
Oracle 的 HotSpot JVM 实现是目前 OpenJDK 使用的主流 JVM, 采用解释与编译混合执行的模式, 其中 JIT 技术采用分层编译, 极大的提升了 Java 的执行速度

#### 字节码
Java 所有的指令有 200 个左右, 一个字节 (8位) 可以存储 256 种不同的指令信息, 一个这样的字节称为字节码 (ByteCode); 在代码的执行过程中, JVM 将字节码解释执行, 屏蔽对底层操作系统的依赖, JVM 也可以将字节码编译执行, 如果是热点代码, 会通过 JIT 动态编译为机器码, 提高执行效率; 字节码中的主要指令如下

##### 加载或存储指令
在某个栈帧中, 通过指令操作数据在虚拟机的局部变量表与操作栈之间来回传输
- 将局部变量加载到操作栈中
如 ILOAD (将 int 类型的局部变量压入栈) 和 ALOAD (将对象引用的局部变量压入栈) 等
- 从操作栈顶存储到局部变量表
如 ISTORE, ASTORE 等
- 将常量加载到操作栈顶, 极为高频使用的指令
  - ICONST 加载的是 -1 ~ 5 的数 (ICONST 和 BIPUSH) 的加载界限
  - BIPUSH, 即 Byte Immediate PUSH, 加载 -128 ~ 127 之间的数
  - SIPUSH, 即 Short Imediate PUSH, 加载 -32768 ~ 32767 之间的数
  - LDC, 即 Load Constant, 在 -2147483648 ~ 2147483647 之间的数或者字符串, JVM 采用 LDC 指令压入栈中
- 运算指令
对两个操作栈帧上的值进行运算, 并把结果写入操作栈顶, 如 IADD, IMUL 等
- 类型转换指令
显式转换两种不同的数值类型, 如 I2L, D2F 等
- 对象创建与访问指令
  - 创建对象指令: 如 NEW, NEWARRAY 等
  - 访问属性指令: 如 GETFIELD, PUTFIELD, GETSTATIC 等
  - 检查实例类型指令: 如 INSTANCEOF, CHECKCAST 等
- 操作栈管理指令
  - 出栈操作: 如 POP 即一个元素, POP2 即两个元素
  - 复制栈顶元素并压入栈: 如 DUP
- 方法调用与返回指令
  - INVOKEVIRTUAL 指令: 调用对象的实例方法
  - INVOKESPECIAL 指令: 调用实例初始化方法, 私有方法, 父类方法等
  - INVOKESTATIC 指令: 调用静态方法
  - RETURN 指令: 返回 VOID 类型
- 同步指令
JVM 使用方法结构中的 ACC_SYNCHRONIZED 标志同步方法, 指令集中有 MONITORENTER 和 MONITOREXIT 支持 synchronized 语义

除字节码外, 还包含一类额外的信息; 例如 LINENUMBER 存储了字节码与源码行号的对应关系, 方便调试的时候正确的定位到代码的所在行: LOCALVARIABLE 存储当前方法中使用到的局部变量表  
在 Java 中把 .java 文件转化为字节码的过程如下
```
Java 源文件 => 词法解析 => 语法解析 => 语法分析 => 生成字节码 => 字节码
```   
字节码必须通过加载过程到 JVM 环境后才可以执行, 执行有三种模式: 解释模式, JIT 编译模式, JIT 编译和解释混合执行 (主流 JVM 默认方式); 混合执行模式的优势在于解释器在启动时先解释执行, 省去编译时间, 随着时间的推进, JVM 通过 JIT 动态编译技术, 将热点代码转换为机器码, 直接交给 CPU 执行; JIT 的作用是将 Java 字节码动态的编译为可以直接发送给处理器指令执行的机器码
```
            |-----------------------------> 执行编译后的机器码 ----------------------------------------
            | 是                                                                   |---> Code Cache  |
方法调用     |                                                           |---> 后台执行编译            |
--------> 已编译?                                                |---> 编译器                         |
            |                                    |--------> 提交编译请求                              |
            | 否                                 | 是           |                                 方法返回 --->
            |                                    |             |                                     |
            | ----> 方法调用计数加 1 ----> 计数是否超过阈值?      |                                     |
                                                 |             |                                     |
                                                 | 否          v                                     |     
                                                 |--------> 解释方式执行 ------------------------------
                                                               ^
                                                   解释器 ------|
```                                                            

#### 类加载过程
ClassLoader 的使命是提前加载 .class 文件到内存中, 在加载类时使用的 Parents Delefation Model (双亲委派模式)  
类加载是一个将 .class 字节码文件实例化成 Class 对象并进行相关初始化的过程; 在这个过程中, JVM 会初始化继承树上还没有被初始化过的所有父类, 并且会执行这个链路上所有未执行过的静态代码块, 静态变量赋值语句等; 某些类的使用也可以按需由类加载器进行加载  
类加载器最高层是 Bootstrap, 它是在 JVM 启动时创建的, 通常由操作系统相关的本地代码实现, 是最根基的类加载器, 负责装载最核心的 Java 类; 第二层是 Extension ClassLoader, 用来加载一些扩展的系统类; 第三层是 Application ClassLoader, 主要加载用户自定义 CLASSPATH 路径下的类  
以下代码可以查看 Bootstrap 加载的类库
```
public static void main(String[] args) {
    URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();
    for (URL url : urls) {
        System.out.println(url.toExternalForm());
    }
}
```
除了以上三种自带的 ClassLoader, 也可以自定义 ClassLoader; 通常在以下情况需要自定义类加载器
- 隔离加载类
- 修改类加载方式
- 扩展加载源
- 防止源码泄露

自定义类加载器的步骤: 继承 ClassLoader, 重写 findClass() 方法, 调用 defineClass() 方法; 简单示例如下
```
public class CustomClassLoader extends ClassLoader {

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        try {
            byte[] result = getClassFromCustomPath(name);
            if (result == null) {
                    throw new FileNotFoundException();
            } else {
                defineClass(name, result, 0, result.length);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
        throw new ClassNotFoundException();
    }

    private byte[] getClassFromCustomPath(String name) {
        // 从自定义路径中加载指定类
        return null;
    }
}
```

#### 内存布局
```
----------------------------------------------------------------------------------------------------
|  ---------------------------------------------  -----------------------------------------------  |
|  |         Native Method Stacks              |  |           Program Counter Register          |  |
|  |             本地方法栈                     |  |                   程序计数器                 |  |
|  ---------------------------------------------  -----------------------------------------------  |
|  ----------------------------------------------------------------------------------------------  |
|  |             ----------------------------------------------         -----------------       |  |
|  | JVM Stacks  |                 栈帧-1 (方法 A)             |        | 栈帧-2 (方法 B) |      |  |
|  |  虚拟机栈    |--------------------------------------------|        |-----------------       | |
|  |             | 局部变量表 | 操作栈 | 动态连接 | 方法返回地址 |         |       ...      |      |  |
|  |             ----------------------------------------------         -----------------       |  |
|  ----------------------------------------------------------------------------------------------  |
|  ----------------------------------------------  ------------------------------  --------------- |
|  |               Heap (堆区)                  |  |     Metaspace (元空间)      |  |             | |
|  | ----------------------------  -----------  |  |  ---------  -------------- |  |             | |
|  | |       Eden     | S0 | S1 |  |          | |  | |  常量池 |  |   class   |  |  | Code Cache | |
|  | |--------------------------|  |  Old 区  | |  | -----------  |  类元信息 |  |  |  JIT 产物   | |
|  | |   Young 区 (新生代)       |  |  老年代  | |  | |方法元信息|  |          |  |  |             | |
|  | ----------------------------  -----------  |  | ----------   ------------  |  |             | |
|  ----------------------------------------------  -----------------------------   --------------- |
----------------------------------------------------------------------------------------------------
```

##### Heap (堆区)
堆存储着几乎所有的实例对象, 堆由垃圾收集器自动回收, 堆区由各子线程共享使用  
堆分成两大块: 新生代和老年代; 对象产生之处在新生代, 步入暮年时进入老年代, 但是老年代也接纳新生代无法容纳的大对象; 新生代有一个 Eden 区, 2 个 Survivor 区; 绝大部分对象在 Eden 区生成, 当 Eden 区装满的时候, 会触发 Young Garbage Collection (YGC); 垃圾回收时, 在 Eden 区实现清除策略, 没有被引用的对象则直接回收, 依然存活的对象会被移送到 Survivor 区, Survivor 区分区 S0 和 S1 两块, 每次 YGC 时将存活的对象复制到未使用的那块 Survivor 空间, 然后将当前正在使用的 Survivor 空间全部清除, 交换两块空间的使用状态; 如果 YGC 要移送的对象大于 Survivor 区容量则直接交给老年代, 在 Survivor 区的对象存活过 -XX:Max Tenuring Threshold 设置的阈值 (默认是 15) 时, 那么对象会晋升到老年代; 当对象放入老年代时, 老年代无法放下则会触发 Full Garbage Collection (FGC), 如果依然无法放下则抛出 OOM

##### Metaspace (元空间)
JDK7 及以前版本中的 Perm 区由于固定大小且难以调优, 在 JDK8 使用 Metaspace 替代; 区别于永久代, 元空间在本地内存中分配, 在 JDK8 里 Perm 区中的所有内容的字符串常量移到堆内存, 其他内容包括类元信息, 字段, 静态属性, 方法, 常量等都移到元空间

##### JVM Stacks (虚拟机栈)
JVM 中的虚拟机栈是描述 Java 方法执行的内存区域, 它是线程私有的, 栈中元素用于支持虚拟机进行方法调用, 每个方法从开始调用到执行结束的过程, 就是栈帧从入栈到出栈的过程; 在活动线程中, 只有位于栈顶的帧才是有效的, 称为当前栈, 正在执行的方法称为当前方法, 帧栈是方法运行的基本结构; 在执行引擎运行时, 所有指令都只能针对当前帧栈进行操作; StackOverflowError 表示请求的栈溢出, 导致内存耗尽, 通常出现在递归方法中; 帧栈在整个 JVM 体系中的地位较高, 包括局部变量表, 操作栈, 动态连接, 方法返回地址等

###### 局部变量表
局部变量表是存放方法参数和局部变量的区域, 局部变量没有准备阶段, 必须显式初始化; 如果是非静态方法, 则在 index[0] 位置上存储的是方法所属对象的实例引用, 随后存储的是参数和局部变量

###### 操作栈
操作栈是一个初始状态为空的桶式结构栈, 在方法执行过程中, 会有各种指令方栈中写入和提取信息; JVM 的执行引擎是基于栈的执行引擎, 其中的栈指的是操作栈; 字节码指令集的定义都是基于栈类型的, 栈的深度在方法的元信息的 stack 属性中; 以下是 i++ 和 ++i 的字节码对比

| a = i++ | a = ++i |
| :--- | :--- |
| 0: iload_1; 1: iinc 1,1; 4: istore_2 | 0: iinc 1,1; 3: iload_1; 4: istore_2 |

###### 动态连接
每个帧栈中包含一个在常量池中对当前方法的引用, 目的是自持方法调用过程的动态连接

###### 方法返回地址
方法执行有两种退出方式: 正常退出和异常退出; 无论何种退出情况, 都将返回至方法当前被调用的位置, 方法退出相当于弹出当前帧栈; 退出的三种处理
- 返回值压入上层调用帧栈
- 异常信息抛给能够处理的帧栈
- PC 计数器指向方法调用后的下一条指令

##### Native Method Stacks (本地方法栈)
本地方法栈在 JVM 内存布局外, 也是线程对象私有的, 但是虚拟机栈 "主内", 本地方法栈 "主外", 这里内外是针对 JVM 来说的; 本地方法栈为 native 方法服务, 线程开始调用本地方法时会进入一个不再受 JVM 管控的区域; 本地方法可以用过 JNI (Java Native Interface) 来访问虚拟机运行时的数据区, 甚至可以调用寄存器, 具有和 JVM 相同的能力和权限; 对于内存不足的情况, 本地方法栈会抛出 native heap OutOfMemory

##### Program Counter Register (程序计数器)
每个线程在创建后都会产生自己的程序计数器和帧栈, 程序计数器用来存放执行指令的偏移量和行号指示器, 线程执行和恢复都要依赖程序计数器, 程序计数器在各个线程之间互不影响, 此区域也不发生内存溢出异常  

最后才线程共享的角度来看, 堆和元空间是所有线程共享的, 而虚拟机栈, 本地方法栈, 程序计数器是线程私有的

#### 对象实例化
Java 是面向对象的静态强类型语言, 常通过声明并创建对象并赋值, 例如 `Object ref = new Object();`, 以下是利用 `javap --verbose -p` 查看的对象创建的字节码
```
stack = 2, locals = 1, args_size = 0
    NEW java/lang/Object
    DUP
    INVOKESPECIAL java/lang/Object.<init> ()V
    ASTORE_1
    LocalVariableTable:
        Start  Length  Slot  Name  Signature
          8      1      0    ref      Ljava/lang/Object;
```
- NEW
如果找不到 Class 对象, 则进行类加; 加载成功后, 则在堆中分配内存, 从 Object 开始到本类路径上的所有属性值都要分配内存; 分配完毕之后, 进行零初始化; 在分配过程中需注意引用是占据存储空间的, 它是一个占用 4 个字节的变量; 这个指令完成后, 将指向实例对象的引用变量压入虚拟机栈顶
- DUP
在栈顶复制该引用变量, 这个时候栈顶有两个指向堆内存实例对象的引用变量, 如果有 <init> 方法有参数, 还需要把参数压入操作栈中; 两个引用变量的目的不同, 其中压至底的引用用于赋值, 或者保存到局部变量中, 另一个栈顶的引用变量作为句柄调用相关方法
- INVOKESPECIAL
调用对象实例方法, 通过栈顶的引用变量调用 <init> 方法; <client> 是类初始化时执行的方法, 而 <init> 是对象初始化时执行的方法

以上是从字节码的角度来看, 以下则是从执行的角度分析
- 确认类元信息是否存
当 JVM 接收到 new 指令时, 首先在 Metaspace 内检查需要创建的类元信息是否存; 若不存在, 那么在双亲委派模式下, 使用当前类加载器以 ClassLoader + 包名 + 类名 为 key 进行查找 .class 文件, 如果没有找到则抛出 ClassNotFoundException, 如果找到则进行类加载, 并生成对应的 Class 类对象
- 分配对象内存
首先计算对象占用空间大小, 如果实例成员是引用变量分配引用变量空间即可, 接着在堆中划分一块内存给新对象; 在分配内存空间时, 需要进行同步操作, 如采用 CAS 失败重试, 区域加锁等方式保证分配操作的原子性
- 设定默认值
成员变量都需要设定默认值
- 设置对象头
设置新对象的哈希码, GC 信息, 锁信息, 对象所属的类元信息等
- 执行 init 方法
初始化成员变量, 执行实例化代码块, 调用类的构造方法, 并把堆内对象的首地址赋值给引用变量

#### 垃圾回收
垃圾回收的主要目的是清除不再使用的对象, 自动释放内存; JVM 根据是否与 GC Roots 之间有没有直接或间接的引用关系,
判定是否需要被回收; GC Roots 有: 类静态属性中引用的对象, 常量引用的对象, 虚拟机栈中引用的对象, 本地方法栈中引用的对象  
有了判定标准后, 需要有垃圾回收的相关算法; 最基础的为 "标记-清除" 算法, 该算法会从每个 GC Roots 出发, 依次标记有引用关系的对象, 最后将没有被标记的对象清除, 但是这种算法会带来大量碎片, 导致需要分配一个较大的对象时容易出现 FGC; 为了解决这个问题, 提出了 "标记-整理" 算法, 会从 GC Roots 出发标记存活的对象, 然后将其整理到内存的一端, 再将其余的空间全部清理; "Mark-Copy" 算法为了能够并行地标记和整理将空间分为两块, 每次只激活其中一块, 垃圾回收时只需要把存活的对象复制到另一块未激活的空间上, 将未激活的空间激活, 已激活的空间标为未激活并清理全部; "Mark-Copy" 现在是主流的 YGC 算法进行新生代的垃圾回收  
垃圾回收器有数十种, 本节只介绍 Serial, CMS, G1  
TODO
