### 计算机基础

#### 走进 0 与 1 的世界
计算机是二进制的世界, 在计算机中二进制整数都是以补码的形式出现的; 正数的补码和源码, 反码是一致的, 负数的补码是反码加 1 的结果  

###### 位移运算
在左移 << 和右移 >> 两种运算中, 符号位均参与移动, 除负数向右移动, 高位补 1 之外, 其他情况均在空位处补 0

| 正数/负数 | 向左移 << 1 位 | 向右移 >> 1 位 |
| :------------- | :------------- |:------------- |
| 正数 (35 的补码是 00100011) | 01000110 = 70 | 00010001 = 17 |
| 负数 (-35 的补码是 11011101) | 10111010 = -70 | 11101110 = -18 |
| 正数 (99 的补码是 01100011) | 11000110 = -58 | 00110001 = 49 |
| 负数 (-99 的补码是 10011101) | 00111010 = 58 | 11001110 = -50 |

左移运算由于符号位参与移动, 移动的结果中最左位可能是 1 或者 0, 所以正数负数移动后都有可能是正是负  
对于三个大于号的 >>> 无符号向右移动 (**注意不存在 <<< 无符号向左移动的运算方式**), 当向右移动时, 正负数高位均补 0, 正数不断向右移动的最小值是 0, 而负数不断向右移动的最小值是 1

| 正数/负数 | 向右移 >>> 1 位 | 向右移 >>> 2 位 | 向右移 >>> 3 位 |
| :------------- | :------------- |:------------- |
| 正数 (35 的补码是 00100011) | 00010001 = 17 | 00001000 = 8 | 00000100 = 4 |
| 负数 (-35 的补码是 11011101) | 01101110 = 110 | 00110111 = 55 | 00011011 = 27 |

在实际编程中, 位移运算仅作用于整型 (32) 和长整型 (64), 移动的位数是 mod 32 或 目的 64 的结果, 即 35 >>> 1 == 35 >>> 33, 所以正数不断向右移动的最小值是 0, 而负数不断向右移动的最小值是 1  

###### 逻辑与和逻辑或
逻辑与 (&&) 和逻辑或 (||) 有具有短路功能

#### 浮点数
计算机定义了两种小数, 分别为定点数和浮点数, 其中定点数的小数点位置是固定的

##### 科学计数法
浮点数是计算机用来表示小数的一种类型; 在数学中, 采用科学计数法来近似表示一个极大或者极小且位数多的值; 如 $ a * 10^n $,  其中 a 满足 $ 1 \leq |a| < 10 $, $ a * 10^n $ 还可以表示为 aen, 例如 -4.86e11 = $ -4.86 * 10^11 $ = -486000000000; 科学计数法的有效数字为从第一个非零数字开始的全部数字, 指数决定小数点的位置, 符号表示该数的正与负

##### 浮点数表示
浮点数表示就是如何用二进制数表示符号, 指数, 有效数字, 业界流行的标准是 IEEE754, 该标准规定了四种浮点类型: 单精度, 双精度, 延伸单精度, 延伸双精度, 前两种最常用

| 精度 | 字节数 | 正数取值范围 | 负数取值范围 |
| :------------- | :------------- |:------------- |:------------- |
| 单精度类型 | 4 | 1.4e-45 ~ 3.4e+48 | 3.4e-48 ~ 1.4e+45 |
| 双精度类型 | 8 | 4.9e-324 ~ 1.798e+308 | 1.798e-308 ~ 4.9e+324 |

因为浮点数无法表示零值, 所以取值分为两个区间, 正数区间和负数区间

TODO

#### 字符集和乱码
在 Unix 中换行使用换行符 "\n",  在 Windows 中换行使用换行回车 "\n\r", 在旧版 macOS 中换行使用回车符 "\r", 新版 OS X 使用与 Unix 一致的换行方式

#### CPU 与内存
TODO

#### TCP/IP

##### 网络协议
TCP/IP (Transmission Control Protocol / Internet Protocol) 即传输控制协议 / 因特网互联协议, 在这个协议族中还有其他协议, 例如 HTTP, HTTPS, FTP, SMTP, UDP, ARP, PPP, IEEE 802.x 等, TCP/IP 是当前流行的网络传输层协议, 由于 TCP/IP 最为核心, 所以把该协议族称为 TCP/IP
```
A 机器                             B 机器
----------------------------------------
应用层     <- HTPP/FTP/SMTP ->     应用层                           
传输层        <= TCP/UDP ->        传输层
网络层         <- IP/ARP ->        网络层
链路层    <- IEEE 802.x/PPP ->     链路层
  |<---------->  物理层  <---------->|
```

###### 链路层
链路层以字节为单位把 0 和 1 进行分组, 定义数据帧, 写入源, 目标机器的物理地址, 数据, 校验位来传输数据
```
-----------------------------------------------------------------------------
|源 MAC 地址|目标 MAC 地址|网络层协议|| IP 报头 |      IP 数据       | 校验数据 |
| 6 个字节  |  6 个字节   | 2 个字节 ||        | TCP 报头 | TCP 数据|  4 个字节|
-----------------------------------------------------------------------------
```
MAC 地址长 6 个字节共 48 位, 通常用十六进制表示, 前 24 位管理机构统一分配, 后 24 位厂商分配
###### 网络层
根据 IP 定义网络地址, 区分网段; 子网内根据地址解析协议 (ARP) 进行 MAX 寻址, 子网外进行路由转发数据包, 即 IP 数据包
###### 传输层
数据包通过网络发送到目标计算机后, 应用程序在传输层定义逻辑端口, 确认身份后将数据包交给应用程序, 实现端到端的通信; 最典型的协议是 TCP 和 UDP 协议; UDP 只是在 IP 数据包上增加端口等部分信息, 是面向无连接的, 是不可靠传输, 多用于视频通信等; TCP 是面向连接的, 是一种端到端通过失败重传机制建立的可靠数据传输方式, 给人感觉是有一条固定的通路承载着数据的可靠传输
###### 应用层
传输层的数据在到达应用后, 以某种统一规定的协议格式解读数据

##### IP 协议
IP 是面向无连接, 无状态的, 没有额外的机制保证发送包是否有序到达; IP 首先规定了 IP 地址格式, 该地址相当于在逻辑上进行了网段划分, 给每台计算机额外设置了一个唯一的详细地址; IP 地址属于网络层; 主要功能在 WLAN 内进行路由寻址, 选择最佳路由; IP 报文如下, 共 32 位 4 个字节, 通常使用十进制数来表示
```
         -----------------------------------------------------------------
IP 报头  | 版本号 | 头长度|服务类型TOP(8位)|          总长度 (16位)         |
         -----------------------------------------------------------------
        |          标识 (16位)           |标志(3位)| 分段偏移 (13 位)      |
        ------------------------------------------------------------------
        |生存时间TTL(8位)|挂载协议标识(8位)|          校验和 (16位)         |
        ------------------------------------------------------------------
        |                        源 IP 地址 (32 位)                       |
        ------------------------------------------------------------------              
        |                       目标 IP 地址 (32 位)                      |   
        ------------------------------------------------------------------          
        |                          选项                          |  填充  |
        ------------------------------------------------------------------
IP 数据 |                      数据 (TCP 报文或 UDP 报文)                  |
        ------------------------------------------------------------------
```
TTL 即数据包可经过的最多路由数, TTL 初始值由源主机设置后, 在传输中每经过一个路由器减 1, 当为 0 时数据包被丢弃, 并发送 ICMP 报文通知主机, 防止源主机无休止的发送报文

##### TCP 建立连接
传输控制协议 (Transmission Control Protocol, TCP), 是一种面向连接, 确保数据在端到端间可靠传输的协议; 面向连接是指在发送数据之前, 需要先建立一条虚拟的链路, 然后让数据在这条链路上 "流动" 完成传输; 为了确保数据的可靠传输, 不仅需要对发出的每一个字节进行编号确认, 校验每一个数据包的有效性, 在出现超时情况时进行重传, 还需要通过实现滑动窗口和拥塞控制等机制, 避免网络状况恶化而最终影响数据拆传输的极端情形; 每个 TCP 数据包是封装在 IP 包中的, 每一个 IP 头的后面紧跟着的是 TCP 头, TCP 报文格式如下
```
          ----------------------------------------------------------------
TPC 报头  |     源机器端口号 (16 位)       |    目标机器端口号 (16 位)      |
         -----------------------------------------------------------------
         |                    序列号 (32 位, 即 seq = ?)                  |
         -----------------------------------------------------------------
         |                   确认序号 (32 位, 即 ack = ?)                 |
         -----------------------------------------------------------------
         |头部长度|     保留  |SYN|ACK|FIN|    本方滑动窗口大小 (16 位)     |
         |  4 位  |     6 位 |PSH|RST|URG|                                |
         -----------------------------------------------------------------
         |        校验和 (16 位)          |      紧急指针 (16 位)          |
         -----------------------------------------------------------------
         |         选项 (发送方最大报文段长度和扩大接受方滑动窗口)           |
         -----------------------------------------------------------------
TCP 数据 |            数据 (最大荷载是由网络设备的 MTU 决定的)              |
         ----------------------------------------------------------------
```
协议第一行的两个端口号各占两个字节, 分别代表了源机器和目标机器的端口号, 这两个端口号与 IP 报头中的源 IP 地址和目标 IP 地址所组成的四元组可唯一标识一条 TCP 连接; 其中 SYN (Synchronize Sequence Numbers) 用作建立连接时的不同步信号, ACK (Acknowledgement) 用于对收到的数据进行确认, 所确认的数据由确认序号表示, FIN (Finish) 表示后面没有数据需要发送, 通常意味着所建立的连接需要关闭了  
以下是通过三次握手建立 TCP 连接的过程
- A 机器发出一个数据包并将 SYN 置为 1, 表示希望建立连接, 这个包中的序列号假设是 x
- B 机器收到 A 机器发过来的数据包后, 通过 SYN 得知这是一个建立连接的请求, 于是发送一个响应包并将 SYN 和 ACK 标记都置为 1, 假设这个包的序列号是 y, 而确认号必须是 x + 1, 表示收到了 A 发过来的 SYN; 在 TCP 中, SYN 被当作数据部分的一个字节
- A 收到 B 的响应包后需要进行确认, 确认包中将 ACK 置为 1, 并将确认序列号设置为 y + 1, 表示收到了来自 B 的 SYN
```
         A 机器                                        B 机器
LISTENING  |  请求连接                                    | LISTENING
           |              SYN = 1, seq = x               |
SYN_SENT   |-------------------------------------------->|           
           |                                             | SYN_RCVD
           |   SYN = 1, ACK = 1, seq = y, ack = x + 1    |
ESTABLISHED|<--------------------------------------------|
           |                                             |
           |      ACK = 1, seq = x + 1, ack = y + 1      |
           |-------------------------------------------->| ESTABLISHED
           |                                             |
           |                 双向传输数据                 |
           |<------------------------------------------->|
```
第三次握手的目的在于: 信息对等和防止超时; 从信息对等的角度来看, 双方之后确定了 4 类信息才能建立连接

| 第几次握手 |  自己发报能力 (A 视角) | 自己收报能力 (A 视角) | 对方发报能力 (A 视角) | 对方收报能力 (A 视角) | 自己发报能力 (B 视角) | 自己收报能力 (B 视角) | 对方发报能力 (B 视角) | 对方收报能力 (B 视角) |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 第一次握手 | NO | NO |NO |NO |NO | YES | YES | NO |
| 第二次握手 | YES | YES | YES | YES | NO | YES | YES | NO |
| 第三次握手 | YES | YES | YES | YES | YES | YES | YES | YES |

第三次握手也是防止出现请求超时导致脏连接; TTL 网络报文的生存时间往往超过 TCP 请求时间, 如果两次握手就可以创建连接, 传输数据并释放连接后, 第一个超时的连接请求才到达 B 机器的话, B 机器会以为是 A 机器创建新的连接, 然后确认同意创建连接, 然而因为 A 机器不是 SYN_SENT 的状态, 所以直接丢弃了 B 的确认数据, 导致最后只有 B 机器单方面创建连接完毕; 如果是三次握手, 则 B 机器收到请求后会向 A 机器确认同意创建连接, 因为 A 机器不是 SYN_SENT 的状态, 所以直接丢弃, 那么 B 机器由于长时间没有收到确认信息, 最终超时导致连接失败, 因而不会出现脏数据  
TCP 在协议层面支持 Keep Alive 功能, 即隔段时间通过向对方发送数据表示连接处于健康状态; 不少服务将确保连接健康的行为放在了应用层, 通过定期发送心跳包检查连接的健康度, 一旦心跳包出现异常不仅会主动关闭连接, 还会回收与连接相关的其他用于提供服务的资源, 确保系统资源最大限度地被有效利用

##### TCP 断开连接
TCP 全双工通信, 双方都能作为数据的发送方和接收方, 但 TCP 连接也会有断开的时候, 建立连接需要握手三次, 断开连接要挥手四次
- A 机器想要关闭连接, 则在本方数据发送完毕后, 传递 FIN 信号给 B 机器
- B 机器应答 ACK, 告诉 A 机器可以断开, 但是需要 B 机器处理完数据再主动给 A 机器发送 FIN 信号; 此时 A 机器处于半关闭状态 (FIN_WAIT_2), 无法再发送新的信息
- B 机器做好连接关闭前的准备工作后, 发送 FIN 给 A 机器, 此时 B 机器进入 LAST_ACK 状态 (LAST_ACK)
- A 机器发送针对 B 机器的 FIN 的 ACK 后, 进入 TIME_WAIT 状态, 经过 2MSL (Maximum Segment Lifttime) 后, 没有收到 B 机器传来的报文, 则确定 B 机器已经收到了 A 机器发送的 ACK 指令, 此时 TCP 连接正式释放
```
         A 机器                                        B 机器
LISTENING  |                  双向传输                    | ESTABLISHED
主动关闭    |              FIN = 1, seq = u               |
FIN_WAIT_1 |-------------------------------------------->| 被动关闭          
           |                                             |
           |        ACK = 1, seq = v, ack = u + 1        |
FIN_WAIT_2 |<--------------------------------------------| CLOSE_WAIT
           |                  单向传输                    |
           |    FIN = 1, ACK = 1, seq = w, ack = u + 1   |
TIME_WAIT  |<--------------------------------------------| LAST_ACK
           |                                             |
           |      ACK =1, seq = u + 1, ack = w + 1       |
           |-------------------------------------------->| CLOSED
           |                                             |
等待 2MSL  |                                             |
           |                                             |
CLOSED     |                                             |           
```
TIME_WAIT 和 CLOSE_WAIT 分别代表主动关闭和被动关闭产生的阶段性状态, 如果线上服务器大量出现这样的状态, 就会加重机器负载, 也会影响有效连接的创建, 因此需要进行有针对性的处理
- TIME_WAIT: 主动要求关闭机器表示收到了对方的 FIN 报文, 并发送出了 ACK 报文, 进入 TIME_WAIT 状态, 等 2MSL 后即可进入到 CLOSED 状态, 如果 FIN_WAIT_1 状态下, 同时收到带 FIN 标志和 ACK 标志的报文时, 可以直接进入 TIME_WAIT 状态, 而无须经过 FIN_WAIT_2 状态
- CLOSE_WAIT: 被动要求关闭的机器收到对方请求关闭连接的 FIN 报文, 在第一 ACK 应答后, 马上进入 CLOSE_WAIT 状态, 这种状态其实表示在等待关闭, 并且通知应用程序发送剩余数据, 处理现场信息, 关闭相关资源

TIME_WAIT 等待的 2MSL 是报文在网络上生存的最长时间的两倍, 超过这个阈值便将报文丢弃; RFC793 中规定 MSL 为 2 分钟, 但是在当前的高速网络中, 4 分钟的等待会造成资源的极大浪费, 为何不跳过 TIME_WAIT 状态直接进入到 CLOSED 状态呢?
- 确认被动关闭方能够顺利进入 CLOSED 状态; 加入最后一个 ACK 由于网络的原因导致无法到达 B 机器, 处于 LAST_ACK 的 B 机器通常 "自信" 地以为对方没有收到自己的 FIN + ACK 报文, 所以会重发; A 机器收到第二次的 FIN + ACK 报文时会重发一次 ACK, 并且重新计时; 如果 A 机器收到 B 机器的 FIN + ACK 报文后, 发送一个 ACK 给 B 机器就进入了 CLOSED 状态, 可能会导致 B 机器无法确保收到最后的 ACK 指令, 而导致无法进入 CLOSED 状态, 这是 A 机器不负责的表现
- 防止失效请求; 为了防止已失效的连接的请求数据包与正常连接的请求数据包混淆而发生异常

TIME_WAIT 状态过多大多数可以通过优化服务器参数得以解决, CLOSE_WAIT 状态过多很可能是程序自身的问题

##### 连接池
数据库层面的请求应答时间必须在 100ms 以内, 秒级的 SQL 查询通常存在巨大的性能提升空间, 通常有以下方案
- 建立高效且合适的索引
- 排查连接资源未显示关闭的情形
- 合并短的请求
- 合理拆分多个表 join 的 SQL, 如是超过三个表则禁止 join
- 使用临时表
- 应用层优化
- 改用其他数据库

#### 信息安全
黑客攻击手段大体可分为两种: 破坏性攻击和非破坏性攻击; 非破坏性攻击一般是为了扰乱系统的运行, 使之暂时失去正常对外提供服务的能力, 比如 DDoS 攻击; 破坏性攻击主要会造成两种后果, 系统数据受损或者信息被窃取, 比如 CSRF 攻击; 所以企业一般都要建立一套完整的信息安全体系, 遵循 CIA 原则: 保密性 (Confidentiality), 完整性(Interity), 可用性(Avaliability)
- 保密性: 对需要保护的数据进行保密操作, 无论是存储还是传输, 都要保证用户数据及相关资源的安全
- 完整性: 访问的数据需要是完整的, 而不是缺失的或者被篡改的
- 可用性: 服务需要是可用的

##### SQL 注入
- 过滤用户输入参数中的特殊字符, 从而降低被 SQL 注入的风险
- 禁止通过字符串拼接的 SQL 语句, 严格使用参数绑定传入的 SQL 参数
- 合理使用数据库访问框架提供的防注入机制

##### XSS 和 CSRF
- XSS: 跨站脚本攻击
TODO
- XSRF: 跨站请求伪造
TODO

##### HTTPS
TODO

#### 编程语言的发展
TODO
