### 计算机基础

#### 走进 0 与 1 的世界
计算机是二进制的世界, 在计算机中二进制整数都是以补码的形式出现的; 正数的补码和源码, 反码是一致的, 负数的补码是反码加 1 的结果  

###### 位移运算
在左移 << 和右移 >> 两种运算中, 符号位均参与移动, 除负数向右移动, 高位补 1 之外, 其他情况均在空位处补 0

| 正数/负数 | 向左移 << 1 位 | 向右移 >> 1 位 |
| :------------- | :------------- |:------------- |
| 正数 (35 的补码是 00100011) | 01000110 = 70 | 00010001 = 17 |
| 负数 (-35 的补码是 11011101) | 10111010 = -70 | 11101110 = -18 |
| 正数 (99 的补码是 01100011) | 11000110 = -58 | 00110001 = 49 |
| 负数 (-99 的补码是 10011101) | 00111010 = 58 | 11001110 = -50 |

左移运算由于符号位参与移动, 移动的结果中最左位可能是 1 或者 0, 所以正数负数移动后都有可能是正是负  
对于三个大于号的 >>> 无符号向右移动 (**注意不存在 <<< 无符号向左移动的运算方式**), 当向右移动时, 正负数高位均补 0, 正数不断向右移动的最小值是 0, 而负数不断向右移动的最小值是 1

| 正数/负数 | 向右移 >>> 1 位 | 向右移 >>> 2 位 | 向右移 >>> 3 位 |
| :------------- | :------------- |:------------- |
| 正数 (35 的补码是 00100011) | 00010001 = 17 | 00001000 = 8 | 00000100 = 4 |
| 负数 (-35 的补码是 11011101) | 01101110 = 110 | 00110111 = 55 | 00011011 = 27 |

在实际编程中, 位移运算仅作用于整型 (32) 和长整型 (64), 移动的位数是 mod 32 或 目的 64 的结果, 即 35 >>> 1 == 35 >>> 33, 所以正数不断向右移动的最小值是 0, 而负数不断向右移动的最小值是 1  

###### 逻辑与和逻辑或
逻辑与 (&&) 和逻辑或 (||) 有具有短路功能

#### 浮点数
