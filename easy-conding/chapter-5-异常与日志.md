### 异常与日志
如果异常在当前方法的处理范围之内, 并且没有必要向外透出, 那么就直接捕获异常并做相应处理, 否则直接向上抛出, 由上层方法或者框架来处理

#### 异常分类
```
             ---> Error                                  
             |                                           ---> 坦然处置型
Throwable ---|                                           |
             |                 ---> checked Exception ---|
             |                 |                         |
             ---> Exception ---|                         ---> 引起注意型
                               |                                              ---> 可预测异常
                               |                                              |
                               ---> unchecked Exception (RuntimeException) ---|--> 需捕捉异常
                                                                              |
                                                                              ---> 可透出异常
```

#### try 代码块
try-catch-finally 是异常处理的三部曲; 通常 finally 代码块没有执行可能有以下三种原因
- 没有进入 try 代码块
- 进入了 try 代码块, 但是代码运行中出现了死循环或者死锁状态
- 进入了 try 代码块, 但是执行了 System.exit() 操作

注意, finally 是在 return 表达式运行后执行的, 此时将要 return 的结果已经被暂存起来, 带 finally 代码块执行结束后再将之前暂存的结果返回  
try 代码块与锁的使用也要十分注意, lock() 方法可能会抛出 unchecked 异常, 如果放在 try 代码块中, 必然会触发 finally 中的 unlock() 方法执行; 对未加锁的对象解锁会抛出 unchecked 异常, 如 IllegalMonitorStateException, 虽然是因为加锁失败而造成程序中断的, 但是真正加锁失败的原因可能会被后者覆盖; 所以在 try 代码之前调用 lock() 方法避免由于加锁失败导致 finally 调用 unlock() 抛出异常
```
Lock lock = new ReentrantLock()
lock.lock();
try {
    ...
} finally {
    lock.unlock();
}
```

#### 异常的抛与接
- 对外提供的开放接口
推荐使用错误码
- 公司内部跨应用远程服务调用则优先考虑使用 Result 对象来封装错误码, 错误描述信息
远程调用时一旦调用方没有捕获就会产生运行时错误, 导致程序中断; 此外抛出的异常中不添加栈信息, 只是 new 自定义异常并加入自定义的错误信息, 对于调用端解决问题帮助并不会太大; 如果加了栈信息, 在频繁调用出错的情况下, 信息序列化和传输的性能损耗也是问题
- 应用内部
推荐直接抛出异常对象

防止 NPE 一定是调用方的责任, 一定需要查看所调用方法的说明

#### 日志
推荐的日志文件命名方式: appName_logType_logName.log  
由于日志可分为 DEBUG, INFO, WARN, ERROR, FATAL 五个不同的级别, 因此在打印日志时针对不同的级别要有不同的处理方式
- 预先判断日志级别
对于 DEBUG, INFO 级别的日志必须使用条件输出或者使用占位符的方式打印; 该约定综合考虑了程序运行效率和日志打印需求, 例如 `logger.debug("Processing trade with id: " + id + " and symbol: " + symbol);`, 那么该日志不会被打印时也会执行字符串拼接操作, 如果 symbol 是对象还需执行 toString() 方法, 白白浪费了系统资源
- 避免打印无效日志
生产环境禁止输出 DEBUG 日志且有选择地输出 INFO 日志; 控制日志输出量, 为日志文件设置合理的生命周期, 避免重复打印必须设置 additivity = false
- 区别对象错误日志
WARN, ERROR 都是与错误有关的日志级别, 但不要一发生错误就笼统的输出 ERROR 级别日志; ERROR 日志只记录系统逻辑错误, 异常或者违反重要的业务规则, 其他错误都可以归为 WARN 级别
- 保证记录内容完整
记录异常时一定要输出异常堆栈, 如果输出对象实例, 确保对象实现了 toString() 方法

##### 日志框架
日志框架分为三部分: 日志门面, 日志适配器, 日志库
```
--------------------     -----------------------------------------------
|    日志库适配器   |     |                 日志门面                     |
|   jul-to-slf4j   |  => |     slf4j                  commons-logging  |
|                  |     -----------------------------------------------
| log4j-over-slf4j |     -----------------------------------------------
|                  |     |              日志门面适配器                  |
|  jcl-over-slf4j  |     |  slf4j-jdk     slf4j-jcl     slf4j-log4j12  |
--------------------     -----------------------------------------------
------------------------------------------------------------------------
|                           日志库 (具体实现)                           |
| log4j             logback              log-jdk           其他日志库   |
------------------------------------------------------------------------
```
###### 日志门面
类似 JBDC 的设计理念, 值提供接口规范, 本身不负责日志功能的实现; 目前使用最为广泛的是 slf4j 和 commons-logging

###### 日志库
具体实现了日志的相关功能, 主流的日志库有: log4j, logback, log-jdk; 最早 Java 记录日志是通过 System.out 或 System.err() 来完成的, 非常不方便; 于是有了 log4j, 接着 JDK1.4 引入了一个日志库 java.util.logging.Logger (log-jdk), logback 是最晚出现的, 它与 log4j 是同一个作者, 是 log4j 的升级版且本身就实现了 slf4j 的接口

###### 日志适配器
- 日志门面适配器
因为 slf4j 规范是后续提出的, 此前实现的日志库是没有实现 slf4j 的接口的, 例如 log4j; 想在工程中使用 slf4j + log4j 的模式, 就额外需要一个适配器 (slf4j-log4j12) 来解决接口不兼容的问题
- 日志库适配器
在一些老的工程里, 一开始为了开发简单直接使用了日志库的 API 来完成日志打印, 随着时间推移想将原来直接调用日志库的模式改为标准的门面模式 (例如 slf4j + logback 组合), 但老工程中代码打印日志地方太多难以改动, 所以需要一个适配器来完成从旧日志库的 API dao slf4j 的路由, 这样在不改动原有代码的情况下也能使用 slf4j 来统一管理日志, 而且后续自由替换具体日志库也没问题

新工程推荐使用 slf4j + logback 组合, 因为 logback 自身实现了 slf4j 的接口, 无需适配器; 老工程通常使用的是 slf4j + slf4j-log4j12 + log4j 的组合, 如果直接使用的是 log4j 的代码库 API, 则还需引入 log4j-over-slf4j  的日志库适配器
