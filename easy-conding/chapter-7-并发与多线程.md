### 并发与多线程
在并发环境下, 由于程序性的封闭性打破, 出现了以下特点
- 并发程序之间有互相制约的关系
直接制约体现为一个程序需要另一个程序的计算结果; 间接制约体现为多个程序竞争共享资源
- 并发程序的执行过程是断断续续的
程序需要记忆现场指令以及执行点
- 当并发数设置合理并且 CPU 拥有足够的处理能力时, 并发会提高程序的运行效率

#### 线程安全
线程可以拥有自己的操作栈, 程序计数器, 局部变量表等资源; 与同一进程内的其他线程共享该进程的所有资源; 线程在生命周期内存在多种状态
- NEW, 即新建状态, 是线程被创建且未启动的状态
创建线程的方式有三种: 继承 Thread 类; 实现 Runnable 接口; 实现 Callable 接; 相比第一种更推荐使用第二种方式, 因为继承不符合里氏替换原则; Runnable 和 Callable 有两点不同: Callable 可以通过 call() 获得返回值, 其次可以抛出异常, 而 Runnable 只有通过 setDefaultUncaughtExceptionHandler() 的方式才能在主线程中捕捉到子线程的异常
- RUNNABLE, 即就绪状态, 是调用 start() 之后运行之前的状态
线程不能 start() 多次, 否则会抛出 IllegalStateException 异常
- RUNNING, 即运行状态, 是 run() 正在执行线程的状态
线程可能会由于某些因素而退出 RUNNING, 如时间, 调度, 锁等
- BLOCKED, 即阻塞状态, 进入此状态, 有以下几种情况
  - 同步阻塞: 锁被其他线程占用
  - 主动阻塞: 调用 Thread 的某些方法, 主动让出 CPU 执行权, 如 sleep(), join() 等
  - 等待阻塞: 执行了 wait() 等
- DEAD, 即终止状态, 是 run() 执行结束, 或因异常退出后的状态, 此状态不可逆转

保证高并发场景下的线程安全, 可以从以下四个维度考量
- 数据单线程内可见
单线总是安全的, 通过限制数据仅在单线程内可见, 可以避免数据被其他线程篡改
- 只读对象
只读对象总是安全的, 它的特性是允许复制, 拒绝写入
- 线程安全类
某些线程安全类的内部都有非常明确的线程安全机制
- 同步与锁机制
线程安全的核心理念就是 “要么只读, 要么加锁”; 合理利用 java.uitl.concurrent 包, 该包中主要有几个家族
  - 线程同步类: 这些类使线程之间协调更加容易, 支持了更加丰富的线程协调场景
  - 并发集合类: 集合并发操作的要求是执行速度快, 提取数据准确
  - 线程管理类: 各种线程池
  - 锁相关类: 锁以 Lock 接口为核心, 派生出在一些实际场景中进行互斥操作的锁相关类

#### 什么是锁
计算机中的锁开始是从悲观锁, 发展到后来的乐观锁, 偏向锁, 分段锁等; 锁主要提供了两种特性: 互斥性和不可见性; 因为锁的存在, 某些操作对外界来说是黑箱操作的, 只有锁的持有者才知道对变量进行了什么修改; Java 中常用锁实现的方式有两种

##### 用并发包中的锁类
