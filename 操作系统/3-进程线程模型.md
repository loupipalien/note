## 进程线程模型
### 目录

### 进程的基本概念
#### 多道程序设计
允许多个程序同时进入内存并允许, 其目的是为了提高系统的效率
#### 并发环境和并发程序
并发环境: 一段时间内, 单处理器上有两个或两个以上的程序同时处于开始运行但尚未结束的的状态并且**次序不是事先确定的**
进程: 是具有独立功能的程序关于某个数据集合上的一次运行活动, 是系统进行资源分配和调度的独立单位
  - 程序的一次执行过程
  - 是正在运行程序的抽象
  - 将一个 CPU 变幻成多个虚拟的 CPU
  - 系统资源以进程为单位分配, 每个进程具有独立的地址空间
  - 操作系统将 CPU 的调度给需要的进程
#### 进程控制块 PCB (Linux: task_struck; Windows: EPROCESS, KPROCESS, PEB)
- PCB 又称进程描述符或进程属性
  - 操作系统用于管理控制进程的一个专门的数据结构
  - 记录进程的各种属性, 描述进程的动态变化过程
- PCB 是系统感知进程存在的唯一标志
  - 进程和 PCB 是一一对应的
- 进程表是所有进程的 PCB 集合
#### PCB 包括的内容
- 进程的描述信息
  - 进程标识符 (PID), 唯一, 通常是一个整数
  - 进程名, 通常基于可执行文件名, 不唯一
  - 用户标识符 (UID)
  - 进程组关系
- 进程的控制信息
  - 当前状态
  - 优先级
  - 代码执行入口地址
  - 程序的磁盘地址
  - 运行统计信息 (执行时间, 页面调度)
  - 进程键同步和通信
  - 进程的队列指针
  - 进程的消息队列指针
- 进程所有用的资源和使用的情况
  - 虚拟地址空间的状况
  - 打开文件列表
- CPU 现场信息
  - 寄存器值 (通用寄存器, 程序计数器 PC, 程序状态字 PSW, 栈指针)
  - 指向该进程页表的指针

### 进程状态及状态转换
#### 进程的三种基本状态
- 运行态: 占有 CPU, 并在 CPU 上执行
- 就绪态: 已经具备运行条件, 但由于没有空闲 CPU, 而暂时不能运行
- 等待态: 因等待某一事件而暂时不能执行
#### 三状态模型及状态转换
- 就绪态到运行态
  - 调度程序选择一个新的程序
- 运行态到就绪态
  - 运行进程使用完了时间片
  - 一个高优先级进程进入就绪态抢占正在运行的进程
- 运行态到等待态
  - 当一个进程等待某个事件发生时
    - 请求 OS 服务
    - 对资源的访问尚不能进行
    - 等待 I/O 结果
    - 等待另一进程提供信息
    - ...
- 等待态到就绪态
  - 所等待的事件发生了
#### 进程的其他状态
- 创建态
  - 已完成创建一进程所必要的工作, 如 PID,PCB
  - 但由于资源有限等原因尚未同意执行该进程
- 终止态
  - 终止执行后, 进程进入该状态
  - 可完成一些数据统计工作
  - 资源回收
- 挂起态
  - 用于负载体调节
  - 进程不占用内存空间, 其进程映像交换到磁盘上
#### 五状态进程模型 (增加创建态和终止态)
#### 七状态进程模型 (增加就绪挂起态和阻塞挂起态)
#### 进程队列
- 操作系统为每一类进程建立一个或多个队列
- 队列元素为 PCB
- 伴随着进程状态的改变, 其 PCB 从一个队列进入到另一个队列
- 多个等待队列等待的事件不同
- 就绪队列也可以有多个
- 单 CPU 的情况下, 运行队列中往往只有一个进程

### 进程控制
进程控制操作完成进程个状态之间的转换, 由具有特定功能的原语 (完成某种特定功能的一段程序, 具有不可分割性或不可中断性, 即原语的执行必须是连续的, 在执行过程中不允许被中断) 完成
- 创建原语
- 撤销原语
- 阻塞原语
- 唤醒原语
- 挂起原语
- 激活原语
- 改变进程优先级
- ...
#### 进程的创建 (Unix: fork/exec; Windows: CreateProcess)
- 给新进程分配一个唯一标识以及进程控制块
- 为进程分配地址空间
- 初始化进程控制块, 设置默认值
- 设置相应的队列指针, 并把指针加入到队列链表中
#### 进程的撤销 (Unix: exit; Windows: TerminateProcess)
- 回收进程所占用的资源, 包括打开的文件, 网络来连接, 分配的内存等
- 撤销该进程的 PCB
#### 进程的阻塞 (Unix: wait; Windows: WaitForSingleObject)
处于运行状态的进程, 在其运行过程中期待某一事件发生, 如等待键盘输入, 等待磁盘数据传输完成, 等待其他进程发送消息; 当被等待的事件未发生时, 由**进程自己执行阻塞原语**, 使自己由运行态变为阻塞态
#### Unix 的几个进程控制操作
- fork(): 通过复制调用进程来建立新的进程, 是最基本的进程建立过程 (复制父进程)
- exec(): 包括一系列的系统调用, 它们都是通过用一段新的程序代码覆盖原来的地址空间, 实现进程执行代码的转换 (覆盖父进程)
- wait(): 提供初级进程同步操作, 能使一个进程等待另一个进程的结束
- exit(): 用来终止一个进程的运行
#### Unix 的 Fork() 实现
- 为子进程分配一个空闲的进程描述符 PCB - proc 结构
- 分配给子进程唯一的标识 pid
- 以一次一页的方式复制父进程的地址空间 (Linux 采用写时复制技术 Copy-On-Write 加快创建进程)
- 从父进程处继承共享资源, 如打开的文件和当前工作目录等
- 将子进程的状态设为就绪, 插入到就绪队列
- 向子进程返回标识符 0
- 向父进程返回子进程的 pid
#### 使用 Fork() 代码示例
```
#include<sys/types.h>
#include<stdio.h>
#include<unistd.h>

void main(int argc, char *argv[]) {
  // 创建一个子进程
  pid_t pid = fork();
  if (pid < 0) {
    // 创建子进程出错
    fprinth(stderr, "fork failed");
  } else if (pid == 0) {
    // 子进程
    execlp("/bin/ls", "ls", NULL);
  } else {
    // 父进程, 等待子进程结束
    wait(NULL);
    printf("child complete");
    exit(0);
  }
}
```

### 关于进程相关概念的讨论
#### 关于进程的讨论
- 进程的分类
  - 系统进程, 用户进程
  - 前台进程, 后台进程
  - CPU 密集型进程, I/O 密集型进程
- 进程层次结构
  - Unix 进程家族树: init 为根
  - Windows: 地位相同
#### 进程与程序的区别
- 进程更能准确刻画并发, 而程序不能
- 程序是静态的, 进程是动态的
- 进程由有生命周期, 有诞生有消亡
- 一个程序可对应多个进程
- 进程具有创建其他进程的功能
#### 进程地址空间
```
int myval;
int main(int argc, char *argv[]) {
  myval = atoi(argv[1]);
  while (1) {
    printf("myval is %d, loc 0x%lx\n", myval, (long) &myval);
  }
}
```
同时运行两个myval程序会发现 &myval 的值相同, 因为两个进程拥有不同的地址空间, 其中地址是逻辑地址即此地址空间的相对地址,而不是物理地址; 两个myval程序会发现 &myval 的值相同只是代表在两个地址空间中相对地址相同
- 内核地址空间 (0xFFFF...)
- 用户地址空间 (0x0000....)
  - 栈
  - 其他内容: 共享库, 内存映射文件 (SP)
  - 堆
  - 数据段 (myval)
  - 代码段 (PC)
#### 进程映像
对进程执行活动全过程的静态描述, 即某一时刻进程的亏快照; 由进程地址空间内容, 硬件寄存器内容以及与该进程相关的内核数据结构, 内核栈组成
- 用户相关: 进程地址空间 (包括代码段, 数据段, 栈和堆, 共享库等...)
- 寄存器相关: 程序计数器, 指令寄存器, 程序状态字寄存器, 栈指针, 通用寄存器等的值
- 内核相关:
  - 静态部分: PCB 以及各种资源数据结构
  - 动态部分: 内核栈 (不同进程在进入内核后使用不同的内核栈)
#### 上下文切换
将 CPU 硬件状态从一个进程换到另一个进程的过程称为上下文切换
- 进程运行时: 其硬件状态保存在 CPU 上的寄存器中;l 包括程序计数器, 程序状态寄存器, 栈指针, 通用寄存器, 其他控制寄存器的值
- 进程不运行时: 这些寄存器的值保存在进程控制块 PCB 中; 当操作系统要运行一个新的进程时, 将 PCB 中的相关值送到对应的寄存器中

### 线程的引入
#### 为什么引入线程
- 应用的需要 (Web 服务器的实现)

|模型|特性|
|-|-|
|单线程进程|无并发, 阻塞系统调用|
|有限状态机|有并发, 非阻塞系统调用, 中断|
|多线程|有并发, 阻塞系统调用|
- 开销的考虑

|进程|线程|
|-|-|
|进程相关操作时间空间开销大, 限制了并发度的提高|创建撤销线程开销小; 线程切换花费时间少; 线程之间互相通信无须调用内核 (同一进程捏的线程共享内存和文件)|
- 性能的考虑
多处理器的情况下, 一个进程中可以有多个线程 (**内核级线程**) 同时运行
#### 线程的基本概念
线程: 是进程多种的运行实体, 是 CPU 的调度单位 (继承进程的属性) , 有时将线程称为轻量级进程; 在同一进程中增加了多个执行序列 (线程)
#### 线程的属性
- 有标示的 ID
- 有状态以及状态的转换, 需要提供相应的操作
- 不运行时需要保存上下文, 程序计数器等寄存器
- 有自己的栈和栈指针
- 同一进程的所有线程共享进程的地址空间和其他资源
- 可以创建撤销另一个线程, 因为程序开始是以一个单线程进程方式运行的

### 线程机制的实现
- 用户级线程
  - 在用户空间创建线程库: 提供一组管理线程的过程
  - 运行时系统: 完成线程的管理工作 (操作, 线程表)
  - 内核管理的还是进程, 并不知道线程的存在
  - 线程切换不需要内核态特权
  - 实例: Unix (POSIX 线程库 - Pthread)

    |线程调用|描述|
    |-|-|
    |Pthread_create|创建一个新线程|
    |Pthread_exit|中断线程调用|
    |Pthread_join|等待指定线程退出|
    |Pthread_yield|释放 CPU 使其他线程运行, 因为系统时间片中断使对于进程而言, 所以线程不主动让出 CPU, 其他线程得不到机会运行|
    |Pthread_attr_init|创建并初始化一个新线程的属性结构|
    |Pthread_attr_destory|移除一个线程的属性结构|
  - 优点
    - 线程切换快
    - 调度算法是应用程序特定得
    - 用户级线程可以运行在任何操作系统上 (只需要实现线程库)
  - 缺点
    - 内核只将处理器分配给进程, 同一进程中得两个线程不能同时运行在两个处理器上 (**因为操作系统是不能感知用户级线程的, 能够在 CPU 上执行的实体必须是内核级线程, 用户级线程的运行必须有内核级线程作为载体**)
    - 大多数系统调用是阻塞的, 因此由于内核阻塞进程, 故进程一个线程的系统调用会阻塞进程中的所有线程
- 核心级线程
  - 内核管理所有线程, 并向引用程序提供了 API 接口
  - 内核维护进程和线程的上下文
  - 线程的切换需要内核的支持
  - 实例: Windows
- 混合模型
  - 线程创建在用户空间完成
  - 线程调度等在核心态完成
  - 实例: Solaris (多个用户级线程多路复用多个内核级线程)

### 重点
- 进程
  - 并发性
  - 动态性
  - 独立性
  - 交互性
  - 异步性
  - 进程映像
- 线程
  - 多线程应用场景
  - 线程基本概念和属性
  - 线程实现机制
- 可再入程序: 可被多个进程同时调用的程序, 具有以下性质: 程序是纯代码的, 即在执行过程中自身不被改变; 调用它的进程应该提供数据取  

### 相关章节
第 2 章: 2.1, 2.2 (除 2.2.8-2.210 外)

>**参考:**  
[用户级线程和内核级线程的区别联系](https://zhidao.baidu.com/question/533561621)  
[线程的3种实现方式--内核级线程, 用户级线程和混合型线程](http://blog.csdn.net/gatieme/article/details/51892437)  
[内核线程、轻量级进程、用户线程三种线程概念解惑（线程≠轻量级进程)](http://blog.csdn.net/gatieme/article/details/51481863)  
