## 处理器调度
### 目录

### CPU 调度的相关概念
- CPU 调度
其任务是控制, 协调进程对 CPU 的竞争; 即按一定的调度算法从就绪队列中选择一个进程, 把 CPU 的使用权交给被选中的进程; 如果没有就绪进程, 系统会安排一个系统空闲进程或 idle 进程上 CPU 运行
- 系统场景
  - N 个进程就绪, 等待上CPU 运行
  - M 个 CPU, M >= 1
  - 需要决策: 给哪一个进程分配哪一个 CPU
- CPU 调度要解决的三个问题
  - 调度算法 (WHAT): 按什么原则选择下一个要执行的进程
  - 调度时机 (WHEN): 何时进行选择
  - 调度过程 (HOW): 如何让被选中的进程上 CPU 运行
#### 调度的时机
事件发生 -> 当前运行的进程暂停运行 -> 硬件机制响应后 -> 进入操作系统, 处理相应的事件 -> 结束处理后:某些进程的状态会发生变化, 也可能又创建了一些新的进程 -> 就绪队形改变了 -> 需要进程调度根据预设的调度算法从就绪队列中选一个进程
- 进程正常终止或由于某种错误终止 (例如: 进程退出等进程控制操作, 或进程执行过程中出现 abort 异常)
- 新的进程创建或一个等待进程变成就绪 (例如: 进程创建等进程控制操作, 或进程等待的事件发生)
- 当一个进程从运行态进入阻塞态 (例如: 进程等待 I/O, I/O 中断)
- 当一个进程从运行态变为就绪态 (例如: 进程唤醒等进程控制操作, 或因为时间片用完或计时器到时的时钟中断)

**即往往是系统内核对中断/异常/系统调用处理后返回到用户态时**
#### 调度的过程 -- 进程切换
- 进程调度系统从就绪队列选择了要运行的进程: 这个进程可以是刚刚被暂停执行的进程, 也可能是另一个**新的进程 (进程切换)**
- 进程切换: 是指一个进程让出处理器, 由另一个进程占用处理器的过程
  进程切换主要包括两部分工作:
  - 切换全局页目录以加载一个新的地址空间
  - 切换内核栈和硬件上下文, 其中硬件上下文包括了内核执行新进程需要的全部信息, 如 CPU 相关寄存器
##### 上下文切换的具体步骤
场景: 进程 A 下 CPU, 进程 B 上 CPU
- 保存进程 A 的上下文环境 (程序计数器, 程序状态字, 其他寄存器...)
- 用新状态和相关信息更新进程 A 的 PCB
- 把进程 A 移至合适的队列 (就绪, 阻塞...)
- 把进程 B 的状态设置为运行态
- 从进程 B 的 PCB 中恢复上下文 (程序计数器, 程序状态字, 其他寄存器...)
##### 上下文切换的开销
- 直接开销: 内核完成切换所用的 CPU 的时间
  - 保存和恢复寄存器...
  - 切换地址空间 (相关指令比较昂贵)
- 间接开销
  - 高速缓存 (Cache), 缓冲区缓存 (Buffer Cache), TLB (Translation Lookup Buffer) 失效
#### 调度算法的设计
批处理系统 -> 多道程序设计系统 -> 批处理与分时的混合系统 -> 个人计算机 -> 网络服务器, 从计算机发展的过程来看调度算法的考虑的重点是不同的   
以下是从用户角度与和系统的通用角度来看调度算法需要考虑的角度:

|-|用户角度|系统角度|
|-|-|-|
|性能|周转时间; 响应时间; 最后期限|吞吐量; CPU 利用率|
|其他|可预测性|公平性; 强制优先级; 平衡资源|

##### 调度算法衡量指标
- 吞吐量 (Throughput): 每单位时间完成的进程数目
- 周转时间 (Turnaround Time): 每个进程从提出请求到运行完成的时间
- 响应时间 (Response Time): 从提出请求到第一次回应的时间
- 其他
  - CPU 利用率 (CPU Utilization): CPU 做有效工作的时间比例
  - 等待时间 (Waiting Time): 每个进程在就绪队列中等待的时间

### 设计调度算法要考虑的几个问题
- 进程控制块 PCB 中需要记录哪些与 CPU 调度有关的信息
- 进程优先级及就绪队列的组织
- 抢占式调度与非抢占式调度
- I/O 密集型与 CPU 密集型
- 时间片
#### 进程优先级
- 静态优先级: 进程创建时指定, 运行过程中不再改变
- 动态优先级：进程创建时指定了一个优先级, 运行过程中可以动态变化 (例如: 等待时间较长的进程可提升其优先级)
#### 进程就绪队列组织
- 按优先级排队
- 随着进程的运行降低进程的优先级
#### 抢占与非抢占
- 可抢占式 (Preemptive): 当有比正在运行的进程优先级更高的进程就绪时, 系统可强行剥夺正在运行进程的 CPU, 提供给具有更高优先级的进程使用
- 不可抢占式 (Non-Preemptive): 某一进程被调度运行后, 除非由于它自身的原因不能运行, 否则一直运行下去
#### I/O 密集型与 CPU 密集型
- I/O 密集型 (I/O-bound): 频繁的进行I/O, 通常会花很多时间等待 I/O 操作的完成
- CPU 密集型 (CPU-bound): 需要大量的 CPU 时间进行计算
#### 时间片
- 分配给调度上 CPU 的进程, 确定了允许该进程运行的时间长度
- 如何选择时间片需考虑的因素
  - 进程切换的开销
  - 对响应时间的要求
  - 就绪进程个数
  - CPU 能力
  - 进程的行为

### 批处理系统的调度算法
在批处理系统中调度主要考虑的因素
- 吞吐量
- 周转时间
- CPU 利用率
- 公平和平衡

####先来先服务 (FCFS-First Come First Serve)
按照进程就绪的先后顺序使用 CPUl; 非抢占式
- 优点
  - 公平
  - 实现简单
- 缺点
  - 长进程后的短进程需要等待很长时间, 不利于用户体验
#### 最短作业优先 (SJF-Shortest Job First)
具有最短完成时间的进程优先执行; 非抢占式
- 优点
  - 最短的平均周转时间 (前提: 在所有进程同时可运行时, 采用 SJF 调度算法可以得到最短的平均周转时间)
- 缺点
  - 源源不断的短作业的到来, 可能使长的任务长时间得不到运行, 产生 "饥饿现象"

#### 最短剩余时间优先 (STRN-Shortest Remaining Time Next)
具有最短完成时间的进程优先执行; 抢占式
**即 SJF 的抢占式版本**, 当一个新的就绪进程比当前运行进程具有更短的完成时间, 系统抢占当前进程, 选择子新就绪的进程执行

#### 最高响应比优先 (HRRN-Highest Response Ratio Next)
是考虑了先来先服务和短作业优先算法的综合算法, 调度时首先计算每个进程的响应比 R, 之后总是选择 R 最高的进程执行
```
响应比 R = 周转时间 / 处理时间
        = (处理时间 + 等待时间) / 处理时间
        = 1 + (等待时间 / 处理时间)  
```

### 交互式系统的调度算法
在交互式系统中调度主要考虑的因素
- 响应时间
- 公平和平衡
#### 轮转调度 (RR-Round Robin)
- 目标
  - 为短任务改善平均响应时间
- 解决思路
  - 周期性切换
  - 每个进程分配一个时间片
  - 时钟中断时轮换
##### 如何选择合适的时间片 (经验值: 10 - 100 ms, 通常为 50 - 60 ms)
- 太长 - 大于典型的交互时间
  - 降级为先来先服务算法
  - 延长短进程的响应时间
- 太短 - 小于典型的交互时间
  - 进程切换浪费 CPU 时间
##### 优缺点
- 优点
  - 公平
  - 有利于交互式计算, 响应时间快
  - 有利于不同大小的进程
- 缺点
  - 由于进程切换, 时间片轮转算法要花费比较高的开销
  - 不利于相同大小的进程
  - 不利于 I/O 型进程 (了解虚拟轮转调度算法 - Virtual Round Robin)
#### 最高优先级调度 (HFP-Highest Priority First)
选择优先级最高的进程投入运行
- 系统进程优先级高于用户进程; 前台进程优先级高于后台进程; 操作系统更偏好于 I/O 型进程
- 优先级可以是静态不变的, 也可以是动态调整的 (优先级可以用优先数表示)
- 就绪队列可以按照优先级组织
- 实现简单, 但也是不公平的, 会导致 "饥饿现象" 产生
##### 优先级反转问题 (基于优先级的抢占式)
一个低优先级进程持有一个高优先级进程所需要的资源, 使得高优先级进程等待低优先级进程运行
- 影响
  - 系统错误
  - 高优先级进程停滞不前, 导致系统性能降低
- 解决方案 (使得临界区中的低优先级进程运行完成以释放高优先级进行需要的资源)
  - 设置优先级上限 (将进入临界区的进程最高的优先级, 未进入临界区的进程优先级不可高于此)
  - 优先级继承 (当有未进入临界区的高优先级进程时, 临界区中的低优先级进程临时进程高优先级的优先级)
  - 使用中断禁止 (禁止进入临界区的进程被中断)

### 多级反馈队列调度算法, 各种调度算法小结
#### 多级反馈队列 (MFQ-Multiple Feedback Queue)
是 UNIX 的分支 BSD-5.3 版采用的调度算法, 是一个综合调度算法
##### 具体设计思想
- 设置多个就绪队列, 第一级队列优先级最高
- 给不同就绪队列中的进程分配长度不同的时间片; 第一级队列时间片最小, 随着队列优先级别的降低, 时间片增大
- 当第一级队列为空时, 在第二级队列调度, 以此类推
- 各级队列按照 **时间片轮转** 方式进行调度
- 当一个新创建进程就绪后, 进入第一级队列
- 进程用完时间片而放弃 CPU, 进入下一级就绪队列
- 由于阻塞而放弃 CPU 的进程进入相应的等待队列, 一旦等待的事件发生, 该进程回到原来一级就绪队列
##### 可派生点
- 被阻塞的进程回到原一级就绪队列
  - 对首还是对尾
  - 分配新的时间片还是上一次剩余的时间片
- 若允许抢占
  - 对首还是对尾
  - 分配新的时间片还是上一次剩余的时间片
#### 各种调度算法的比较

|调度算法|占用 CPU 方式|吞吐量|响应时间|开销|对进程的影响|饥饿问题|
|-|-|-|-|-|-|-|
|FCFS|非抢占|不强调|可能很慢, 尤其是当进程的执行时间差别较大时|最小|对短进程不利; 对 I/O 进程不利|无|
|Round Robin|抢占 (时间片用完时)|若时间片很小, 吞吐量会很低|为短作业提供良好的响应时间|最小|公平对待|无|
|SJF|非抢占式|高|为短进程提供好的响应时间|可能较大|对长进程不利|可能|
|SRTN|抢占 (新进程到达时)|高|提供好的响应时间|可能较大|对长进程不利|可能|
|HRRN|非抢占|高|提供好的响应时间|可能较大|很好的平衡|无|
|FeedBack|抢占 (时间片用完时)|不强调|不强调|可能较大|对 I/O 型进程有利|可能|
#### 多处理器调度算法设计考虑的问题
- 不仅要决定选择哪一个进程执行, 还需要决定哪一个 CPU 上执行
- 要考虑进程在多个 CPU 之间迁移时的开销
   - 高速缓存失效, TLB 失效
   - 尽可能的是同一个进程在 同一个CPU 上执行
- 负载均衡问题

### Windows 的线程调度算法
#### 典型系统所采用的调度算法
- Unix: 动态优先数法
- BSD-5.3: 多级反馈队列法
- **Linux**: 抢占式调度
- **Windows**: 基于优先级的抢占式多任务调度
- Solaris: 综合调度算法
#### Linux 调度算法历史
- Linux 2.4: 简单的基于优先级调度
- Linux 2.6: O(1) 调度器
- Linux 2.6: SD 调度器补丁
- Linux 2.6: RSDL 调度器补丁
- Linux 2.6: CFS 调度器
#### Windows 线程调度
- 因为 Windows 操作系统支持内核级线程, 所以调度单位是**线程**
- 采用基于动态优先级的, 抢占式调度, 结合时间配额的调整
##### 基本思想
- 就绪线程按优先级进入相应队列
- 系统总是选择优先级最高的就绪线程进行
- 同一优先级的各线程按时间片轮转进行调度
- 多 CPU 系统总允许多个线程并行运行
#### 引发线程调度的条件
- 线程正常终止或由于某种错误终止
- 新的线程创建或一个等待线程变成就绪
- 当一个线程从运行态进入阻塞态
- 当一个线程从运行态变为就绪态
- **一个线程的优先级改变了**
- **一个线程改变了它的亲和处理机集合**
#### 线程优先级
- 实时优先级 (16 - 31): 实时优先级线程不改变其优先级
- 可变优先级 (1 - 15): 其优先级可在一定范围内升高或降低, 可区分为**基本优先级**和**当前优先级**
- 系统线程 (0): 零页线程, 用于对系统中空闲的物理页面清零
#### 线程时间配额
- 时间配额不是一个时间长度值, 而是一个配额单位的整数
- 一个线程用完了自己的时间配额时, 如果没有其他相同优先级的线程, Windows 将重新给该线程分配一个新的时间配额, 让它继续运行
#### 线程调度策略
- 主动切换
- 抢占
  当线程被抢占时, 它被放回相应优先级的就绪队列的对首
  - 处于实时优先级的线程在被抢占时, 时间配额被重置为一个完整的时间配额
  - 处于可变优先级的线程在被抢占时, 时间配额不变, 重新得到 CPU 后将运行剩余的时间配额
- 时间配额用完
  - 线程的优先级没有降低
    - 如果队列中有其他就绪线程, 选择下一个线程执行, 此线程回到原来就绪队列末尾
    - 如果队列中没有其他就绪队列, 系统则给此线程分配一个新的时间配额, 让此线程继续运行
  - 线程的优先级降低了 (优先级曾今被提升过), Windows 将选择iyge更高优先级的线程运行
#### 线程优先级提升和时间配额调整
-  Windows 的策略调整
  - 如何体现对某类线程的倾向性
  - 如何解决由调度策略中潜在的不公平性而带来的 "饥饿现象"
  - 如何改善系统吞吐量, 响应时间等整体特征
- 解决方案
  - 提升线程优先级
  - 给线程分配一个更大的时间配额
##### 线程优先级提升场景
针对可变优先级的线程在下列五种场景下 Windows 会提升线程的当前优先级
- I/O 操作完成
- 信号量或事件等待结束
- 前台进程中的线程完成一个等待操作
- 由于窗口活动而唤醒窗口线程
- 线程处于就绪态超过了一定的时间还没有运行 - "饥饿现象"

### 重点
- 掌握处理器调度的相关概念
  - 调度时机, 进程切换
  - 调度指标: 吞吐量, 周转时间, 响应时间
  - 优先级/优先数, 抢占/非抢占, I/O型与CPU型
- 掌握主要的调度算法
  - 先来先服务, 短作业优先, 最高响应比优先
  - 时间片轮转, 最高优先级
  - 多级反馈队列
- 了解 Windows, 多处理器调度的基本思想

### 相关章节
第 2 章: 2.4
第 11 章: 11.4.3 中的调度部分
