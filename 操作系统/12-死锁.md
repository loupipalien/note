## 死锁
### 目录

### 死锁的基本概念
#### 死锁的定义
- 一组进程中, 每个进程都无限等待被该组进程中另一进程所占有的资源, 因而永远无法得到资源, 这种现象称为进程死锁, 这一组进程就被称为死锁进程; 如果死锁发生, 会浪费大量系统资源, 甚至导致系统崩溃
  - 参与死锁的所有进程都在等待资源
  - 参与死锁的进程是当前系统中所有进程的子集  
#### 为什么会出现死锁
- 资源数量有限, 锁和信号量错误使用
- 资源的额使用方式: "申请 -> 分配 -> 使用 -> 释放" 模式
- **可重用资源**: 可被多个进程多次使用
  - 可抢占资源与不可抢占资源
  - 处理器, I/O 部件, 内存, 文件, 数据库, 信号量
- 可消耗资源: 只可使用一次, 可创建和销毁的资源
  - 信号, 中断, 消息
#### 活锁或饥饿
- 活锁
  - 先加锁
  - 再轮询
  - 即无进展也没有阻塞(Peterson 算法, 死锁时进程处于等待状态不会竞争 CPU)
- 饥饿: 资源分配策略决定
#### 产生死锁的必要条件
- 互斥使用 (资源独占)
一个资源每次只能给一个进程使用
- 占有且等待 (请求和保持, 部分分配)
进程再申请新的资源的同时保持对原有资源的占有
- 不可抢占 (不可剥夺)
资源申请者不能强行的从资源占有者手中夺取资源, 资源只能由占有者自愿释放
- 循环等待
存在一个进程等待队列: $ \lbrace P_1, P_2, ..., P_n \rbrace $, 其中 $P_1$ 等待 $P_2$ 占有的资源, $P_2$ 等待 $P_3$ 占有的资源, ..., $P_n$ 等待 $P_1$ 占有的资源, 形成一个进程等待环路

### 资源分配图
使用有向图描述系统资源和进程的状态
二元组: G = (V, E)
- V: 节点的集合, 分为 P (进程), R (资源) 两部分
    - P = $ \lbrace P_1, P_2, ..., P_n \rbrace $
    - R = $ \lbrace R_1, R_2, ..., r_n \rbrace $
- E: 有向边的集合, 其元素为有序二元组, ($P_i$, $R_j$) 或 ($R_j$, $P_i$)
#### 资源分配图画法说明
系统由若干类资源构成, 一类资源称为一个资源类, 每个资源类中包含若干个同种资源, 称为资源实例
- 资源类: 用方框表示
- 资源实例: 用方框种的黑圆点表示
- 进程: 用圆圈种加进程名表示
- 分配边: 资源实例 -> 进程
- 申请边: 进程 -> 资源类
#### 死锁定理
- 如果资源分配图中没有环路, 则系统中没有死锁, 如果图中存在环路则系统中可能存在死锁
- 如果每个资源类中只包含一个资源实例, 则环路是死锁存在的充分必要条件
#### 资源分配图化简
- 找一个非孤立且只有分配边的进程节点去掉分配边, 将其变为孤立节点
- 再吧相应的资源分配给一个的等待该资源的进程, 即将该进程的申请边变为分配边
- 重复 1, 2 直到不能再进行, 这时如果所有进程节点都是孤立的则说明没有死锁

### 死锁预防
#### 解决死锁的方法
- 不考虑此问题 (鸵鸟算法)
- 不让死锁发生
  - 死锁预防
    - 静态策略: 设计子合适的资源分配算法, 不让死锁发生
  - 死锁避免
    - 动态策略: 以不让死锁发生为目标, 跟踪并评估资源分配过程, 根据评估结果决策是否分配
- 让死锁发生
  - 死锁检测与解除
#### 死锁预防
- 在设计系统时, 通过确定资源分配算法, 排除发生死锁的可能性
- 具体做法是: 防止产生死锁的四个必要条件中任何一个条件发生
  - 破坏 "互斥使用/资源独占" 条件
    - 资源转换技术: 把独占资源变为共享资源
      - SPOOLING 技术的引入
      解决不允许任何进程直接占有打印机的问题: 设计一个 "守护进程/线程" 负责管理打印机, 进程需要打印时, 将请求发给该 daemon, 由它完成打印任务
    - 破环 "占有且等待" 条件
      - 实现方案 1: 要求每个进程在运行前必须一次性申请它所要求的所有资源, 且当该进程所要资源均可满足时才给予一次性分配
        - 产生问题: 资源利用率低; "饥饿" 现象产生
      - 实现方案 2: 在允许进程动态申请资源前提下规定, 一个进程在申请新的资源不能立即得到满足而变为等待状态之前, 必须释放已占有的全部资源, 若需要再重新申请
        - 产生问题: "饥饿" 现象
    - 破坏 "不可抢占" 条件
      - 实现方案: 当一个进程申请的资源被其他进程占用时, 可以通过操作系统抢占这一资源 (两个进程优先级不同)
      - 局限性: 适用于状态易于保存和恢复的资源 (CPU, 内存)
    - 破坏 "循环等待" 条件
      - 通过定义资源类型的线性顺序实现
      - 实现方案: 资源有序分配法, 把系统中所有资源编号, 进程再申请资源时必须严格按照资源编号的递增次序进行, 否则操作系统不予分配

### 死锁避免
再系统运行过程中, 对进程发出的每一个系统能够满足的资源申请进行动态检查, 并根据检查结果决定是否分配资源, 若分配后系统发生死锁或可能发生死锁, 则不与分配, 否则给予分配
- 安全状态: 如果系统中存在一个由所有进程构成的安全序列 $ \lbrace P_1, P_2, ..., P_n \rbrace $, 则称系统处于安全状态, 安全状态一定没有死锁发生
- 安全序列: 一个进程序列 $ \lbrace P_1, P_2, ..., P_n \rbrace $ 是安全的, 如果对于每一个进程 $P_i (1 \leq i \leq n)$, 该进程后续需要的资源量不超过系统当前剩余资源量与所有进程 $P_j (j \leq i)$ 当前占有资源量之和

### 银行家算法
仿照银行发放贷款时采取的控制方式而设计的一种死锁避免算法
#### 应用条件
- 在固定数量的进程中共享数量固定的资源
- 每个进程预先指定完成工作所需的最大资源数量
- 进程不能申请比系统中可用资源总数还多的资源
- 进程等待资源的时间是有限的
- 如果系统满足了进程对资源的最大需求, 那么进程应该在有限的时间内使用资源, 然后归还给系统
#### 银行家算法数据结构
n: 系统中进程数量
m: 资源类数量
Available: array[1...m] 表示系统中每一类资源可分配的数量
Max: array[1...n, 1...m] 表示当前系统中进程对每一类资源的最大需求量
Allocation: array[1...n, 1...m] 表示当前系统中进程已获得的每类资源数量
Need: array[1...n, 1...m] 表示当前系统中进程还需要的每类资源数量
Request: array[1...n, 1...m] 表示当前系统中进程本次对每类资源申请数量
#### 银行家算法具体步骤
当进程 $P_i$ 提出资源申请时, 系统执行下列步骤
- 若 Request[i, 1...m] <= Need[i, 1...m] 则进行下一步, 否则报错返回
- 若 Request[i, 1...m] <= Available[1...m] 则进行下一步, 否则进程等待
- 假设系统分配了资源, 则有
  - Available[1...m] = Available[1...m] - Request[i, 1...m]  
  - Allocation[i, 1...m] = Allocation[i, 1...m] + Request[i, 1...m]  
  - Need[i, 1...m] = Need[i, 1...m] - Request[i, 1...m]  
- 对系统新状态进行**安全性检查**, 若系统新状态安全的则完成分配, 否则恢复为原来的状态, 该进程等待
#### 银行家算法安全性检查
- 数据结构如下
Work: array[1...m] 表示当前系统每类资源可分配的数量
Finish: array[1...n] 表示是否对此进程进行过安全检查
- 具体步骤
  1. Work[1...m] = Available[1...m]; Finish[1...n] = false;
  2. 寻找满足条件的进程 $P_i$: Finish[i] == false && Need[i, 1...m] <= Work[1...m], 如果存在则进行下一步, 否则跳转到 4
  3. 假设此进程完成将资源返还给系统 : Work[1...m] = Work[1...m] + Allocation[i, 1...m]; Finish[i] = true; 跳转到 2
  4. 若对所有的进程 $P_i$ 有 Finish[i] == true, 则系统处于安全状态, 否则系统处于不安全状态

### 死锁检测与解除
检测到死锁并以最小的代价恢复系统的运行
#### 死锁检测
- 允许死锁发生, 但操作系统会不断监视系统进展情况, 判断死锁是否真的发生
- 一旦死锁发生则采取专门的措施, 解除死锁并以最小的代价恢复操作系统运行
  - 检测时机
    - 当进程由于资源请求不满足而等待时检测死锁, 缺点是系统开销大
    - 定时检测
    - 系统资源利用率下降时检测死锁
#### 一个简单的死锁检测算法
- 每个进程, 每个资源指定唯一编号
- 设置一张资源分配表, 记录各进程与其占用资源之间的关系
- 设置一张进程等待表, 记录各进程与要申请资源之间的关系
- 选取一个等待的进程, 在这两张表中查找是否有循环等待
#### 死锁的解除
- 撤销所有死锁进程 (代价较大)
- 进程回退再启动 (系统需要保存进程的中间状态, 代价较大)
- 按照某种选择原则逐一撤销死锁进程, 直到...
- 按照某种选择原则逐一抢占资源 (资源被抢占的进程必须回退到之前的对应状态), 直到...

### 哲学家就餐问题
问题模型: 在应用程序中并发线程执行时, 协调处理共享资源
- 有五个哲学家围坐所在一圆桌旁, 桌子中央有一盘通心粉, 每个人面前有一个空盘子, 每两个人之间放一只筷子
- 每个哲学家的行为时思考, 感到饥饿, 然后吃通心粉
- 为了吃通心粉, 每个哲学家必须拿到两只筷子, 并且每个人只能直接从自己的左边或右边去取筷子 (筷子的互斥使用, 不能出现死锁现象)

#### 第一种解决方案
```
semaphore fork[5] = {1};
int i;
void philisopher(int i) {
  while(true) {
    think();
    P(fork[i]);
    // 每个进程都恰巧在这里被切换下 CPU, 那么就造成了死锁
    P(fork[(i + 1) mod 5]);
    eat();
    V(fork[(i + 1) mod 5]);
    V(fork[i]);
  }
}
void main() {
  parbegin(philisopher(0), philisopher(1), philisopher(2), philisopher(3), philisopher(4));
}
```

为了防止死锁的发生可以采取的措施
- 最多允许 4 个 哲学家同时坐在桌子周围
- 仅当一个哲学家左右两边的筷子都可用是, 才允许他拿筷子
- 给所有哲学家编号, 奇数号的哲学家必须先拿左边的筷子, 偶数号的哲学家反之
- ......
#### 第二种解决方案
```
semaphore fork[5] = {1};
// 抽屉法则, 必然会有一个哲学家可以拿到一双筷子从而完成进程
semaphore room = {4};
int i;
void philisopher(int i) {
  while(true) {
    think();
    P(room);
    P(fork[i]);
    // 每个进程都恰巧在这里被切换下 CPU, 那么就造成了死锁
    P(fork[(i + 1) mod 5]);
    eat();
    V(fork[(i + 1) mod 5]);
    V(fork[i]);
    V(room);
  }
}
void main() {
  parbegin(philisopher(0), philisopher(1), philisopher(2), philisopher(3), philisopher(4));
}
```
#### 第三种解决方案
```
monitor dining_controller;
cond ForkReadyp[5];
boolean fork[5]
```

### 重点
- 掌握死锁的基本概念
  - 理解产生死锁的四个必要条件
  - 理解死锁, 活锁, "饥饿" 的区别
- 掌握死锁的解决方案
  - 死锁预防: 资源的有序分配法
  - 死锁避免: 银行家算法, 安全/不安全状态
  - 死锁检测与解除
- 理解资源分配图及再解决死锁问题上的应用
- 理解哲学家就餐问题, 掌握解决哲学家就餐问题的各种方法

### 教材相关章节
第 6 章相关内容
