## I/O 系统
### 目录

### I/O 管理概述
#### I/O 的特点
- I/O 性能经常称为系统性能的瓶颈
- 操作系统庞大复杂原因之一
  - 各种设备传输差异很大
  - 各种应用
  - 控制接口的复杂性
  - 传送单位
  - 数据表示
  - 错误条件
- 与其他功能联系密切, 特别是文件系统
#### I/O 设备分类
- 按数据组织角度分类
  - 块设备: 以数据块为单位存储, 传输信息, 传输速率较高, 可寻址 (随机读写)
  - 字符设备: 以字符为单位存储, 传输信息, 传输速率低, 不可寻址
- 按资源分配角度分类
  - 独占设备: 在一段时间内只能有一个进程使用的设备, 一般为低速 I/O 设备 (如打印机, 磁带等)
  - 共享设备: 在一段时间内可有多个进程共同使用的设备, 多个进程以交叉的方式来使用设备, 其资源利用率高 (如硬盘)
  - 虚设备: 在一类设备上模拟另一类设备, 常用共享设备模拟独占设备, 用高速设备模拟低速设备, 被模拟的设备称为虚设备; 目的是将慢速的独占设备改造成多个用户可共享的设备提高设备的利用率 (如 SPOOLING 技术)
  #### I/O 管理的目标和任务
  - 按照用户的请求, 控制设备的各种操作, 完成 I/O 设备与内存之间的数据交换, 最终完成用户的 I/O 请求
    - 设备分配与回收
      - 记录设备的状态
      - 根据用户的请求和设备的类型, 采用一定的分配方法, 选择一条数据通路
    - 执行设备驱动程序, 实现真正的 I/O 操作
    - 外部设备的中断处理
    - I/O 缓冲区管理
- 建立方便, 统一的独立于设备的接口
  - 方便性: 向用户提供使用外部设备的方便接口, 使用户编程时无须考虑设备复杂的物理特性
  - 统一性：对不同的设备采取统一的操作方式, 即在用户程序中使用的是逻辑设备
    - 逻辑设备与物理设备
    - 屏蔽硬件细节 (设备的物理特性, 错误处理, 不同 I/O 过程的差异性)
- 充分利用各种技术 (通道, 中断, 缓冲, 异步 I/O 等) 提高 CPU 与设备, 设备与设备之间的并行工作能力, 充分利用资源, 提高资源利用率
  - 利用率
  - 均衡性 (使设备充分忙碌)
- 数据保护, 设备传送或管理的数据应该使安全的, 不被破坏的, 保密的

### I/O 硬件组成
#### I/O 设备一般是由机械和电子两部分组成
- 机械部分是设备本身 (物理装置)
- 电子部分又称设备控制器 (或适配器)
  - 端口地址译码
  - 按照主机与设备之间约定的格式和过程接受计算机发来的数据和控制信号, 或向主机发送数据或状态信号
  - 将计算机的数字信号转换成机械部分能识别的模拟信号, 或反之
  - 实现设备内部硬件缓冲, 数据加工等提高性能或增强功能
#### 设备接口控制器的作用
- 操作系统将命令写入控制器的接口寄存器 (或接口缓冲区) 中, 以实现输入/输出, 并从接口寄存器读取状态信息或结果信息
- 当控制器接受一条命令后, 可独立于 CPU 完成指定操作, CPU 可以另外执行其他计算: 命令完成时, 控制器产生一个中断, CPU 响应中断, 控制转给操作系统: 通过读控制器寄存器中的信息, 获得操作结果和设备状态
- 控制器与设备之间的接口常常是一个低级接口
- 控制器的任务: 把串行的流转换为字节块, 并进行必要的错误修正: 首先, 控制器按位进行组装, 然后存入控制器内部的缓冲区中形成以字节为单位的块: 在对块验证检查和并证明无错误时, 再将它复制到内存中
#### I/O 端口地址
- I/O 端口地址: 接口电路中每个寄存器具有的, 唯一的地址, 是个整数
- 所有 I/O 端口地址形成 I/O 端口空间 (受到保护)
- I/O 指令形式与 I/O 地址是相互关联的, 主要有两种形式
  - 内存映像编址 (内存映像 I/O 模式)
  - I/O 独立编址 (I/O 专用指令)
#### I/O 独立编址
- 分配给系统中所有端口的地址空间完全独立, 与内存地址空间无关
- 使用专门的 I/O 指令对端口进程操作
- 优点
  - 外设不占用内存的地址空间
  - 编程时, 易于1区分是对内存操作还是对 I/O 端口操作
- 缺点
  - I/O 端口操作的指令类型少, 操作不灵活
#### 内存映像编址  
- 分配给系统中所有端口的地址空间与内存的地址空间统一编址
- 把 I/O 端口看作使一个存储单元, 对 I/O 的读写操作等同于对内存的操作
- 优点
  - 凡是可对内存操作的指令都可对 I/O 端口操作
  - 不需要专门的 I/O 指令
  - I/O 端口可占有较大的地址空间
- 缺点
  - 占用内存空间
#### 内存映射 I/O 的优点
- 不需要特殊的保护机制来阻止用户进程执行 I/O 操作
- 可以引用内存的每一条指令也可以引用控制寄存器
#### 内存映射 I/O 的缺点
- 对一个设备控制寄存器不能进行高速缓存
- 考虑以下汇编代码循环, 第一次引用 PORT_4 将导致它被高速缓存, 随后的引用只从高速缓存中取值, 并且不会再查询设备, 之后当设备最终变为就绪时, 软件将没有办法发现这一点, 结果循环将会永远进行下去
- 为避免这一情形, 硬件必须针对每个页面具备选择性禁用高速缓存的能力, 操作系统必须管理选择性高速缓存, 所以这一特定为硬件和操作系统两者增添了额外的复杂性
```
LOOP: TEST PORT_4 // 检查端口 4 是否为 0
  BEQ READY       // 如果为 0, 转向 READY
  BRANCH LOOP     // 否则, 继续测试
READY:
```

### I/O 控制方式
- 可编程 I/O (轮询/查询)
由 CPU 代表进程给 I/O 模块发 I/O 命令, 进程进入忙等待, 直到操作完成才继续执行
- 中断驱动 I/O
为了奸商设备驱动程序不断地询问控制器状态寄存器的开销, I/O 操作结束后, 由设备控制器主动通知设备驱动程序
- DMA (直接存储器访问)

|-|无中断|使用中断|
|-|-|-|
|通过处理器实现, I/O 内存间的传送|可编程 I/O|中断驱动 I/O|
|I/O 内存间直接传送|-|直接存储器访问 (DMA)|

#### I/O 部件的演化 (性能/CPU 与 I/O 分离)
- CPU 直接控制外围设备
- 增加了控制器或 I/O 部件, CPU 使用非中断的可编程 I/O
- 与 2 相同, 但采用了中断的方式
- I/O 部件通过 DMA 直接控制存储器
- I/O 部件增强为一个单独的处理器, 有专门为 I/O 设计的指令集
- I/O 部件有自己的局部存储器 (其本身就是一台计算机)

### I/O 软件设计
分层的设计思想
- 把 I/O 软件组织成多各层次
- 每一层都执行操作系统所需要的功能的一个相关子集, 它依赖于更低一层所执行的更原始的功能, 从而可以隐藏这些功能的细节, 同时又给更高一层提供服务
- 较底层考虑硬件的特性, 并向较高层软件提供接口
- 较高层不依赖与硬件, 并向用户提供一个友好的, 清晰的, 简单的, 功能更强的接口
#### I/O 软件层次
- 用户级 I/O 软件
用户进程层执行输入输出系统调用, 对 I/O 数据进行格式化, 为假脱机输入/输出做准备
- 与设备无关的 OS 软件
独立于设备的软件实现设备的命名, 设备的保护, 成块处理, 缓冲技术和设备分配
  - 驱动程序的统一接口
  - 缓冲
  - 错误报告
  - 分配与释放设备
  - 提供与设备无关的块大小
- 设备驱动程序
设备驱动程序设置设备寄存器, 检查设备的执行状态
- 中断处理程序
中断处理程序负责 I/O 完成时, 唤醒设备驱动程序进程, 进行中断处理
- 硬件
硬件层实现物理 I/O 的操作
#### 设备独立性
用户编写的程序可以访问任意 I/O 设备, 无需事先指定设备; 在设备分配时有较好的灵活性, 易于实现 I/O 重定向
- 从用户角度: 用户在编制程序时, 使用逻辑设备名由系统事先从逻辑设备到物理设备的转换, 并实施 I/O 操作
- 从系统角度: 设计并实现 I/O 软件时, 除了直接与设备打交道的低层软件之外, 其他部分的软件不依赖硬件

### I/O 相关技术
缓冲技术可以解决的问题
- 解决 CPU 与 I/O 设备之间速度的不匹配问题
- 提高 CPU 与 I/O 设备之间的并行性
- 减少 I/O 设备对 CPU 的中断请求次数, 放宽 CPU 对中断响应时间的要求
#### 缓冲技术实现
- 缓冲区分类
  - 硬缓冲: 由硬件寄存器实现 (设备中设置的缓冲区, 如显卡缓冲)
  - 软缓冲: 在内存中开辟一个空间, 用作缓冲区
- 缓冲管理
  - 单缓冲
  - 双缓冲
  - 缓冲池 (多缓冲, 循环缓冲): 统一管理多个缓冲区, 采用有界缓冲区的生产者/消费者模型对缓冲池中的缓冲区进行循环使用
#### UNIX system v 缓冲技术
- 采用缓冲技术可平滑和加快信息在内存和磁盘之间的传输
  - 缓冲区结合提前读和延迟写技术对具有重复性及阵发性 I/O 进程, 提高 I/O 速度很有帮助
  - 可以充分利用之前从磁盘读入, 虽已传入用户区但仍在缓冲区的数据 (尽可能减少磁盘 I/O 的次数, 提高系统运行的速度)
- 缓冲区实现细节
  - 缓冲池: 200 个缓冲区 (512字节或1024字节)
  - 每个缓冲区由两部分组成: 缓冲控制块或缓冲首部 + 缓冲数据区 (系统通过缓冲控制块实现缓冲区的管理)
  - 空闲缓冲区队列 (av 链): 队列头部为 bfreelist
  - 设备缓冲队列 (b链): 链接所有分配给各类设备使用的缓冲区, 按照散列方式组织 (buf 用 b 双向链, 可以有 64 个队列, 每个队列首部有头标, 设备为 b_dev 上的逻辑块 b 在散列队列的头标为: i = (b_dev + b) mod 64)
- 缓冲区数据结构
  - 逻辑设备号和盘块号分别标志出文件系统和数据所在的盘块号, 是缓冲区的唯一标志
  - 状态标识缓冲区的当前状态: 忙/闲, 上锁/开锁, 是否延迟写, 数据有效性等
  - 两组指针 (av 和 b) 用于对缓冲池的分配管理
- 缓冲区的在 av 链和 b 链的场景
  - 开始: 在空闲 av 链 (缓冲区未被使用)
  - 开始 IO 请求: 在设备 IO 请求队列和设备 b 链
  - IO 结束: 在空闲 av 链和设备 b 链
#### UNIX system v 缓冲技术的使用
系统对缓冲区的分配时采用近似 LRU 算法
-  当进程想从指定的盘块读取数据时, 系统根据盘块号从设备 b 链 (散列队列) 中查找, 如找到缓冲区, 则将该缓冲区状态标记为 "忙", 并冲空闲 av 队列中取下, 并完成从缓冲区到内存用户区的数据传送
- 如果在设备 b 链中未找到时, 则从空闲 av 链队首取一个缓冲区插入到设备 I/O 请求队列, 并从原设备 b 链中取下, 插入由读入信息盘块号确定的新的设备 b 链中
- 当数据从磁盘块读入到缓冲区后, 缓冲区从设备 I/O 请求队列取下, 当系统完成从缓冲区到内存用户区的数据传送后, 要把缓冲区释放, 链入空闲 av 链队尾
- 当数据从磁盘块读入到缓冲区, 并传送到内存用户区后, 该缓冲区一直保留在原设备 b 链中, 即它的数据一直有效, 若又要使用它, 则冲空闲 av 链中取下, 使用完后插入到空闲 av 链队尾; 若一直未使用它, 则该缓冲区从空闲 av 链队尾慢慢升到队首, 最后被重新分配, 旧的盘块数据才被置换

### I/O 设备管理
#### 设备管理有关的数据结构
- 描述设备, 控制器等部件的表格: 系统中常常为每一个部件, 每一台设备分别设置一张表格, 常称为设备表或部件控制块; 这类表格具体描述设备的类型, 标识符, 状态, 以及当前使用者的进程标识符等
- 建立同类资源的队列: 系统为了方便对 I/O 设备的分配管理, 通常在设备表的基础上通过指针将相同物理属性的设备连成队列 (称为设备队列)
- 面向进程 I/O 请求的动态数据结构: 每当进程发出 I/O 请求时, 系统建立一张表格 (称 I/O 请求包), 将此次 I/O 请求的参数填入表中, 同时也将该 I/O 有关的系统缓冲区地址等信息填入表中; I/O 请求包随着 I/O 的完成而被删除
- 建立 I/O 队列: 如请求包队列
#### 独占设备的分配
在申请涉笔时, 如果设备空闲就将其独占, 不再允许其他进程申请使用, 一直等待该设备被释放, 才允许被其他进程申请使用; 需要考虑效率问题, 并避免由于不合理的分配策略造成死锁
- 静态分配: 在进程运行前完成设备的分配, 运行结束时收回设备, 缺点时设备利用率低
-动态分配: 在进程运行过程中, 当用户提出设备要求时才进行分配, 一旦停止使用则立即收回; 优点时效率好, 缺点是分配策略不好时产生死锁
#### 共享设备的分配
采用分时式共享策略
- 分时式共享就是以一次 I/O 请求为单位分时使用设备, 不同进程的 I/O 操作请求以排队的方式分时的占用设备进行 I/O
- 由于同时有多个进程同时访问, 且访问频繁, 就会影响整个设备使用效率, 影响系统效率; 因此要考虑多个访问请求到达时的服务顺序, 使平均服务时间越短越好
#### 设备驱动程序
- 与设备密切相关的代码放在设备驱动程序中, 每个设备驱动程序处理一种设备类型
- 一般的, 设备驱动程序的任务是接受来自与设备无关的上层软件的抽象请求, 并执行这个请求
- 每个控制器都设有一个或多个设备寄存器, 用来存放向设备发送的命令和参数, 设备驱动程序负责释放这些命令, 并监督它们正确执行
- 在设备驱动程序的进程释放一条或多条命令后, 系统有两种处理方式, 多数情况下, 执行设备驱动程序的进程必须等待命令完成, 这样在命令开始执行后它阻塞自己, 直到中断处理时它解除阻塞为止; 而其他情况下命令执行不必延迟就很快完成
#### 设备驱动程序与外界接口
- 操作系统的接口
为实现设备独立性, 设备作为特殊文件处理; 用户的 I/O 请求, 对命令的合法性检查以及参数处理在文件系统中完成, 在需要各种设备执行具体操作时, 通过相应数据结构转入不同的设备驱动程序
- 与系统引导的接口
初始化, 包括分配数据结构, 建立设备的请求队列
- 与设备的接口
#### 设备驱动程序接口函数
- 驱动程序初始化函数
向操作系统登记该驱动程序的接口函数, 该初始化函数在系统启动时或驱动程序安装入内核时执行
- 驱动程序卸载函数
- 申请设备函数
- 释放设备函数
- I/O 操作函数
对独占设备包含启动 I/O 的指令; 对共享设备将 I/O 请求形成一个请求包, 排到设备请求队列, 如果请求队列为空, 则直接启动设备
- 中断处理函数
对 I/O 完成作善后处理, 一般是唤醒等待刚完成的 I/O 请求的阻塞进程, 使其能进一步作后续工作; 如果存在 I/O 请求队列, 则启动下一个 I/O 请求
#### 一种典型的实现方案: I/O 进程
I/O 进程专门处理系统中的 I/O 请求和 I/O 中断工作
- I/O 请求进入
  - 用户程序: 调用 send 将 I/O 请求发送给 I/O 进程, 然后调用 block 阻塞自己, 直到 I/O 任务完成后被唤醒
  - 系统: 利用 weakup 唤醒 I/O 进程, 完成用户所要求的 I/O 处理
- I/O 中断进入
当 I/O 中断发生时, 内核中中断处理程序发一条消息给 I/O 进程, 由 I/O 进程负责判断并处理中断

#### I/O 进程的特性
- 是系统进程, 一般赋予最高优先级, 一旦被唤醒, 它可以很快的抢占处理机并投入运行
- I/O 进程开始运行后, 首先关闭中断, 然后用 receive 去接受消息
  - 没有消息: 则开中断, 将自己阻塞
  -  有消息: 则判断消息类型
    - I/O 请求: 准备通道程序, 发出启动 I/O 指令, 继续判断有无消息
    - I/O 进程: 进一步判断正常或异常结束
      - 正常: 唤醒要求进程 I/O 操作的进程
      - 异常: 转入相应的错误处理程序

### I/O 性能问题
- 使 CPU 利用率尽可能不被 I/O 降低
  - 缓冲技术
- 使 CPU 不等待 I/O
  - 异步 I/O
- 使 CPU 尽可能摆脱 I/O
  - DMA, 通道
#### 异步传输 I/O 的基本思想
- 系统实现
  - 通过切换到其他线程保证 CPU 的利用率
  - 对少量数据的 I/O 操作会引入切换的开销
- 用户实现
  - 将访问控制分成两段进行
  - 发出读取指令后继续做其他操作
  - 当需要读入的数据时, 再使用 wait 命令等待其完成
  - 不引入线程切换, 减少开销

### 重点
- 掌握 I/O 系统的概念
  - 理解 I/O 设备的特点及分类
  - 理解 I/O 管理的任务
- 掌握 I/O 管理的解决方案
  - 了解 I/O 硬件组成
  - 理解 I/O 控制方式
  - 掌握 I/O 软件层次及功能
- 掌握 I/O 相关技术
- 了解 I/O 性能提高的各种解决方案

### 教材相关章节
第 5 章: 5.1, 5.2, 5.4
