## 操作系统运行环境与运行机制
### 目录

### 处理器状态
#### 中央处理器(CPU)
处理器由运算器, 控制器, 一系列的**寄存器**以及高速缓存构成  

寄存器:
- 用户可见寄存器: 高级语言编译器通过优化算法分配并使用之, 以减少程序访问内存次数
- 控制和状态寄存器: 用于控制处理器的操作, 通常由操作系统代码使用
用于控制处理器的操作, 在某种特权级别下可以访问, 修改
常见的控制和状态寄存器
  - 程序计数器 (PC: Program Counter), 记录将要取出的指令的地址
  - 指令寄存器 (IR: Instruction Register), 记录最近取出的指令
  - 程序状态字 (PSW: Program Status Word), 记录处理器的运行状态, 一些条件码, 模式, 控制位等信息
#### 操作系统的需求 - 保护
操作系统并发共享的特征出发: 保护用户程序和用户程序之间互不干扰, 保护用户程序不对操作系统干扰, 因此对硬件提出实现保护和控制的要求
需要硬件提供的基本运行机制
- 处理器具有特权级别, 能在不同的特权级别运行不同的指令集合
- 硬件机制可将操作系统和用户程序之间隔离
#### 操作系统需要两种 CPU 状态
- 内核态 (Kernel Mode): 运行操作系统程序
- 用户态 (User Mode): 运行用户程序
指令集合
- 特权指令: 只能由操作系统使用, 用户程序不能使用的指令
启动 I/O, 内存清零, 修改程序状态字, 设置时钟, 是否允许中断, 停机
- 非特权指令: 用户程序可以使用的指令
控制转移, 算术计算, 取数指令, 访管指令 (使用从户态陷入内核态)
CPU 状态之间的转换
- 用户态到内核态: 唯一途径 -> 中断/异常/陷入机制
- 内核态到用户态: 设置程序状态字 PSW

### 中断与异常机制 (操作系统的驱动力)
#### 主要作用
- 及时处理设备发来的中断请求
- 可使操作系统捕获用户程序提出的服务请求
- 防止用户程序执行过程中的破坏性活动
- ...
#### 中断/异常的概念
- CPU 对系统发生的某个事件做出的一种反应
事件的发生改变了处理器的控制流
- CPU 暂停正在执行的程序, 保留现场后自动转去执行相应事件的处理程序, 处理完成后返回断点继续执行被打断的程序
中断和异常是随机发生的, 硬件自动完成控制流程转移工作, 被打断的事件可以恢复继续执行
#### 为什么引入中断与异常
中断的引入: 为了支持 CPU 和设备之间的并行操作
异常的引入: 表示 CPU 执行指令时本身出现的问题
事件
- 中断 (外中断): 外部事件, 正在运行的程序所不期望的
I/O 中断, 时钟中断, 硬件故障, ...
- 异常 (内中断): 由正在执行的指令引发的
系统调用, 页故障/页错误, 保护性异常, 断点指令, 程序性异常, ...
#### 中断和异常的小结

|类别|原因|异步/同步|返回行为|
|-|-|-|-|
|中断 Interrupt|来子 I/O 设备, 其他硬件部件|异步|总是返回到下一条指令|
|陷入 Trap|有意识安排的|同步|返回到下一条指令|
|故障 Fault|可恢复的错误|同步|返回到当前指令|
|终止 Abort|不可恢复的错误|同步|不会返回|

### 中断/异常机制工作原理
中断/异常机制是现代计算机系统的核心机制之一, 硬件和软件互相配合而使计算机系统得以充分的发挥能力
- 硬件该做什么事? -- 中断/异常响应
捕获中断源发出的中断/异常请求, 以一定方式响应, 将处理器控制权交给特定的处理程序
- 软件要做什么事? -- 中断/异常处理程序
识别中断异常类型, 完成对应的处理
#### 中断响应
发现中断, 接收中断的过程, 由中断硬件部件完成
1. 开始
2. 取下一条指令
3. 执行指令
  - 禁止中断: 到 2
  - 允许中断: 在每条指令执行周期的最后时刻扫描中断寄存器, 查看是否有中断信号, 若无中断信号则继续到 2, 若有中断信号到 4
4. 检查指令处理中断
中断硬件将该中断触发器内容按规定编码送入 PSW 的相应位, 称为中断码; 然后查询在中断向量表, 调出与此中断码对应的中断处理程序, 然后再到 2 执行中断处理程序
#### 中断向量表
中断向量表是由若干个中断向量组成
- 中断向量: 一个内存单元, 存放中断处理程序入口地址和程序运行时所需的处理机状态字
执行流程按中断号/异常类型的不同, 通过中断向量表把控制权转移给对应的中断处理程序
#### 中断处理程序
- 设计操作系统时, 为每一类中断/异常事件编好相应的处理程序, 并设置好中断向量表
- 系统运行时若响应中断, 中断硬件部件将 CPU 控制权转给中断处理程序
  - 保存相关寄存器信息 (PSW 和 PC 等寄存器信息被堆栈保存, 其他一些寄存器信息在中断程序中被保存)
  - 分析中断/异常的具体原因
  - 执行对应的处理功能
  - 恢复现场, 返回被事件打断的这个程序
#### 中断/异常机制小结
以设备输入输出为例
- 打印机给 CPU 发中断信号 (硬件)
- CPU 处理完当前指令后检测到中断, 判断出中断来源并向相关设备发确认信号 (硬件)
- CPU 开始为软件处理中断做准备 (硬件)
  - 处理器状态被切换到内核态
  - 在系统栈中保存被中断程序的重要上下文环境, 主要是程序计数器 PC, 程序状态字 PSW
- CPU 根据中断码查中断向量表, 获得与该中断相关的处理程序的处理程序的入口地址, 并将 PC 设置成该地址, 新的指令周期开始时, CPU 控制转移到中断处理程序 (硬件)
- 中断处理程序开始工作 (软件)
  - 在系统栈中保存现场信息
  - 检查 I/O 设备的状态信息, 操纵 I/O 设备或者在设备和内存之间床送数据等
- 中断处理结束时, CPU 检测到中断返回指令, 从系统栈中恢复被中断程序的上下文环境, CPU 状态恢复成原来的状态, PSW 和 PC 恢复成中断前的值, CPU 开始一个新的指令周期 (硬件)
#### I/O 中断处理程序
- I/O 操作正常结束
  - 若有程序正等待此次 I/O 的结果, 则应将其唤醒
  - 若要继续 I/O 操作, 需要准备好数据重新启动 I/O
- I/O 操作出现错误
  - 需要重新执行失败的 I/O 操作
  - 重试次数有上限, 达到时系统将判定硬件故障

### 中断/异常机制实例
#### 基本概念 - x86
- 中断
  - 由硬件信号引发的, 分为可屏蔽和不可屏蔽中断
 - 异常
  - 由指令执行引发的, 如除零异常
  - 80x86 处理器发布了大约 20 种不同的异常
  - 对于某些异常, CPU会在执行异常处理程序之前产生硬件出错码, 并压入内核态堆栈
- 系统调用
  - 异常的一种,  用户态到内核态的唯一入口
-  中断控制器 (PIC 或 APIC)
  - 负责将硬件的中断信号转换为中断向量, 并引发 CPU 中断
- 实模式: 中断向量表 (Interrupt Vector)
  - 存放中断服务程序的入口进地址
    - 入口地址 = 段地址左移 4 位 + 偏移地址
    - 不支持 CPU 运行状态切换
    - 中断处理与一般的过程调用相似
- 保护模式: 中断描述符表 (Interrupt Descriptor Table)
  - 采用门描述符数据结构来表示中断向量
- 中断向量表/中断描述符表
 - 四种类型门描述符
   - 任务门
   - **中断门**
     - 给出段选择符, 中断/异常程序的段内偏移量
     - 通过中断门后系统会自动禁止中断
   - **陷阱门**
     - 与中断门类似, 但通过陷阱门后系统不会自动禁止中断
   - 调用门  
#### 中断/异常的硬件处理过程
- 确定与中断或异常关联的向量 i
- 通过 IDTR 寄存器找到 IDT 表, 获得中断描述符 (表中的第 i 项)
- 从 GTDR 寄存器获得 GDT 的地址, 结合中断描述符中的段选择符, 在 GDT 表获取对应的段描述符, 从段描述符中得到中断或异常处理程序所在的段基址
- 特权级检查
- 检查是否发生了特权级的变化, 如果是则进行堆栈切换 (必须使用与新的特权级相关的栈)
- 硬件压栈, 保存上下文环境, 如果异常产生了硬件出错码, 也将它保存在栈中
- 如果是中断, 清 IF 位
- 通过中断描述符的段内偏移量和段描述符的基地址, 找到中断/异常处理程序的入口地址, 执行其第一条指令

### 系统调用机制
系统调用: 用户在编程时可以调用的操作系统功能
- 系统调用时操作系统提供给编程人员的唯一接口
- 使 CPU 状态从用户态陷入内核态
- 每个操作系统都提供了几百中系统调用
#### 系统调用机制设计
- 中断/异常机制: 支持系统调用服务的实现
- 选择一条特殊指令 (陷入指令): 引发异常, 完成用户态到内核态的转换
- 系统调用号和参数: 每个系统调用都事先给定一个编号(功能号)
- 系统调用表: 存放系统调用服务例程的入口地址
- 怎样实现用户程序的参数传递给内核
  - 由陷入指令自带参数: 陷入指令的长度有限, 且还要携带系统调用功能号, 只能自带有限的参数
  - 通过通用寄存器传递参数: 这些寄存器时操作系统和用户程序都能访问的, 但寄存器的个数会限制传递参数的数量
  - 在内存中开辟专用的区域传递参数
#### 系统调用执行过程
当 CPU 执行到特殊的陷入指令时
- 中断/异常机制: 硬件保护现场, 通过查**中断向量表**把控制权转给系统调用总入口程序
- 系统调用总入口程序: 保存现场, 将参数保存在内核态堆栈里, 通过查**系统调用表**把控制权转给相应的系统调用处理例程或内核函数
- 执行系统调用例程
- 恢复现场, 返回用户程序

### LINUX 系统调用实现 - 基于 x86 处理器
- 陷入指令选择 128 号: int $0x80
- 门描述符
  - 系统初始化: 对 IDT 表中的 128 号门初始化
  - 门描述符: 2,3 两个字节是内核代码段选择符; 0, 1, 6, 7 四个字节是偏移量
  - 门类型: 15 号是陷阱门
  - DPL: 3, 与用户态的特权级是一致的, 允许用户通过这个门描述符
#### 系统执行 int $0x80
- 由于特权级的改变, 要切换栈: 用户栈到内核栈
  - CPU 从任务状态段 TSS 中装入新的栈指针 (SS: ESP), 指向内核栈
- 用户栈的信息 (SS: ESP), EFLAGS, 用户态 CS, EIP 寄存器的内容压栈 (返回用户态时用)
- 将 EFLAGS 压栈后, 复位 TF, IF 位保持不变
- 用 128 在 IDT 中找到该门描述符, 从中找到段选择符装入代码段寄存器 CS
- 代码段描述符中的基地址 + 陷阱门描述符中的偏移量定位 system_call() 的入口地址
#### 中断发生后 OS 底层工作步骤
- **硬件**压栈: 程序计数器等
- **硬件**从中断向量装入心的程序计数器等
- **汇编语言**过程保存寄存器值
- **汇编语言**过程设置新的堆栈
- **C 语言**中断服务程序运行
- **进程调度程序**决定下一个将运行的进程
- **C 语言**过程返回至汇编代码
- **汇编语言**过程开始运行新的当前进程

### 重点
- 理解计算机系统的保护机制
  - 掌握处理器状态
  - 掌握特权指令与非特权指令
- 掌握中断/异常机制
  - 掌握中断/异常的基本概念
  - 掌握中断/异常机制的工作原理
- 掌握系统调用机制
  - 掌握系统调用设计原理
  - 掌握系统调用执行过程

### 相关章节
第 1 章: 1.3, 1.6
第 2 章: 52 页图 2-5 及说明该图思路的段落
