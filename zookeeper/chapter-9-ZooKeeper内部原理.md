### ZooKeeper 内部原理

#### 请求, 事务, 标识符
ZooKeeper 服务器会在本地处理只读请求 (exists, getData, getChildren), 这样可以提高集群处理读操作的性能; 哪些会改变 ZooKeeper 状态的客户端请求 (create, deletem, setData) 将会被转发给群首, 群首执行相应的请求, 并形成状态的更新, 这称之为事务; 其中请求表示源自客户端发起的操作, 而事务则包含了对应请求处理而改变 ZooKeeper 状态所需要执行的步骤  
当群首产生了一个事务, 就会为该事务分配一个标识符, 称之为 ZooKeeper 会话 ID (zxid), 通过 zxid 对事务进行标识, 就可以按照群首所指定的顺序在各个服务器中按序执行  
zxid 为一个 long 型 (64 位) 整数, 分为两部分: 时间戳 (epoch) 部分和计数器 (counter) 部分; 每个部分分为 32 位

#### 群首选举
群首为集群中的服务器选择出来的一个服务器, 并会一直被集群所认可; 设置群首的目的是为了对客户端所发起的 ZooKeeper 状态变更请求进行排序, 包括 create, delete, setData 操作; 群首将每一个请求转换为一个事务  
选举并支持一个群首的集群服务数量必须至少存在一个服务器进程的交叉, 使用属于仲裁 (quorum) 来表示这样一个进程的子集, 仲裁模式要求服务器之间两两相交  
每个服务器启动后进入 LOOKING 状态, 开始选举一个新的群首或查找已经存在的群首, 如果群首已经存在, 其他服务器就会通知这个新启动的服务器, 告知哪个服务器是群首, 新的服务器便会与群首建立连接, 以确保自己的状态与群首一致  
如果集群中所有的服务器均处于 LOOKING 状态, 这些服务器之间就会进行通信来选举一个群首, 通过信息交换对群首选举达成共识的选择, 胜出的服务器将会进入 LEADING 状态, 而集群中的其他服务器将会进入 FOLLOWING 状态  
对于群首选举的消息称之为群首选举通知消息 (leader election notification), 该协议非常简单, 当一个服务器进入 LOOKING 状态, 就会向集群中每一个服务器发送一个通知消息, 该消息中包含该服务器的投票, 投票中包含服务器标识符 (sid), 和最近执行的事务的 zxid 信息 (处于群首选举的目的, zxid 只有一个数字, 而在其他协议中, zxid 则有时间戳 epoch 和计数器组成)  
当一个服务器收到一个投票信息, 该服务器将会依据以下规则修改自己的投票信息
- 将接收的 voteId 和 voteZxid 作为一个标识符, 并获取接收方当前的投票中的 zxid, 用 myZxid 和 mySid 表示接收方服务器自己的值
- 如果 (voteZxid < myZxid) 或者 (voteZxid == myZxid 且 voteId > mySid), 则保留当前的投票信息
- 否则, 修改自己的投票信息, 将 voteZxid 赋值给 myZxid, voteId 赋值给 mySid

简而言之, 只有最新的服务器将赢得选举, 多个服务器 zxid 相同时, sid 最大的则称为赢家; 当一个服务器接收到的仲裁数量的服务器发来的投票都一样时, 表示群首选举成功; 如果群首是某个服务器本身, 则该服务器将会开始行驶群首角色, 否则将要先与群首建立连接, 与群首之间进行状态同步后, 才可以进行处理新的请求   
```
                                received (1,6) 和 (2,5)  change to (1,6)            elect 1
Server3 (3,5) ---------------------------------------------------------------------------->
                ^    | |      ^                                              ^   | |
                |    v |      | received (1,6) 和 (3,5)  change to (1,6)     |   v | elect 1
Server2 (2,5) ---------------------------------------------------------------------------->
                |      |    ^ |                                              |     |
                v      v    | | received (2,5) 和 (3,5)  not change          v     v elect 1
Server1 (1,6) ---------------------------------------------------------------------------->
```

#### Zab: 状态更新的广播协议
ZooKeeper 原子广播协议 (ZooKeeper Atomic Broadcast protocol, Zab), 通过该协议提交一个事务类似于一个两阶段的提交
- 群首向所有追随者发送一个 proposal 消息 p
- 当一个追随者接收到消息 p 后, 会响应群首一个 ack 消息, 通知群首其已接受该提案 (proposal)
- 当收到仲裁数量的服务器发送的确认消息后 (该仲裁包括群首自己), 群首就会发送消息通知追随者进行提交操作

Zab 保障了以下几个重要属性
- 如果群首按顺序广播了事务 T1 和事务 T2, 那么每个服务器在提交 T2 事务前保证 T1 已经提交完成
- 如果某个服务器按照事务 T1, T2 顺序提交事务, 所有其他服务器也必然会在提交事务 T2 前提交 T1

第一个属性保证事务在服务器之间的传送顺序是一致的, 而第二个竖向地保证了服务器不会跳过任何事务; Zab 在仲裁数量服务器中记录了事务, 集群中仲裁数量的服务器需要在群首提交事务前对事务达成一致, 而且追随者也会在硬盘中记录事务的确认信息  
ZooKeeper 自始至终并不总是有一个活动的群首, 因为群首服务器也可能崩溃或短时间地失去连接, 此时其他服务器需要选举一个新的群首来保证系统可用; 其中时间戳 (epoch) 的概念代表了管理权随时间的变化情况, 一个时间戳表示了某个服务器行驶管理权的这段时间, 在一个时间戳内, 群首会广播提案消息, 并根据计数器识别每一个消息  
时间戳的值在每次新群首选举发生的时候便会增加; 同一个服务器称为群首后可能持有不同的时间戳消息, 但从协议的角度出发, 一个服务器行驶管理权时, 如果持有不同的时间戳, 该服务器就会被认为是不同的群首; 另外, 集群还会存在群首并发的情况出现; 为了解决这写问题, Zab 协议提供了以下保障
- 一个被选举的群首确保在提交完所有之前的时间戳内需要提交的事务, 之后才开始广播新的事务
- 在任何时间点, 都不会出现两个被仲裁支持的群首

为了实现第一个需求, 群首并不会马上处于活动状态, 直到确保仲裁数量的服务器认可这个群首新的时间戳值; 在群首进行时间戳 e 的任何新的提案前, 必须保证自时间戳开始值到时间戳 e - 1 内的所有提案被提交  
对于第二个需求, 因为不能完全阻止两个群首独立的运行; 假如一个群首 L1 管理并广播事务, 在此时仲裁数量的服务器 Q 判断群首 L2 已经退出, 并开始选举了一个新的群首 L2, 假设在仲裁机构 Q 放弃群首 L1 时有一个事务 T 正在广播, 而且仲裁机构 Q 的一个严格子集也记录了这个事务 T, 为 T 形成了一个仲裁数量, 在这种情况下事务 T 在群首 L2 被选举后会进行提交; Zab 协议保证 T 作为事务的一部分被群首 L2 提交, 确保群首 L2 的仲裁数量的支持者中至少有一个追随者确认了该事务 T, 其中关键点在于群首 L1 和 L2 在同一时刻并未获得足够的仲裁数量的支持者  
下图说明了这一场景, 在图中群首 L1 为服务器 S5, L2 为服务器 S3, 仲裁机构由 S1 - S3 组成, 事务 T 的 zxid 为 (1, 1); 在收到第二个确认消息之后, 服务器 S5 成功向服务器 S4 发送了提交消息来通知提交事务; 其他服务器因追随服务器 S3 忽略了服务器 S5 的消息, 此时服务器 S3 所了解的 xzid 为 (1,1), 因此它知道获得管理权后的事务点
```     
            propose(1,1)   accept(1,1)  accept(1,1)    commit
Server5 -------------------------------------------------------------------------->
         ^    | | | |          ^             ^     (3)    |
         |    v | | |          |             |            v
Server4 -------------------------------------------------------------------------->
         ^      | | |          |
         |      v | |          |
Server3 -------------------------------------------------------------------------->
         ^        | |                  ^
         |        v |                  |
Server2 -------------------------------------------------------------------------->
         ^          |                  ^
         | (1)      v                  | (2)
Server1 -------------------------------------------------------------------------->
     fllow S5                      follow S3
(1): 选中 S5 并且 S1 - S5 追随 S5
(2): 选中 S3 并且 S1 - S2 追随 S3
(3): 服务器 S5 接受来自 S4 的确认消息, 选中服务器 S3 并且获得一个仲裁支持 (S1 - S3) 后形成一个响应仲裁
```
在新的群首 L2 生效前, 它必须学习仲裁数量服务器之前接受的所有提议, 并且保证这些服务器不会继续接受来自旧群首的提议; 此时如果群首 L1 还能继续提交提议, 比如 (1,1), 这条提议必须已经被一个以上的认可了群首的仲裁数量服务器所接受, 由于仲裁服务器必须在一台以上的服务器之上有所重叠, 这样群首 L1 用来提交的仲裁数量和新群首 L1 使用的仲裁数量必定有一台以上的服务器是一致的; 因此 L2 将 (1,1) 加入自身的状态并传播给其跟随者  
在群首选举时, 由于选择了 zxid 最大的服务器作为群首, 这使得 ZooKeeper 不需要将提议从追随者传到群首, 而只需要将状态从群首传播到追随者即可  
在时间戳发生转换时, ZooKeeper 使用两种不同的方式来更新追随者来优化这个过程; 如果追随者滞后于群首不多, 群首只需要发送缺失的事务点; 因为追随者严格按照顺序接收事务点, 这些缺失的事务点永远是最近的, 这种更新称之为 DIFF; 如果滞后很久, ZooKeeper 将发送完整的快照 SNAP, 要注意的是发送完整的快照会增大系统的延时

#### 观察者
除了群首和追随者之外, 还有观察者的角色; 观察者与追随者之间有一些共同点, 即它们提交来自群首的提议, 不同于追随者的是, 观察者不参与选举过程, 仅仅学习经由 INFORM 消息提交的提议; 参与决定了那条提议被提交的投票的服务器被成为是 PARTICIPANT 服务器, 它可以是群首也可以是追随者, 而观察者被称为 OBSERVER 服务器  
引入观察者的主要原因是提高请求的可扩展性, 通过加入多个观察者, 可以在不牺牲写操作的吞吐率前提下服务更多的读操作; 写操作的吞吐率取决于仲裁数量的大小, 如果增加更多参与投票的服务器将会减少写操作的吞吐率; 增加观察者的的开销仅在于对应于每个已提交事务点引入一条额外的消息  

#### 服务器的构成
TODO
