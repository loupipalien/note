### 了解 ZooKeeper

#### ZooKeeper 基础
ZooKeeper 采用类似于文件系统的层级树状结构进行管理数据, 其中的节点称作为 znode

##### API 概述
znode 节点可能含有数据, 也可能没有; 如果一个 znode 节点包含任何数据, 那么数据存储为字节数组, 其中字节数组的格式特定于每个应用的实现, ZooKeeper  并不直接提供解析支持; ZooKeeper 的 API 暴露了以下方法

| 方法 | 描述 |
| :--- | :--- |
| create /path date | 创建一个名为 /path 的 znode 节点, 并包含数据 data |
| delete /path | 删除名为 /path 的 znode |
| exist /path | 检查是否存在名为 /path 的节点 |
| setData /path data | 设置名为 /path 的 znode 的数据为 data |
| getData /path | 返回名为 /path 节点的数据信息 |
| getChildren /path | 返回 /path 节点的所有子节点列表 |

需要注意的是, ZooKeeper 不允许局部写入或读取 znode 节点的数据, 只能整个替换和读取

##### znode 的不同类型
当新建 znode 时, 还需要指定节点的类型, 不同类型决定了 znode 节点的行为方式

###### 持久节点和临时节点
znode 节点可以是持久节点 (persistent) 节点, 还可以是临时 (ephemeral) 节点; 持久的 znode 只能通过调用 delete 来进行删除, 而临时节点不但可以通过调用 delete 删除, 当创建该节点的客户端崩溃或者关闭了与 ZooKeeper 的连接时, 临时节点就会被删除

###### 有序节点
一个 znode 还可以设置为有序 (sequential) 节点, 一个有序 znode 节点被分配唯一一个单调递增的整数; 有序 znode 通过提供了创建具有唯一名称的 znode 的简单方式, 同时也通过这种方式可以直观的查看 znode 的创建顺序  
总之 znode 有四种类型: 持久的 (persistent), 临时的 (ephemeral), 持久有序的 (persistent sequential), 临时有序的 (ephemeral sequential)

##### 监视与通知
ZooKeeper 通常以远程服务的方式被访问, 如果每次访问 znode 时, 客户端都需要获得节点中的内容, 这样会导致较高的延迟, 而且 ZooKeeper 需要更多的操作; 考虑以下的例子
```
                                            create /tasks/task-1
Client C1 ------------------------------------------------------------------------>
                                                    | (3)
                                                    v
ZooKeeper ------------------------------------------------------------------------>
                ^   (1)  |        ^   (2)  |              ^     (4)   |
                |        v        |        v              |           v
Client C2 ------------------------------------------------------------------------>
          getChildren   {}  getChildren   {}         getChildren   {task=1}
(1): 客户端 C2 读取任务列表, 其初始值为空
(2): 客户端 C2 再次读取任务列表, 看是否有新任务
(3): 客户端 C1 创建了一个新任务
(4): 客户端 C1 再次读取任务列表, 并发现了变化
```
这是一个常见的轮询问题, 为了替换客户端的轮询, 可以选择基于通知的机制: 客户端向 ZooKeeper 注册需要接受通知的 znode, 通过对 znode 设置监视点 (watch) 来接收通知; 监视点是一个单次触发的操作, 意即监视点会触发一个通知, 为了接收多个通知, 客户端必须在每次通知后设置一个新的监视点
```
                           create /tasks/task-1
Client C1 ------------------------------------------------------------------------>
                                  |
                                  v
ZooKeeper ------------------------------------------------------------------------>
                ^   (1)  |             (2)  |          ^     (3)   |
                |        v                  v          |           v
Client C2 ------------------------------------------------------------------------>
            getChildren   {}                       getChildren   {task=1}
(1): 客户端 C1 读取任务列表, 其初始值为空, 并设置一个监控变更的监视点
(2): 当发生变化时通知客户端
(3): 客户端 C2 读取 /tasks 的子节点, 以发现新任务
```
通知机制是单次触发的操作, 所以在客户端接收一个 znode 变更通知并设置新的监视点时, znode 节点也许发生了新的变化, 但客户端并不会错过这些变化
- 客户端 C1 设置监视点来监控 /tasks 数据的变化
- 客户端 C1 连接后, 向 /tasks 中添加了一个新的任务
- 客户端 C1 接受通知
- 客户端 C1 设置新的监视点, 在设置完成前, 第三个客户端 C3 连接后, 向 /tasks 中添加一个新的任务
客户端 C1 最终设置了新的监视点, 但由于 C3 添加数据的变更并没有触发一个通知, 为了观察这个变更, 在设置新的监视点前, C1 实际上需要读取节点 /tasks 的状态, 通过在设置监视点前读取 ZooKeeper 的状态, 最终 C1 就不会错过任何变更  
ZooKeeper 可以定义不同类型的变更, 这依赖于设置监视点对应的通知类型

##### 版本
每一个 znode 都有一个版本号, 它随着每次数据变化而自增; 两个 API 操作可以有条件的执行: setData 和 delete; 这两个调用以版本号作为转入参数, 只有当转入参数的版本号与服务器上的版本号一致时才会调用成功, 当多个客户端对同一个 znode 进行操作时显得尤为重要
```
                setData /config (1)                                setData y version = 2
Client C1 --------------------------------------------------------------------------------------------->
          version = 1 |  ^                                                     | Incorrent version
                      v  | version = 2               /config version = 3       v       Failed!
ZooKeeper --------------------------------------------------------------------------------------------->
                              ^          |                   ^
                              |          v                   |
Client C2 --------------------------------------------------------------------------------------------->
                           getData x, version = 2    setData y version = 2
```

#### ZooKeeper 架构
ZooKeeper 服务端运行于两种模式下: 独立模式 (standalone) 和仲裁模式 (quorum); 独立模式下只有单个服务器, ZooKeeper 的状态无法复制; 在仲裁模式下, 具有一组 ZooKeeper 服务器, 称之为 ZooKeeper 集合, 它们之间可以进行状态的复制, 并同时服务于客户端的请求

##### ZooKeeper 仲裁
在仲裁模式下, Zookeeper 复制集群中的所有服务器的数据树, 但如果让一个客户端等待每个服务器完成数据保存后再继续, 延迟问题将无法接受; 在公共管理域, 法定人数是指进行一项投票后所需要的立法者的最小数量, ZooKeeper 中这个数量为正常服务器个数的一半加一, 即遵循多数原则

##### 会话
客户端通过 TCP 协议与服务端进行连接并通信, 但当会话无法与当前连接的服务器继续通信时, 会话就可能转移到另一个服务器上, ZooKeeper 客户端会被透明的转移一个会话到不同的服务器

#### 开始使用 ZooKeeper
TODO

##### 会话的状态和声明周期
会话的主要状态是简单明了的: NOT_CONNECTED, CONNECTING, CONNECTED, CLOSED
```
                               |------------------------------------|
                               |                                    v
-----------------       --------------       -------------      ----------
| NOT_CONNECTED |  ---> | CONNECTING | <---> | CONNECTED | ---> | CLOSED |
-----------------       --------------       -------------      ----------
```
一个会话从 NOT_CONNECTED 状态开始, 当 ZooKeeper 客户端初始化后转换到 CONNECTING 状态, 正常情况下成功与 ZooKeeper 服务器建立连接后, 会话转到 CONNECTED 状态, 当客户端与 ZooKeeper 服务器断开连接或者无法接收到服务器的响应时, 就会转回到 CONNECTING 的状态, 并尝试发现其他 ZooKeeper 服务器, 如果可以发现另一个服务器或者重连到原来的服务器, 当服务器确认会话有效后, 状态又会转换回 CONNECTED 状态, 否则会话过期转换到 CLOSED 状态  
创建会话时需要设置会话超时时间参数, 这个参数设置了 ZooKeeper 服务允许会话被声明为超时之前存在的时间; 如果经过时间 t 之后服务接收不到这个会话的任何消息, 服务就会声明会话过期; 而在客户端侧, 如果经过 t/3 的时间未收到任何消息, 客户端将会向服务端发送心跳消息, 在经过 2t/3 的时间后, ZooKeeper 客户端开始寻找其他的服务器, 此时它还有 t/3 的时间去寻找  
客户端在重连的情况下使用事物标识符 (zkid), 当客户端因超时与 s1 断开连接后, 客户端开始尝试连接 s2, 但 s2 延迟于客户端所知的变化, 然而 s3 对这个变化的情况与客户端保持一致, 所以 s3 可以安全连接
```
                    zkid = 1                  zkid = 2
Server3 ------------------------------------------------------------------------------>
                                                          ^      |
                                   zkid = 1               |      |   zkid = 2
Server2 ------------------------------------------------------------------------------>
                                   ^      |               |      |
                    zkid = 1       |      |   zkid = 2    |      |
Server1 ------------------------------------------------------------------------------>
           ^     |  ^     |        |      |               |      |
           | (1) v  | (2) v  (3)   | (4)  v               | (5)  v
Client1 ------------------------------------------------------------------------------>
                  create node       not ok                ok, connect
(1): 客户端连接 S1
(2): 客户端执行创建操作, 操作成功并获得服务器分配的 zkid 1
(3): 客户端与 S3 断开
(4): 客户端尝试连接 S2, 但是服务器有一个较低的 zkid
(5): 客户端尝试连接 S3 并成功
```

##### ZooKeeper 与仲裁模式
TODO

##### 实现一个原语: 通过 ZooKeeper 实现锁
假设有一个应用有 n 个进程组成, 这些进程尝试获取一个锁, 这里使用 ZooKeeper 的 znode 实现; 为了获得一个锁, 每个进程 p 尝试创建名为 /lock 的 znod, 如果成功创建了 znode, 就表示获得了一个锁, 并可以继续执行其临界区的代码, 完成后删除该 znode; 不过一个潜在的问题是进程 p 可能崩溃, 导致这个锁永远无法释放, 在这种情况下, 没有任何其他进程可以再次获得这个锁, 整个系统则因死锁而阻塞; 为了避免这种情况, 则把 /lock 创建为临时节点

#### 一个主从模式例子的实现
TODO

#### 小结
TODO
