### 虚拟机类加载机制
代码编译的结果从本地机器码转变为字节码, 是存储格式发展的一小步, 却是编程语言发展的一大步

#### 概述
虚拟机把描述类的数据从 Class 文件加载到内存, 并对数据进行校验, 转换解析和初始化, 最终形成可以被虚拟机直接使用的 Java 类型, 这就是虚拟机的类加载机制  
与那些在编译时需要进行连接工作的语言不同, Java 语言里的类型加载, 连接, 初始化过程都是在程序运行期间完成的, 这种策略虽然会令类加载时稍微增加一些性能开销, 但是会为 Java 应用程序提供高度的灵活性, Java 天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的  

#### 类加载的时机
类从被加载到虚拟机内存中, 到卸载出内存为止, 它的整个生命周期包括: 加载 (Loading), 验证 (Verification), 准备 (Preparation), 解析 (Resolution), 初始化 (Initialization), 使用 (Using), 卸载 (Unloading) 7 个阶段; 其中验证, 准备, 解析 3 个部分统称为连接 (Linking)  
加载, 验证, 准备, 初始化和卸载这 5 个阶段的顺序是确定的, 类的加载过程必须按照这种顺序按部就班的开始, 而解析阶段则不一定: 它在某些情况下可以在初始化阶段之后再开始, 这是为了支持 Java 语言的运行时绑定 (也称为动态绑定或晚期绑定); 什么情况下需要开始类加载过程的第一个阶段: 加载? Java 虚拟机规范中并没有进行强制约束, 这由虚拟机的具体实现来自由把握; 但对于初始化阶段, 虚拟机规范则是严格规定了**有且只有** 5 种情况必须立即对类进行 "初始化" (加载, 验证, 准备自然要在此之前进行)  
- 遇到 new, getstatic, putstatic, invokestatic 这 4 条字节码指令是, 如果类没有进行过初始化, 则需要先触发初始化; 生成这 4 条指令的最常见的 Java 代码场景是: 使用 new 关键字实例化对象时, 读取或设置一个类的静态字段 (被 final 修饰, 已在编译器把结果放入常量池的静态字段除外) 时, 以及调用一个类的静态方法时
- 使用 java.lang.reflect 包的方法对类进行反射调用的时候, 如果类没有进行过初始化则需要先触发初始化
- 当初始化一个类时, 如果发现其父类还没有进行过初始化, 则需要先触发其父类的初始化
- 当虚拟机启动时, 用户需要指定一个执行的主类 (包含 main 方法的那个类), 虚拟机会先初始化这个主类
- 当使用 JDK 1.7 的动态语言支持时, 如果一个 java.lang.invoke.MethodHandle 实例最后解析结果 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄, 并且这个方法句柄所对应的类还没有进行过初始化, 则需要先触发其初始化

对于以上 5 种会触发类进行初始化的行为称为对一个类进行主动引导; 除此之外, 所有引用类的方式都不会触发初始化, 称为被动引用
- 通过子类引用父类的静态字段, 不会导致子类初始化
- 通过数组定义来引用类, 不会触发此类的初始化
- 常量在编译阶段会存入调用类的常量池中, 本质上并没有直接引用到定义常量的类, 因此不会触发定义常量的类的初始化

接口的加载过程与类加载过程稍有不同, 针对接口需要做一些特殊说明: 接口也有初始化过程, 编译器会为接口生成 "<clinit>()" 类构造器, 用于初始化接口中所定义的成员变量; 接口与真正有所区别的是前面讲述的 5 种情景中的第 3 种: 当一个类在初始化时, 要求其父类全部都已经初始化过了, 但是一个接口在初始化时, 并不要求其父接口全部都完成了初始化, 只有在真正使用到了父接口的时候 (如引用接口种定义的常量) 才会初始化

#### 类加载的过程
类加载的全过程, 也就是加载, 验证, 准备, 解析和初始化这 5 个阶段所执行的具体动作

##### 加载
加载时类加载过程的一个阶段, 在加载阶段, 虚拟机需要完成一下 3 件事
- 通过一个类的全限定名来获取定义此类的二进制字节流
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
- 在内存中生成一个代表这个类的 java.lang.Class 对象, 作为方法区这个类的各种数据的访问接口

以上的虚拟机规范并不算具体, 因此虚拟机实现与具体应用的灵活度都是相当大的;  例如获取二进制字节流并没有规定从哪里获取, 怎样获取等等; Java 发展历程中, 许多举足轻重的 Java 技术都建立在这一基础之上
- 从 ZIP 包中读取, 最终成为日后 JAR, EAR, WAR 格式的基础
- 从网络中读取, 最典型的应用就是 Applet
- 运行时计算生成, 这种场景使用的最多的就是动态代理技术, 在 java.lang.reflect.Proxy 中, 就是用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为 "\*$Proxy" 的代理类的二进制字节流
- 由其他文件生成, 典型场景时 JSP 应用, 即由 JSP 文件 生成对应的 Class 类
- 从数据库中读取, 这种场景相对少见; 例如某些中间件服务器 (SAP Netweaver) 可以选择把程序安装到数据库中来完成程序代码在集群间的分发

相对类加载过程的其他阶段, 一个非数组类的加载阶段 (准确的说是加载阶段中获取类的二进制字节流的动作) 是开发人员可控性最强的, 因为加载阶段既可以使用系统提供的引导类加载器来完成, 也可以由用户自定义的类加载器去完成, 开发人员可以通过定义自己的类加载器去控制字节流的获取方式 (即重写一个类加载器的 loadClass() 方法)  
对于数组类而言情况就有所不同, 数组类本身不通过类加载器创建, 它是由 Java 虚拟机直接创建的, 但数组类与类加载器仍然有很密切的关系, 因为数组类的元素类型 (Element Type, 即数组去掉所有维度的类型) 最终是要靠类加载器去创建的, 一个数组类 (下面简称 C) 创建过程就遵顼以下原则
- 如果数组的组件类型 (Component Type, 即数组去掉一个维度的类型) 是引用类型, 那就递归采用本节定义的加载过程去加载这个组件类型, 数组 C 将在加载该组件类型的类加载器的类名称空间上被标识
- 如果数组的组件类型不是引用类型 (例如 int[] 数组), Java 虚拟机将会把数组 C 标记为与引导类加载器关联
- 数组类的可见性与它的组件类型可见性一致, 如果组件类型不是引用类型, 那数组类的可见性将默认为 public

加载阶段完成后, 虚拟机外部的二进制字节来就按照虚拟机所需的格式存储在方法区之中, 方法去中的数据存储格式由虚拟机实现自行定义, 虚拟机规范未规定此区域的具体数据结构; 然后在内存中实例化一个 java.lang.Class 类的对象 (并没有明确规定是在 Java 堆中, 对于 HotSpot 虚拟机而言, Class 对象比较特殊, 虽然是对象但是存放在方法区里), 这个对象将作为程序访问方法去中的这些类型数据的外部接口  
加载阶段和连接阶段的部分内容是交叉进行的, 加载阶段尚未完成, 连接阶段可能已经开始了, 但这些夹在加载阶段中的进行的动作, 仍然属于连接阶段的内容, 这两个阶段的开始时间仍然保持着固定的先后顺序

##### 验证
验证是连接阶段的第一步, 这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求, 并且不会危害虚拟机的自身安全  
验证阶段是非常重要的, 这个阶段是否严谨直接决定了 Java 虚拟机是否能承受恶意代码的攻击; 从执行性能的角度上讲, 验证阶段的工作量在虚拟机的类加载子系统中占了相当大的一部分; 如果验证到输入的字节流不符合 Class 文件格式的约束, 虚拟机就应抛出一个 java.lang.VerifyError 异常或其子类异常; 验证阶段大致会完成下面 4 个阶段的检验动作: 文件格式验证, 元数据验证, 字节码验证, 符号引用验证

###### 文件格式验证
第一阶段要验证字节流是否符合 Class 文件格式的规范, 并且能被当前版本的虚拟机处理; 这一阶段可能包括下面这些验证点
- 是否以魔数 0xCAFEBABE 开头
- 主次版本号是否在当前虚拟机处理范围之内
- 常量池的常量中是否有不被支持的常量类型 (检查常量 tag 标记)
- 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量
- CONSTANT_Utf8_info 型的常量中是否有不符合 UTF-8 编码的数据
- Class 文件中各个部分及文件本身是否有被删除的或附件的其他信息
- ...

这一阶段的验证点远不止这些, 该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区内; 通过这个阶段地验证后, 字节流才会进入内存地方法区中进行存储, 后续验证阶段都是基于方法区的存储结构进行的, 不会再直接操作字节流

###### 元数据验证
第二阶段是对字节码描述的信息进行语义分析, 以保证其描述的信息符合 Java 语言规范的要求; 这一阶段可能包括的验证点如下
- 这个类是否有父类
- 这个类的父类是否继承了不允许被继承的类 (被 final 修饰的类)
- 如果这个类不是抽象类, 是否实现了其父类或接口之中要求实现的所有方法
- 类中的字段, 方法是否于父类产生矛盾 (例如覆盖了父类的 final 字段, 或者出现不符合规则的方法重载, 如方法参数一致但返回值类型却不同等)
- ...

这一阶段的主要目的是对类的元数据信息进行语义校验, 保证不存在不符合 Java 语言规范的元数据信息

###### 字节码验证
第三阶段是整个验证过程中最复杂的阶段, 主要目的是通过数据流和控制流分析, 确定程序语义是合法的, 符合逻辑的; 在第二阶段对元数据信息中的数据类型做完校验后, 这个阶段将对类的方法体进行校验分析, 以保证被校验的类方法在运行时不会做出危害虚拟机的安全事件
- 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作; 不会出现: 在操作栈放置了一个 int 类型的数据, 使用时却按 long 类型来加载入本地变量表中
- 保证跳转指令不会跳转到方法体以外的字节码指令上
- 保证方法体的类型转换时有效的; 例如可以把一个子类对象赋值给父类数据类型, 这是安全的, 但是把父类对象赋值给子类数据类型则是危险和不合法的
- ...

这里方法体通过了字节码验证也不能说一定就是安全的, 这里涉及了离散数学中一个很著名的问题 "Halting Problem": 通过程序去校验程序逻辑是无法做到绝对准确的 --- 不能通过程序准确地检查出程序是否能在有限地时间内结束运行  
在 JDK 1.6 之后地 Javac 编译器和 Java 虚拟机中斤进行了一项优化, 给方法体地 Code 属性的属性表中增加了一项名为 "StackMapTable" 的属性, 这项属性描述了方法体中所有的基本块 (Basic Block, 按照控制流拆分的代码块) 开始时本地变量表和操作栈应有的状态, 在字节码验证期间, 就不需要根据程序推到这些状态的合法性, 只需要检查 StackMapTable 属性中的记录是否合法即可; 这样将字节码的类型推导转变为类型检查从而节省了一些时间  
在 JDK 1.6 的 HotSpot 虚拟机中提供了 -XX:-UseSplitVerifier 选项来关闭这项优化, 或者使用参数 -XX:+FailOverToOldVerifier 要求类型校验失败时退回到旧的类型推导方式进行校验; 在 JDK 1.7 之后, 对于主版本号大于 50 的 Class 文件, 使用类型检查来完成数据流分析则是唯一的选择

###### 符号引用验证
最后一阶段的校验发生在虚拟机将符号引用转化为直接引用的时候, 这个转化动作将在连接的第三阶段 --- 解析阶段中发生; 符号引用验证可以看作是对类自身以外 (常量池中各种符号引用) 的信息进行匹配性校验, 通常需要校验以下内容
- 符号引用中通过字符串描述的全限定名是否能找到对应的类
- 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段
- 符号引用中的类, 字段, 方法的访问性是否可被当前类访问
- ...

符号引用验证的目的是确保解析动作能正常执行, 如果无法通过符号引用验证, 那么将抛出一个 java.lang.IncompatibleClassChangeError 异常的子类, 如 java.lang.IllegalAccessError, java.lang.NoSuchFieldError, java.lang.NoSuchMethodError 等  
对于虚拟机的类加载机制来说, 验证阶段是一个非常重要的, 但不是一定必要的阶段; 可以使用 -Xverify:none 参数来关闭大部分的类验证措施, 以缩短虚拟机类加载的时间

##### 准备
准备阶段是正式为类变量 (被 static 修饰的变量) 分配并设置类变量初始值的阶段, 这些变量所使用的内存都将在方法区中进行分配; 这里说的初始值通常情况下是数据类型的零值, 假设一个类变量的定义为: `public static int value = 123;`, 那变量 value 在准备阶段过后的初始值是 0 而不是 123; 因为这是尚未开始执行任何 Java 方法, 而把 value 赋值为 123 的 putstatic 指令是程序被编译后, 存放于类构造器 <clinit>() 方法中, 所以将 value 赋值为 123 的动作将在初始化阶段才会执行; 下表是 Java 中所有基本数据类型的零值
|数据类型|零值|数据类型|零值|
|-|-|-|-|
|int|0|boolean|false|
|long|0L|float|0.0f|
|short|(short)0|double|0.0d|
|char|'\u0000'|reference|null|
|byte|(byte)0|-|-|
在通常情况下初始值是零值, 如果类字段的字段属性表中存在 ConstantValue 属性, 那在准备阶段变量 value 就会被初始化为 ConstantValue 属性所指定的值, 例如: `public static final int value = 123;`, 编译时 Javac 将会为 value 生成 ConstantValue 属性, 在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 123

##### 解析
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程
- 符号引用 (Symbolic Reference): 符号引用以一组符号来描述所引用的目标, 符号可以是任何形式的字面量, 只要使用时能无歧义地定位到目标即可; 符号引用与虚拟机实现地内存布局无关, 引用地目标并不定已加载到内存中; 各种虚拟机实现的内存布局可以各不相同, 但是它们能接受的符号必须都是一致的, 因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中
- 直接引用 (Direct Reference): 直接引用可以是直接指向目标的指针, 相对偏移量或是一个能间接定位到目标的句柄; 直接引用是和虚拟机实现的内存布局相关的, 同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同; 如果有了直接引用, 那引用的目标必定已经在内存中存在了

虚拟机规范中并未规定解析阶段发生的具体时间, 只要求了在执行 `anewarray, checkcast, getfield, getstatic, instanceof, invokedynamic, invokeinterface, invokespecicial, invokestatic, invokevirtual, ldc, ldc_w, multianewarray, new, putfield, putstatic` 这 16 个用于操作符号引用的字节码指令之前, 先对它们所使用的符号引用进行解析; 所以虚拟机实现可以根据需要来判断是在类被加载器加载时就对常量池的符号引用进行解析, 还是等到一个符号引用将要被使用前才去解析它  
对同一个符号引用进行多次解析请求是很常见的事情, 除了 invokedynamic 指令之外, 虚拟机实现可以对第一次解析的结果进行缓存 (在运行时常量池中记录直接引用, 并把常量标识为已解析状态) 从而避免解析动作重复执行; 无论是否真正执行了多次解析动作, 虚拟机需要保证的是在同一个实体中, 如果一个符号引用之前已经被成功解析过了, 那么后续的引用解析请求就应当一直成功; 同样的, 如果第一次解析失败了, 那么其他指令对这个符号的解析请求也应该收到相同的异常  
对于 invokedynamic 指令上述规则不成立, 因为 invokedynamic 指令的目的本来就是用于动态语言支持, 它所对应的引用称为 "动态调用点限定符" (Dynamic Call Site Specifier), 即代码程序实际运行到这条指令的时候, 解析动作才能进行; 相对的, 其余可触发解析的指令都是静态的, 可以在刚刚完成加载阶段, 还没有开始执行代码时就进行解析  
解析动作主要针对类或接口, 字段, 类方法, 接口方法, 方法类型, 方法句柄, 调用点限定符 7 类符号引用进行, 分别对应于常量池的 `CONSTANT_Class_info, CONSTANT_Fieldref_info, CONSTANT_Methodref_info, CONSTANT_InterfaceMethodref_info, CONSTANT_MethodType_info, CONSTANT_MethodHandle_info, CONSTANT_InvokeDynamic_info` 这 7 种常量类型
###### 类或接口的解析
假设当前代码所处的类为 D, 如果要把一个从未解析过的符号引用 N 解析为一个类或接口 C 的直接引用, 虚拟机需要完成整个解析过程需要以下三个步骤
- 如果 C 不是一个数组类型, 那虚拟机将会把代表 N 的全限定名传递给 D 的类加载器去加载这个类 C; 在加载过程中, 由于元数据验证, 字节码验证的需要, 又可能触发其他相关类的加载动作, 例如加载这个类的父类或实现的接口; 一旦这个加载过程出现了任何异常, 解析过程就宣告失败
- 如果 C 是一个数组类型, 并且数组的元素类型为对象, N 的描述符会类似为 "[Ljava/lang/Integer" 的形式, 那将会按照第一点的规则去加载数组元素类型; 如果 N 的描述符如前面所假设的形式, 那么需要加载的元素类型就是 "java.lang.Integer", 接着由虚拟机生成一个代表数组维度和元素的数组对象
- 如果上面的步骤没有出现任何异常, 那么 C 在虚拟机中实际上已经成为了一个有效的类或接口了, 但在解析完成之前还要进行符号引用验证, 确认 D 是否具有对 C 的访问权限; 如果发现不具备访问权限, 则抛出 java.lang.IllegalAccessError 异常

###### 字段解析
解析一个未被解析过的字段符号引用, 首先将会对字段表内 class_index 项中索引的 CONSTANT_Class_info 符号引用进行解析, 也就是字段所属类或接口的符号引用; 如果在解析这个类或接口符号引用的过程中出现了任何异常, 都会导致字段符号引用解析的失败; 若解析完成, 那将这个字段所属的类或接口用 C 表示, 虚拟机规范要求按照如下步骤对 C 进行后续字段的搜索
- 如果 C 本身就包含了简单名称或字段描述符都与目标相匹配的字段, 则返回这个字段的直接引用, 查找结束
- 否则, 如果在 C 中实习了接口, 将会按照继承关系从上往下递归搜索各个接口和它的父接口, 如果接口中包含了简单名称和字段描述都与目标相匹配的字段, 则返回这个字段的直接引用, 查找结束
- 否则, 如果 C 不是 java.lang.Object 的话, 将会按照继承关系从下往上递归搜索其父类, 如果在父类中包含了简单名称和字段描述都与目标相匹配的字段, 则返回这字段的直接引用, 查找结束
- 否则, 查找失败, 抛出 java.lang.NoSuchFieldError 异常
如果查找过程成功返回了引用, 将会对这个字段进行权限验证, 如果不具备对这个字段的访问权限, 将抛出 java.lang.IllegalAccessError 异常; 在实际应用中, 虚拟机的编译器实现可能会比上述规范要求得更加严格一些, 如果一个同名字段同时出现在 C 的接口或类中, 或者同时在自己的或父类的多个接口中, 编译器将可能拒绝编译

###### 类方法解析
类方法解析的第一个步骤与字段解析一样, 也需要先解析出类方法表的 class_index 项中索引的方法所属的类或接口的符号引用, 如果解析成功依然用 C 表示这个类, 接下来虚拟机按如下步骤进行后续的类方法搜索
- 类方法和接口方法符号引用的常量类型定义是分开的, 如果在类方法表中发现 class_index 中索引的 C 是个接口, 那就直接抛出 java.lang.IncompatibleClassChangeError 异常
- 如果通过了第一步, 在类 C 中查找是否有简单名称和描述符都与目标相匹配的方法, 如果有则返回这个方法的直接引用, 查找结束
- 否则, 在类 C 的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法, 如果有则返回这个方法的直接引用, 查找结束
- 否则, 在类 C 实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法, 如果存在匹配的方法, 说明类 C 是一个抽象类, 这时查找结束, 抛出 java.lang.AbstractMethodError 异常
- 否则, 宣告方法查找失败, 抛出 java.lang.NoSuchMethodError

最后, 如果查找过程成功返回了直接引用, 将会对这个方法进行权限验证, 如果不具备对这个字段的访问权限, 将抛出 java.lang.IllegalAccessError 异常

###### 接口方法解析
接口方法也需要先解析出接口方法表的 class_index 项中索引的方法所属的类或接口的符号引用, 如果解析成功, 依然用 C 表示这个接口, 接下来虚拟机将会按照如下步骤进行后续的接口方法搜索
- 与类方法解析不同, 如果在接口方法表中发现 class_index 中的索引 C 是个类而不是接口, 那就直接抛出 java.lang.IncompatibleClassChangeError 异常
- 否则, 在接口 C 中查找是否有简单名称和描述符都与目标相匹配的方法, 如果有则返回这个方法的直接引用, 查找结束
- 否则, 在接口 C 的父接口中递归查找, 直到 java.lang.Object 类 (查找范围会包括 Object 类) 为止, 看是否有简单名称和描述符都与目标相匹配的方法, 如果有则返回这个方法的直接引用, 查找结束
- 否则, 宣告方法查找失败, 抛出 java.lang.NoSuchMethodError 异常

由于接口中的所有方法默认都是 public 的, 所以不存在访问权限的问题, 所以接口方法的符号解析不会抛出 java.lang.IllegalAccessError 的异常

##### 初始化
类初始化阶段是类加载过程的最后一步, 在类加载过程中, 除了在加载阶段用户应用程序可以通过自定义类加载器参与之外, 其余动作完全由虚拟机主导和控制; 到了初始化阶段, 才真正开始执行类中定义的 Java 程序代码  
在准备阶段, 变量已经赋过一次系统要求的初始值, 而在初始化阶段, 则根据程序员通过程序指定的主观计划去初始化类变量和其他资源, 初始化阶段是执行类构造器 `<clinit>()` 方法的过程
- `<clinit>()` 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的, 编译器收集的顺序是由语句在源文件中出现的顺序所决定的, 静态语句块中只能访问到在静态语句块之前的变量, 定义在它之后的变量, 在前面的静态语句块可以赋值, 但是不能访问
```
public class Test {
  static {
      i = 0;  // 给变量赋值可以正常编译通过
      System.out.println(i);  // 这句编译会提示 "非法前向引用"
  }
  static int i = 1;
}
```
- `<clinit>()` 方法与类的构造函数 (或者说实例构造器 `<init>()` 方法) 不同, 不需要显式的调用父类构造器, 虚拟机会保证子类的 `<clinit>()` 方法执行之前, 父类的 `<clinit>()` 方法已经执行完成; 因此在虚拟机中第一个被执行的 `<clinit>()` 方法的类肯定是 java.lang.Object
- 由于父类的 `<clinit>()` 方法先执行, 也就意味着父类中定义的静态语句块要优先子类的变量赋值操作
- `<clinit>()` 方法对于类或接口来说并不是必需的, 如果一个类中没有静态语句块, 也没有对变量的赋值操作, 那么编译器可以不为这个类生成 `<clinit>()` 方法
- 接口中不能使用静态语句块, 但仍然有变量初始化的赋值操作, 因此接口与类一样都会生成 `<clinit>()` 方法; 只有当父接口中定义的变量使用时, 父接口才会初始化, 另外, 接口的实现类在初始化时也一样不会执行接口的 `<clinit>()` 方法
- 虚拟机会保证一个类的 `<clinit>()` 方法在多线程环境中被正确的加锁, 同步, 如果多个线程同时去初始化一个类, 那么只会有一个线程去执行这个类的 `<clinit>()` 方法; 其他线程都需要阻塞等待, 直到活动线程执行 `<clinit>()` 方法完毕, 如果在一个类的 `<clinit>()` 方法中有耗时很长的操作, 就可能造成多个进程阻塞; 但如果执行 `<clinit>()` 方法的那条线程退出 `<clinit>()` 方法后, 其他线程唤醒之后不会再次进入 `<clinit>()` 方法; 同一个类加载器下, 一个类型只会初始化一次

#### 类加载器
虚拟机设计团队把类加载阶段中的 "通过一个类的全限定名来获取描述此类的二进制字节流" 这个动作放到 Java 虚拟机外部去实现, 以便让应用程序自己决定如何去获取所需要的类; 实现这个动作的代码模块称为 "类加载器"

##### 类与类加载器
类加载器虽然只用于实现类的加载动作, 但对于任意一个类, 都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性, 每一个类加载器都拥有一个独立的类命名空间; 即比较两个类是否相等, 只有在这两个类由同一个类加载器加载的前提下才有意义, 否则, 即使这两个类来源于同一个 class 文件, 被同一个虚拟机加载, 只要加载它们的类加载器不同, 那么这两个类就必定不相等  
这里指的相等包括代表类的 Class 对象的 equals() 方法, isAssignableFrom() 方法, isInstance() 方法的返回结果, 也包括使用 instanceof 关键字做对象所属关系的判定等; 如果没有注意到类加载器的影响, 在某些情况下可能会产生具有迷惑性的结果

##### 双亲委派模型
从 Java 虚拟机的角度来讲, 只存在两种不同的类加载器:一种是启动类加载器 (Boostrap ClassLoader), 这个类加载器是 C++ 语言实现的 (HotSpot), 是虚拟机的一部分; 另一种就是所以其他的类加载器, 这些类加载器都由 Java 语言实现, 独立于虚拟机外部, 并且全都继承自抽象类 java.lang.ClassLoader  
从开发人员的角度来看, 可大致分为以下三种系统提供的类加载器
- 启动类加载器 (Boostrap ClassLoader): 这个类加载器负责将存放在 <JAVA_HOME>\lib 目录中的, 或者被 -Xbootclasspath 参数指定的路径中的, 并且是虚拟机识别的 (仅按文件名识别, 如 rt.jar, 名字不符合的类库即使放在路径 lib 目录中也不会被加载) 类库加载到虚拟机内存中; 启动类加载器无法被 Java 程序直接引用, 用户在编写自定义类加载器时, 如果需要把加载请求委派给引导类加载器, 那直接使用 null 代替即可
- 扩展类加载器 (Extension ClassLoader): 这个加载器由 sun.misc.Launcher$ExtClassLoader 实现, 它负责加载 <JAVA_HOME>\lib\ext 目录中的, 或者被 java.ext.jars 系统变量所指定的路径中的所有类库, 开发者可以直接使用扩展类加载器
- 应用程序类加载器 (Application ClassLoader): 这个类加载器由 sun.misc.Launcher$AppClassLoader 实现; 由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值, 所以一般也成为系统类加载器, 负责加载用户类路径 (ClassPath) 上所指定的类库

应用程序都是由这 3 中类加载器互相配合进行加载的, 如果有必要, 还可以加入自定义的类加载器  
```
Boostrap ClassLoader <- Extension ClassLoader <- Application ClassLoader <- User ClassLoader
```
这些类加载器之间的关系如以上所示, 称为双亲委派模型 (Parents Delegation Model); 双亲委派模型要求除了顶层的启动类加载器外, 其余类加载器都应当有自己的父类加载器; 这里类加载器之间的父子关系一般不会以继承 (Inheritance) 的关系来实现, 而是使用组合的方式来复用 (Composition) 父类加载器的  
双亲委派模型的工作过程是: 如果一个类加载器收到了类加载的请求, 它首先不会自己尝试加载这个类, 而是把这个请求委派给父类加载器去完成, 每一个层次的类加载器都是如此, 因此所有的加载请求最终都应该传送到顶层的启动类加载器中, 只有当父加载器反馈自己无法完成这个加载请求时 (它的搜索范围没有找到所需的类) 时, 子加载器才会尝试自己去加载  
使用双亲委派模型来组织类加载器之间的关系的好处是: Java 类随着它的类加载器一起具备了一种个优先级的层级关系; 例如类 java.lang.Object, 它存放在 rt.jar 中, 无论哪一个类加载器要加载这个类, 最终都是委派给处于模型最顶层的启动类加载器进行加载, 因此 Object 类在程序的各种类加载器环境中都是同一个类  
双亲委派模型对于保证 Java 程序的稳定运行很重要, 但它的实现却非常简单, 实现双亲委派的代码都集中在 java.lang.ClassLoader 的 loadClass() 方法中
```
protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
    synchronized (getClassLoadingLock(name)) {
        // 首先, 检查请求的类是否已经被加载过了
        Class<?> c = findLoadedClass(name);
        if (c == null) {
            long t0 = System.nanoTime();
            try {
                if (parent != null) {
                    c = parent.loadClass(name, false);
                } else {
                    c = findBootstrapClassOrNull(name);
                }
            } catch (ClassNotFoundException e) {
                // 如果从非 null 的父类加载器中没有找到此类, 则抛出 ClassNotFoundException 异常
            }

            if (c == null) {
                // 如果仍然没有找到, 则调用此 ClassLoader 的 findClass 方法来加载类
                long t1 = System.nanoTime();
                c = findClass(name);

                // 为此 ClassLoader 定义以记录统计值
                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                sun.misc.PerfCounter.getFindClasses().increment();
            }
        }
        if (resolve) {
            resolveClass(c);
        }
        return c;
    }
}
```

##### 破坏双亲委托模型
双亲委派模型并不是一个强制性的约束模型, 而是 Java 设计者推荐给开发者的类加载器实现方式; 到目前为止, 双亲委派机制主要出现过 3 次大规模的 "被破坏" 情况
- 第一次
发生在双亲委派模型出现之前 --- JDK 1.2 发布之前; 由于双亲委派模型在 JDK 1.2 之后才被引入, 而类加载器和抽象类 java.lang.ClassLoader 在 1.0 时代就已经存在, 对已经存在的用户自定义的类加载器的实现代码, 为了做到向前兼容, Java 设计者引入双亲委派模型时不得不做了一些妥协; JDK 1.2 之后 java.lang.ClassLoader 添加了一个新的 protect 方法 findClass(); 在此之前用户去继承 ClassLoader 的唯一目的就是为了重写 loadClass() 方法, 而虚拟机在进行类加载的时候会调用加载器的私有方法 loadClassInternal(), 而这个方法的唯一逻辑就是去调用自己的 loadClass(); JDK 1.2 之后已不再提倡用户再去覆盖 loadClass() 方法, 而是应当把自己的类加载逻辑写到 findClass() 方法中, 在 loadClass() 方法的逻辑里如果父类加载失败, 则会调用自己的 findClass() 方法来完成加载, 这样就保证了新写出来的类加载器是符合双亲委派模型的
- 第二次
第二次的破坏是由于这个模型自身的缺陷导致的, 双亲委派很好的解决了各个类加载器的基础类的统一问题 (越基础的类由越上层的加载器进行加载), 基础类之所以被称为 "基础", 是因为它们总是作为被用户代码调用的 API; 但也会出现基础类又要调回用户的代码, 一个典型的例子就是 JNDI 服务; JNDI 服务现在是 Java 的标准服务, 它的代码由启动类加载器去加载, 但 JNDI 的目的就是对资源进行集中管理和查找, 它需要调用独立厂商实现并部署在应用程序的  ClassPath 下的 JNDI 接口提供者 (SPI, Service Provider Interface) 的代码, 但启动类加载器不可能 "认识" 这些代码; 为了解决这个问题, Java 涉及团队只好引入了一个不太优雅的设计: 线程上下文类加载器 (Thread Context ClassLoader), 这个类加载器可以通过 java.lang.Thread 类的 setContextClassLoader() 方法进行设置, 如果创建线程是还未设置, 它将会从父线程中继承一个, 如果全局范围内都没有设置过的话, 那这个类加载器默认就是应用程序类加载器; 这样 JNDI 服务使用这个线程上下文类加载器去加载所需要的 SPI 代码, 也就是父类加载器请求子类加载器去完成类加载的动作, 也就是打通了双亲委派模型的层次结构来逆向使用类加载器, 实际上已经违背了双亲委派模型的一般性原则, 但也是无可奈何的事; Java 中所有涉及 SPI 的加载动作基本上采用这种方式, 如 JNDI, JDBC, JCE, JAXB 和 JBI
- 第三次
第三次破坏是由于用户对程序动态性的追求导致的, 即指一些热门的技术名词: 代码热替换, 模块热部署等; 目前 OSGi 是 Java 模块化标准, 而 OSGi 实现模块化热部署的关键则是它自定义的类加载器机制的实现; 每个程序模块 (OSGi 中称为 Bundle) 都有一个自己的类加载器, 当需要更换一个 Bundle 时就把 Bundle 连同类加载器一起换掉以实现代码的热替换; 在 OSGi 环境下, 类加载器不再是双亲委派模型中的树状结构, 而是进一步发展为更加复杂的网状结构, 当收到类的加载请求时, OSGi 将按照下面的顺序进行类搜索
  - 将以 java.* 开头的类委派给父类加载器加载
  - 否则, 将委派列表名单内的类委派给父类加载器加载
  - 否则, 将 Import 列表中的类委派给 Export 这个类的 Bundle 的类加载器加载
  - 否则, 查找当前 Bundle 的 ClassPath, 使用自己的类加载器加载
  - 否则, 查找类是否在自己的 Fragment Bundle 中, 如果在则委派给 Fragment Bundle 的类加载器加载
  - 否则, 查找 Dynamic Import 列表的 Bundle, 委派给对应的 Bundle 的类加载器加载
  - 否则, 类查找失败
上述查找顺序只有开头两点仍然符合双亲委派模型, 其余的类查找都是在平级的类加载器中进行的
