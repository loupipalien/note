### Java 内存区域与内存溢出异常
Java 与 C++ 之间有一堵有内存动态分配和垃圾收集技术所围成的 "高墙", 墙外面的人想进去, 墙里面的人却想出来

#### 概述
垃圾收集 (Garbage Collection, GC) 的历史比 Java 久远, 1960 年诞生于 MIT 的 Lisp 是第一门真正使用内存动态分配和垃圾收集技术的语言, 人们认为 GC 需要完成的有以下三件事
- 哪些内存需要回收?
- 什么时候回收?
- 如何回收?

第 2 章中介绍了 Java 内存运行时区域的各个部分, 其中程序计数器, 虚拟机栈, 本地方法栈三个区域随着线程而生, 随着线程而灭; 栈中的每一个栈帧中分配多少内存基本上是在类结构确定时就已知的, 因此这几个区域的内存分配和回收都具有确定性, 因此不需要过多的考虑回收的问题; 而 Java 堆和方法区则不一样, 一个接口中的多个实现类需要的内存可能不一样, 一个方法中的多个分支需要的内存也可能不一样, 我们只有在程序运行期间才能知道会创建哪些对象; 这部分的内存的分配和回收是动态的, 垃圾收集器关注的是这部分内存  

#### 对象已死吗?
在堆里存放着 Java 世界中几乎所有的对象实例, 垃圾收集器在对堆进行回收之前, 第一件事情就是要确定这些对象之中还有哪些 "存活" 着, 哪些已经 "死去" (即不可能再被任何途径使用的对象)

##### 引用计数算法
判断对象是否存活的算法是这样的: 给对象中添加一个引用计数器, 每当有一个地方引用它时, 计数器值就加一, 当引用失效时, 计数器值就减一, 任何时刻计数器为 0 的对象就是不可能再被使用的; 微软的 COM (Component Object Model) 技术, 使用 ActionScript 的 FlashPlayer, Python 语言和在游戏脚本领域应用的 Squirrel 中都使用了引用计数算法进行内存管理; 但是主流 Java 虚拟机里没有用引用计数算法, 其中最主要的原因是它很难解决对象之间相互循环引用的问题  

##### 可达性分析算法
在主流的商用程序语言 (Java, C#, Lisp等) 的主流实现中, 都是通过可达性分析来判断对象是否存活的; 这个算法的基本思想就是通过一系列的称为 "GC Roots" 的对象作为起始点, 从这些节点开始向下搜索, 搜索所走过的路径称为引用链 (Reference Chain), 当一个对象到 GC Roots 没有任何引用链相连时, 则证明此对象是不可用的  
在 Java 语言中可作为 GC Roots 的对象包括以下几种
- 虚拟机栈 (栈帧中的本地变量表) 中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中 JNI (即一般说的 Native 方法) 引用的对象

##### 再谈引用
在 JDK 1.2 之前, Java 中引用的定义很传统: 如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址, 就称这块内存代表着一个引用; 这种定义很纯粹但也很狭隘, 一个对在这种定义下只有被引用和没有被引用两种状态, 对于如何描述一些 "食之无味, 弃之可惜" 的对象就显得无能为力; 例如希望描述这样一类对象: 当内存空间还足够时, 则能保留在内存之中; 如果内存空间在进行垃圾收集后还是非常紧张, 则可以抛弃这些对象; 很多缓存功能符合这样的场景  
在 JDK 1.2 之后, Java 对引用概念进行了扩充, 将引用分为强引用 (Strong Reference), 软引用 (Soft Reference), 弱引用 (Weak Reference), 虚引用 (Phantom Reference) 四种
- 强引用就是指代码中普遍存在的, 类似 "Object obj = new Object()" 这类引用, 只要强引用还在, 垃圾收集器永远不会回收掉被引用的对象
- 软引用是用来描述一些还有用但并非必需的对象; 对于软引用关联的对象, 在系统将要发生内存溢出异常之前, 会将这些对象列入回收范围之中进行第二次回收, 如果这次回收还没有足够的内存, 才会抛出内存溢出异常; 在 JDK 1.2 之后, 提供了 SoftReference 类来实现软引用
- 弱引用也是用来描述非必需对象的, 但是它比软引用更弱一些, 被弱引用关联的对象只能生存到下一次垃圾回收发生之前; 当垃圾收集器开始工作时, 无论当前内存是否足够, 都会回收掉只被弱引用关联的对象; 在 JDK 1.2 之后, 提供了 WeakReference 类来实现弱引用
- 虚引用也称为幽灵引用或幻影引用, 它是最弱的一种引用关系; 一个对象是否有虚引用的存在, 完全不会对其生存时间构成影响, 也无法通过虚引用来取得一个对象实例; 为对象设置一个虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知; 在 JDK 1.2 之后, 提供了 PhantomReference 类来实现虚引用

##### 生存还是死亡
即使在可达性分析算法中不可达的对象, 也并非是 "非死不可" 的, 要宣告一个对象死亡至少要经历两次标记过程: 如果对象在进行可达性分析后发现没有与 GC Roots 相连的引用链, 那它将会被第一次标记并且进行一次筛选, 筛选的条件是此对象是否有必要执行 finalize() 方法; 当对象没有覆盖 finalize() 方法, 或者 finalize() 方法已经被虚拟机调用过了, 虚拟机将这两种情况都视为 "没有必要执行"  
如果这个对象被判定为有必要执行 finalize() 方法, 那么这个对象将会被防止在一个叫做 F-Queue 的队列中, 并在稍后由一个虚拟机自动建立的, 低优先级的 Finalizer 线程区执行; 这里的执行是指虚拟机会触发 finalize() 方法, 但并不承诺会等待它运行结束, 这样做的原因是, 如果一个对象在 finalize() 方法中执行缓慢, 或者发生了死循环, 将很可能会导致 F-Queue 队列中其他对象永远处于等待, 甚至导致整个内存回收系统奔溃; finalize() 方法是对象逃脱死亡命运的最后一次机会, 稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记, 如果对象在 finalize() 中成功拯救了自己 --- 只要重新与引用链上的任何一个对象建立关联即可, 譬如把自己赋值给某个类变量或者对象的成员变量, 那在第二次标记时它将会被移出 "即将回收" 集合; 如果这时还未逃脱, 那基本上它就真的被回收了

##### 回收方法区
Java 虚拟机规范中可以不要求在方法区实现垃圾收集, 并且在方法区中进行垃圾收集的 "性价比" 较低: 在堆中, 尤其在新生代中, 常规应用进行一次垃圾收集一般可以回收 70% ~ 90% 的空间, 而在方法区 (HotSpot 的永久代) 的垃圾收集效率远低于此  
永久代的垃圾收集主要回收两部分内容: 废弃常量和无用的类; 回收废弃常量与回收 Java 堆中的对象类似, 当没有地方引用常量, 如果发生内存回收, 而且有必要的话就会被回收; 判定一个常量是否时 "废弃常量" 比较简单, 而要判定一个类是否时 "无用的类" 的条件则相对苛刻很多, 类要同时满足以下三个条件才算是 "无用的类"
- 该类所有的实例都已经被回收, 也就是 Java 堆中不存在该类的任何实例
- 加载该类的 ClassLoader 已经被回收
- 该类对应的 java.lang.Class 对象没有在任何地方被引用, 无法在任何地方通过反射访问该类的方法

虚拟机对满足以上三个条件的无用的类可以进行回收, 但不像对象那样不用了就回收; 是否对类进行回收, HotSpot 虚拟机提供了 -Xnoclassgc 参数控制

#### 垃圾收集算法
由于各个平台虚拟机操作内存的方法各不相同, 以下只介绍算法的思想及发展过程

##### 标记 - 清除算法
最基础的收集算法是 "标记-清除" (Mark-Sweep) 算法, 算法分为 "标记" 和 "清除" 两个阶段: 首先标记处所有需要回收的对象, 在标记完成后统一回收所有被标记的对象; 此算法的不足主要有两个: 一是效率问题, 标记和清除两个过程的效率都不高; 另一个是空间问题, 标记清除之后会产生大量不连续的内存碎片, 空间碎片太多可能会导致以后再程序运行过程中需要分配较大对象时, 无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作

##### 复制算法
为了解决效率问题, 复制算法出现了; 它将可用内存按容量划分为大小相等的两块, 每次只使用其中的一块; 当这一块的内存使用完了, 就将还存活着的对象复制到另外一块上面, 然后再把已使用过的内存空间一次清理掉; 这样每次都对整个半区进行内存回收, 内存分配时也就不用考虑内存碎片等复杂情况, 只是这样的空间代价较高  
现在商业虚拟机都采用这种算法来回收新生代, IBM 公司研究表明新生代中 98% 的对象都是 "朝生夕死" 的, 所以不需要按照 1 : 1 的比例划分内存空间, 而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间; 每次使用 Eden 空间和其中一块 Survivor 空间, 当回收时, 将 Eden 和 Survivor 中还存活的对象一次性的复制到另外一块 Survivor 空间上, 最后清理掉 Eden 和之前使用过的 Survivor 空间; HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8 : 1; 虚拟机没有办法保证每次回收都只有不多于 10% 的对象存活, 当 Survivor 空间不够用时, 需要依赖其他内存 (这里指老年代) 进行分配担保 (Handle Promotion); 即另外一块 Survivor 没有足够空间存放上一次新生代收集下来的存活对象时, 这些对象将直接通过分配担保机制进入老年代

##### 标记 - 整理算法
复制收集算法在对象存活率较高时就要进行较多的复制操作, 效率会变低; 更关键的是, 如果不像浪费 50% 的空间, 就需要有额外的空间进行分配担保, 以应对被使用的内存中对象 100% 存活的极端情况, 所以在老年代一般不能直接使用这种算法  
根据老年代的特点提出了 "标记 - 整理" (Mark-Compact) 算法, 标记过程和 "标记 - 清除" 算法一样, 但后续步骤不是直接可回收对象进行清理, 而是让所有存活的对象向一端移动, 然后直接清理掉端边界以外的内存

##### 分代收集算法
当前商业虚拟机的垃圾收集都采用 "分代收集" (Generational Collection) 算法, 这种算法只是根据对象存活周期的不同将内存划分为几块; 一般是把 Java 堆分为新生代和老年代, 在新生代采用复制算法, 在老年代采用 "标记 - 清理" 或 "标记 - 整理" 算法

#### HotSpot 的算法实现
以上介绍了对象存活判定算法和垃圾收集算法, HotSpot 在实现这些算法时必须对算法的执行效率有严格的考量, 才能保证虚拟机高效运行

##### 枚举根节点
从可达性分析中自 GC Roots 节点找引用链, 可作为 GC Roots 的节点主要在全局性的引用和执行上下文中, 但很多应用仅方法区就有数百兆, 如果要逐个检查所用引用, 必然会耗费很多时间  
另外, 可达性分析对执行时间敏感还体现在 GC 的停顿上, 因为这项分析工作必须在一个能确保一致性的快照中进行, 这里的一致性的意思是指在整个分析期间整个执行系统看起来就像被冻结在某个时间点上, 不可以出现分析过程中对象引用关系还在不断变化的情况; 如果这一点不能满足分析结果则无准确性可言; 这一点是导致 GC 进行时必须停顿所有 Java 执行线程 (传说中的 Stop The World) 的其中一个重要原因, 即使是在号称 (几乎) 不会发生停顿的 CMS 收集器中, 枚举根节点时也是必须要停顿的  
目前的主流 Java 虚拟机使用的都是准确式 GC, 即所有执行系统停顿下来后, 并不需要一个不漏的检查湾所有执行上下文和全局的引用位置; HotSpot 使用一组称为 OopMap 的数据结构来达到这个目的, 在类加载完成的时候, HotSpot 就把对象内什么偏移量上是什么类型的数据计算出来, 这样 GC 在扫描时就可以直接得知这些信息了  

##### 安全点
在 OopMap 的协助下, HotSpot 可以完成快速准确的 GC Roots 枚举; HotSpot 并没有为每条指令都生存 OopMap, 只是在 "特定的位置" 记录了这些信息, 这些位置称为安全点 (Safepoint), 即程序执行只有到了安全点才能停顿下来开始 GC; 安全点的选定既不能太少以致于让 GC 等待时间太长, 也不能过于频繁增大运行负荷; 所以基本上是以程序 "是否具有让程序长时间执行的特征" 为标准选定的  
对于安全点另一个需要考虑的问题是如何在 GC 发生时让所有线程都跑到最近的安全点上停顿下来; 这里有两种方案选择
- 抢先式中断: 抢先式中断不需要线程的执行代码主动去配合, 在 GC 发生时, 首先把所有线程全部中断, 如果发现线程中断的地方不在安全点上, 就恢复线程让其跑到安全点上; 现在几乎没有虚拟机采用这种方式
- 主动式中断: 主动式中断的思想是当 GC 需要中断线程时, 不直接对线程操作, 仅仅简单的设置一个标志, 各个线程执行时主动去轮询这个标志, 发现中断标志时自己挂起, 轮询标志的地方和安全点是重合的

##### 安全区
使用安全点保证了程序在执行时, 在不太长的时间内就会遇到可进入的 GC 安全点; 但是程序在不执行 (没有分配到 CPU 时间) 的时候, 这些线程无法响应 JVM 的中断请求, 走到安全点挂起, JVM 也不可能等待线程重新被分配时间; 这种情况就需要安全区来解决  
安全区是指在一段代码片段中, 引用关系不会发生变化; 在这个区域内的任意地方开始 GC 都是安全的, 也可以把安全区看成是被扩展的安全点

#### 垃圾收集器  
在介绍这些收集器各自特性之前, 需要明确的观点是: 虽然是对各个收集器进行比较, 但并非为了挑选出一个最好的收集器; 因为直到现在为止还没有最好的收集器出现, 更没有万能的收集器, 所以选择的是对具体应用最合适的收集器

##### Serial 收集器
Serial 收集器是最基本, 发展历史最悠久的收集器, 在 JDK 1.3.1 之前是虚拟机新生代收集的唯一选择; 此收集器是一个单线程收集器, 但它 "单线程" 的含义并不仅仅说明它只会使用一个 CPU 和一个收集线程去完成垃圾收集工作, 更重要的是它进行垃圾收集时, 必须暂停其他所有的工作线程, 直到收集完毕  
从 JDK 1.3 开始, 一直到现在最新的 JDK 1.7, HotSpot 虚拟机开发团队为消除或减少工作线程因为内存回收而导致停顿的努力一直在进行着; 从 Serial 收集器到 Parallel 收集器, 再到 Concurrent Mark Sweep (CMS) 乃至 GC 收集器的最前沿成果 Garbage First (G1) 收集器; 但实际上到目前为止, Serial 收集器仍然是虚拟机在 Client 模式下的默认的新生代收集器; 相对其他收集器的单线程比, Serial 收集器简单而高效, 对于限定的单个 CPU 环境来说 Serial 收集器是很好的选择

##### ParNew 收集器
ParNew 收集器是 Serial 收集器的多线程版本, 除了使用多条线程进行垃圾收集之外, 其余行为包括 Serial 收集器可用的所有控制参数 (例如: -XX:SurvivorRatio, -XX:PetenureSizeThreshold, -XX:HandlePromotionFailure 等), 收集算法, Stop The World, 对象分配规则, 回收策略和 Serial 收集器完全一样; 虽然与 Serial 收集器相比没有太多创新处, 但却是 Server 模式下的首选新生代收集器, 其中有一个与性能无关的但重要的原因, 除了 Serial 收集器外, 目前只有 ParNew 收集器能与 CMS 收集器配合工作; 在 JDK 1.5 时期推出了 CMS (Concurrent Mark Sweep) 收集器, 这款收集器第一次实现了让垃圾收集线程与用户线程同时工作  
不幸的是, CMS 作为老年代的收集器, 却无法和 JDK 1.4 中已存在的新生代收集器 Parallel Scavenge 配合工作, 所以在 JDK 1.5 中使用 CMS 收集老年代时, 新生代只能选择 ParNew 收集器或 Serial 收集器中的一个; ParNew 收集器也是使用 -XX:+UseConcMarkSweepGC 选项后的默认新生代收集器, 也可以使用 -XX: UseParNewGC 选项来强制指定它  
ParNew 收集器在单 CPU 的环境中绝对不会有比 Serial 收集器有更好的效果, 但随着可使用的 CPU 数量的增加, 对于 GC 时系统资源的有效利用还是很有好处的; 它默认开启的收集线程数与 CPU 的数量相同, 在 CPU 非常多的环境下, 可以使用 -XX: ParallelGCThreads 参数来限制垃圾收集的线程数

###### 在垃圾收集器的上下文语境中的并行和并发
- 并行 (Parallel): 指多条垃圾收集线程并行工作, 但此时用户线程仍然处于等待状态
- 并发 (Concurrent): 指用户线程与垃圾收集线程同时执行 (但不一定时并行的, 可能会交替执行), 用户程序在继续运行, 而垃圾收集程序运行于另一个 CPU 上

##### Parallel Scavenge 收集器
Parallel Scavenge 收集器是一个新生代收集器, 也是使用复制算法的收集器, 也是并行的多线程收集器; 但它的特点是与其他收集器关注点不同, Parallel Scavenge 收集器的目标是达到一个可控制的吞吐量; 所谓吞吐量就是 CPU 用于运行用户代码时间和 CPU 总消耗时间的比值, 即吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间), 虚拟机总共运行了 100 分钟, 其中垃圾收集占 1 分钟, 那吞吐量就是 99 %  
停顿时间越短就越适合需要与用户交互的程序, 良好的响应速度能提升用户体验; 而高吞吐量则可以高效率的利用 CPU 时间, 尽快完成程序的运算任务, 更适合在后台运算而不需要太多交互的任务  
Paralle Scavenge 收集器提供了两高个参数用于精确控制吞吐量, 分别是控制最大垃圾收集停顿时间的 -XX:MaxGCPauseMillis 参数以及直接设置吞吐量大小的 -XX: GCTimeRatio 参数; MaxGCPauseMillis 参数允许的值是一个大于 0 的毫秒值, 收集器尽可能的保证内存回收花费的时间不超过设定值, 但 GC 停顿时间是以牺牲吞吐量和新生代空间换取的; GCTimeRatio 参数允许一个大于 0 且小于 100 的整数, 这也就是垃圾收集时间与用户代码运行时间比率的倒数; 默认是 99, 即允许最大 1% (1 / (1 + 99)) 的垃圾时间  
由于与吞吐量关系密切, Paralle Scavenge 收集器也常被称为 "吞吐量优先" 收集器; 除上述参数外, Paralle Scavenge 收集器还有一个参数 =XX:+UseAdaptiveSizePolicy 参数, 当此参数打开后就不需要手工指定大部分细节参数了, 虚拟机会根据当前系统的运行情况收集性能监控信息动态调整参数, 只需要手工设置好 -Xmx, MaxGCPauseMillis, GCTimeRatio 等参数即可; 这种方式也称为 GC 自适应的调节策略

##### Serial Old 收集器
Serial Old 是 Serial 收集器的老年代版本, 同样是一个单线程收集器, 使用 "标记-整理" 算法; 这个收集的主要意义也是在于给 Client 模式下的虚拟机使用的; 如果在 Server 模式下主要有两大用途: 一种用途是在 JDK 1.5 以及之前的版本中于 Paralle Scavenge 收集器搭配使用, 另一种用途就是作为 CMS 收集器的后备方案, 在并发收集发生 Concurrent Mode Failure 时使用  

##### Parallel Old 收集器
Parallel Old 是 Parallel Scavenge 收集器的老年代版本, 使用多线程和 "标记 - 整理" 算法; 这个收集器在 JDK 1.6 中才开始提供, 在此之前新生代的 Parallel Scavenge 收集器一直处于比较尴尬的状态, 因为老年代收集器只能选 Serial Old 收集器, 因为 CMS 收集器不支持; 由于老年代收集拖累了 Parallel Scavenge 收集器, 所以在老年代很大且硬件比较高级的环境中, Parallel Scavenge 收集器与 Serial Old 收集器的组合的吞吐量不一定比 ParNew + CMS 好; 直到有了 Parallel Old 收集器, 所以在注重吞吐量以及 CPU 资源敏感的场景可优先考虑 Parallel Scavenge + Parallel Old 组合  

##### CMS 收集器
CMS (Concurrent Mark Sweep) 收集器是一种以获取最短停顿时间为目标的收集器, 从名字上可以看出 CMS 收集器是居于 "标记 - 清除" 算法实现的, 它的运作过程相对于前几种收集器来说更复杂一些, 整个过程分为 4 个步骤
- 初始标记
- 并发标记
- 重新标记
- 并发清除

其中, 初始标记和重新标记这两个步骤仍然需要 "Stop The World"; 初始标记仅仅是标记一下 GC Roots 能直接关联到的对象, 速度很快; 并发标记就是进行 GC Roots Tracing 的过程; 而重新标记则是为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录, 这个阶段的停顿时间一般会比初始标记阶段稍长一些, 但远比并发标记的时间短  
由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作, 所以总体上来说, CMS 收集器的内存回收过程是用户线程一起并发执行的; CMS 是一款优秀的收集器, 它主要在于并发收集和低停顿; 但 CMS 远达不到完美的程度, 它有以下三个缺点
- CMS 收集器对 CPU 资源非常敏感: 在并发阶段虽然不会导致用户线程停顿, 但是因为占用了一部分线程 (或者说 CPU 资源)
而导致应用程序变慢, 总吞吐量变低; CMS 默认启动的回收线程数是 (CPU 数量 + 3) / 4, 也就是当 CPU 在 4 个以上时, 并发回收时垃圾收集线程不少于 25% 的 CPU 资源, 并且随着 CPU 数量的增加而下降; 但当 CPU 不足 4 个时, CMS 对用户程序的影响就可能变得很大; 为了应付这种情况, 虚拟机提供了一种称为 "增量式并发收集器 (Incremental Concurrent Mark Sweep / i-CMS)" 的 CMS 收集器变种, 使用抢占式模拟多任务机制的思想一样, 就是在并发标记, 清理的时候让 GC 线程, 用户线程交替运行, 尽量减少 GC 线程的独占资源的时间, 这样整个垃圾收集的过程会更长, 但对用户程序的影响就会显的少一些; 但实践证明, 增量式的 CMS 收集器效果很一般, 已不再提倡用户使用  
- CMS 收集器无法处理浮动垃圾 (Floating Gaebage), 可能出现 "Concurrent Mode Failure" 失败而导致另一次 Full GC 的产生: 由于 CMS 并发清理阶段用户线程还在运行着, 伴随程序运行自然就还会有新的垃圾不断产生, 这一部分垃圾出现在标记之后, CMS 无法在当次收集中处理掉它们, 只好留待下一次 GC 时再清理掉, 这一部分垃圾就称为 "浮动垃圾"; 也是由于再垃圾收集阶段用户线程还需要运行, 就需要预留足够的内存空间给用户线程使用, 因此 CMS 收集器不能像其他收集器那样等到老年代几乎用完再进行收集, 需要预留一部分空间提供并发收集时的程序运行使用; 在 JDK 1.5 的默认设置下, CMS 收集器当老年代使用了 68% 的空间后就会被激活, 这是一个偏保守的设置, r如果在应用中老年代增长的不是太快, 可以适当调高参数 -XX:CMSInitiatingOccupancyFraction 的值来提高触发百分比, 以便降低内存回收次数而获得更好的性能, 在 JDK 1.6 中, CMS 收集器的启动阈值已经提升至 92%; 要是 CMS 运行期间预留的内存无法满足程序需要, 就会出现一次 "Concurrent Mode Failure" 失败, 这时虚拟机将启动后备预案: 临时启动 Serial Old 收集器来重新进行老年代的垃圾收集, 这样停顿时间就很长了; 所以参数 -XX:CMSInitiatingOccupancyFraction 设置的太高很容易导致大量 "Concurrent Mode Failure" 失败, 性能反而降低  

##### G1 收集器
G1 是一款面向服务端应用的垃圾收集器, HotSpot 赋予它的使命是未来可以替换掉 JDK 1.5 中发布的 CMS 收集器, 与其他 GC 收集器比具备以下特点
- 并行与并发: G1 能充分利用多 CPU, 多核环境下的硬件优势, 使用多个 CPU 来缩短 Stop The World 停顿的时间, 部分其他收集器原本需要停顿 Java 线程执行的 GC 动作, G1 收集器仍然可以通过并发的方式让 Java 程序继续执行
- 分代收集: 分代的概念在 G1 中依然得以保留, 虽然 G1 可以不需要配合其他收集器就能独立管理整个 GC 堆, 但它能够采用不同的方式去处理新创建的对象和已经存活一段时间, 熬过多次 GC 的旧对象以获取更好的收集效果
- 空间整合: 与 CMS 的 "标记 - 整理" 算法不同, G1 从整体来看是基于 "标记 - 整理" 算法实现的收集器, 从局部上 (两个 Region 之间) 看来是基于 "复制" 算法实现的; 当无论如何, 这两种算法都意味着 G1 运行期间不会产生内存空间碎片, 收集后能提供规整的可用内存,
- 可预测的停顿: 这是 G1 相对与 CMS 的另一大优势, 降低停顿时间是 G1 和 CMS 共同的关注点, 但 G1 除了追求低停顿外, 还能建立可预测的停顿时间模型, 能让使用者明确指定在一个长度为 M 毫秒的时间段内, 消耗在垃圾收集上的时间不得超过 N 毫秒

G1 收集器的收集范围不再是整个新生代或老生代, Java 堆的内存布局就与其他收集器的有很大区别; 它将整个 Java 堆划分为多个大小相等的独立区域 (Region), 虽然还保留着新生代和老年代的概念, 但新生代和老年代不再是物理隔离, 它们都是一部分 Region (不需要连续) 的集合  
G1 收集器之所以能建立可预测的停顿时间模型, 是因为它可有计划的避免在整个 Java 堆中进行全区域的垃圾收集; G1 跟踪各个 Region 里的垃圾堆积的价值大小, 在后台维护一个优先列表, 每次根据允许的收集时间, 优先回收价值最大的 Region; G1 收集器的运行大致可以划分为以下几个步骤
- 初始标记
- 并发标记
- 最终标记
- 筛选回收

初始标记阶段仅仅只是标记一下 GC Roots 能直接关联到的对象, 并且修改 TAMS (Next Top at Mark Start) 的值, 让下一阶段用户程序并发运行时, 能在正确可用的 Region 中创建新对象, 这阶段需要停顿线程, 但耗时很短; 并发标记阶段是从 GC Roots 开始对队中对象进行可达性分析, 找出存活的对象, 这阶段耗时较长, 但可以与用户程序并发执行; 最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录, 虚拟机将这段时间对象变化记录在线程 Remembered Set Logs 中, 最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中, 这阶段需要停顿线程, 但是可并行执行; 最后在筛选阶段首先对各个 Region 的回收价值和成本进行排序, 根据用户所期望的 GC 停顿时间来制定回收计划  

TODO...

##### 理解 GC 日志
每一种收集器的日志形式都是由它们自身实现所决定的, 即每个收集器的日志形式都可以不一样; 但虚拟机设计者为了方便用户阅读, 将各个收集器都维持一定的共性, 以下是两段典型的 GC 日志
```
33.125: [GC [DefNew: 3324K -> 152K(3712K), 0.0025925 secs] 3324K -> 152K(11904K), 0.0031680 secs]
100.667: [Full GC [Tenured: 0K -> 210K(10240K), 0.0149142 secs] 4603K -> 210K(19456K), [Perm: 2999K -> 2999K(21248K)], 0.015007 secs] [Times: user=0.01 sys=0.00, real=0.02 secs]
```
数字 "33.125" 和 "100.167" 代表 GC 发生的时间, 这个数字的含义是从 Java 虚拟机启动以来经过的秒数; GC 日志开头的 "[GC" 和 "[Full GC" 说明了这次垃圾收集的停顿类型, 如果有 "Full" 说明是发生了 STW 的
```
[Full GC 283.736: [ParNew: 261599K -> 261599K(261952K), 0.0000288 secs]]
```
这段新生代收集器 ParNew 的日志也会出现 "[Full GC" (这一般是因为出现了分配担保失败之类的问题, 所以才导致 STW); 如果是调用了 System.gc() 方法所触发的收集, 那么这里将显示 "[Full GC(System)]"; 接下来的 "[DefNew", "[Tenured", "[Perm" 表示 GC 发生的区域, 这里显示的区域名称与使用的 GC 收集器有关, 例如上面样例所使用的 Serial 收集器中的新生代名为 "Default New Generation", 所以显示的是 "[DefNew"; 如果是 ParNew 收集器, 新生代的名称就会变为 "[ParNew", 意为 "Parallel New Generation"; 如果采用 Parallel Scavenge 收集器, 那么它配套的新生代称为 "PSYoungGen", 老年代和永久代同理, 名称也是由收集器决定的  
后面方括号内部的 "3324K -> 152K(3712K)" 含义是 "GC 前该内存区域已使用容量 -> GC 后该内存区域已使用容量(该内存区域总含量)"; 方括号之外的 "3324K -> 152K(11904K)" 表示 "GC 前 Java 堆已使用容量 -> GC 后 Java 堆已使用容量(Java 堆总容量)";  
再往后的 "0.0025925 secs" 表示该内存区域 GC 所占用的时间, 单位是秒; 有的收集器会给出更具体的时间数据, 如 "[Times: user=0.01 sys=0.00, real=0.02 secs]", 这里的 user, sys, real 与 Linux 的 time 命令输出的时间含义一致, 分别代表用户态消耗的 CPU 时间, 内核态消耗的 CPU 时间和操作从开始到结束所经过的墙钟时间 (Wall Clock Time); CPU 时间和墙钟时间的区别是, 墙钟时间包括各种非运算的等待耗时, 例如等待磁盘 I/O, 等待线程阻塞, 而 CPU 时间不包括这些耗时, 但当系统有多 CPU 或者多核的话, 多线程操作会叠加这些 CPU 时间, 所以可能看到 user 或 sys 时间超过 real 时间  

##### 垃圾收集器参数总结
JDK 1.7 中各种垃圾收集器相关的常用参数整理如下

|参数|描述|
|-|-|
|UseSerialGC|虚拟机运行在 Client 模式下的默认值, 打开此开关后, 使用 Serail + Serail Old 的收集器组合进行内存回收|
|UseParNewGC|打开此开关后, 使用 ParNew + Serial Old 的收集器组合进行内存回收|
|UseConcMarkSweepGC|打开此开关后, 使用 ParNew + CMS + Serial Old 的收集器组合进行内存回收; Serail Old 收集器将作为 CMS 收集器出现 Concurrent Mode Failure 失败后的后备收集器使用|
|UseParallelGC|虚拟机运行在 Server 模式下的默认值, 打开此开关后, 使用 Parallel Scavenge + Serial Old (PS MarkSweep) 的收集器组合进行内存回收|
|UseParallelOldGC|打开此开关后, 使用 Parallel Scavenge + Parallel Old 的收集器组合进行内存回收|
|SurvivorRatio|新生代中 Eden 区域与 Survivor 区域的容量比值, 默认为 8, 代表 Eden : Survivor = 1 : 8|
|PretenureSizeThreshold|直接晋升到老年代的对象大小, 设置这个参数后, 大于这个参数的对象将直接在老年代中分配|
|MaxTenuringThreshold|晋升到老年代的对象年龄; 每个对象在坚持过一次 Minor GC 之后, 年龄就增加 1, 当超过这个参数值时就进入老年代|
|UseAdaptiveSizePolicy|动态调整 Java 堆中各个区域的大小以及进入老年代的年龄|
|HandlePromotionFailure|是否允许分配担保失败, 即老年代的剩余空间不足以应付新生代的整个 Eden 和 Survivor 区的所有对象都存活的极端情况|
|ParallelGCThreads|设置并行 GC 时进行内存回收的线程数|
|GCTimeRatio|GC 时间占总时间的比率, 默认值为 99, 即允许 1% 的 GC 时间; 仅在使用 Parallel Scavenge 收集器时生效|
|MaxGCPauseMillis|设置 GC 的最大停顿时间, 仅在使用 Parallel Scavenge 收集器时生效|
|GMSInitiatingOccupancyFraction|设置 CMS 收集器在老年代空间被使用多少后触发垃圾收集; 默认值为 68%, 仅在使用 CMS 收集器时生效|
|UseCMSCompactAtFullCollection|设置 CMS 收集器在完成垃圾收集器后是否要进行一次内存碎片整理; 仅在使用 CMS 收集器时生效|
|CMSFullGCsBeforeCompaction|设置 CMS 收集器在进行若干此次垃圾收集器后再启动一次内存碎片整理; 仅在使用 CMS 收集器时生效|

#### 内存分配与回收策略
以上已经讲述了虚拟机中内存回收的垃圾回收器体系以及原理, 以下将探讨如何给对象分配内存  
对象的内存分配大的方向上讲就是在堆上分配 (但也可能经过 JIT 编译后被拆散为标量类型并间接地栈上分配), 对象主要时分配在新生代地 Eden 区, 如果启动了本地线程分配缓冲, 将按线程优先地在 TLAB 上分配; 少数情况下也可能会直接分配在老年代中, 分配地规则并不是百分之百固定的, 其细节取决于当前使用的是哪一种垃圾收集器组合, 还有虚拟机中的内存相关的参数设置

##### 对象优先在 Eden 分配
大多数情况下对象优先在 Eden 区分配, 当 Eden 区没有足够空间进行分配时, 虚拟机将发起一次 Minor GC; 虚拟机提供了 -XX:+PrintGCDetails 这个收集器日志, 告诉虚拟机在发生垃圾收集行为时打印内存回收日志, 并且在进程退出的时候输出当前内存各区域分配情况
TODO...

###### Minor GC 和 Full GC 的区别
- 新生代 GC (Minor GC): 指发生在新生代的垃圾收集动作, 因为 Java 对象大多都具备朝生夕灭的特性, 所以 Minor GC 非常频繁, 一般回收速度也较快
- 老年代 GC (Major GC/ Full GC): 指发生在老年代的 GC, 出现了 Major GC, 经常会伴随着至少一次的 Minor GC (在 Parallel Scavenge 收集器的收集策略里就有直接进行 Major GC 的策略选择过程); Major GC 的速度一般会比 Mino GC 慢 10 倍以上

##### 大对象直接进入老年代
所谓的大对象是指需要连续内存空间的 Java 对象, 最典型的大对象就是那种很长的字符串以及数组; 大对象对虚拟机的内存分配来说就是一个坏消息 (比一个大对象更加坏的消息是遇到一群 "朝生夕灭" 的 "短命大对象"), 经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取连续空间来 "安置" 它们  
虚拟机提供了一个 -XX: PretenureSizeThreshold 参数, 令大于这个设置值的对象直接在老年代分配, 这样做的目的是避免在 Eden 区以及两个 Survivor 区之间发生大量的内存复制 (此参数只对 Serial 和 ParNew 两款收集器有效, Parallel Scavenge 收集器不认识这两个参数, Parall Scavenge 收集器一般并不需要设置, 如果遇到必须使用参数的场景, 可以考虑 ParNew + CMS 的收集器组合)
TODO...

##### 长期存活的对象将进入老年代
Java 虚拟机采用了分代收集的思想, 那么内存回收时就必须能识别哪些对象应该放在新生代, 哪些对象应该放在老年代; 为做到这一点, 虚拟机每个对象定义了一个对象年龄 (Age) 计数器; 如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活, 并且能被 Survivor 容纳的话, 将被移动到 Survivor 空间中, 并且对象年龄设为 1; 对象在 Survivor 区中每 "熬过" 一次 Minor GC, 年龄就增加 1 岁, 当它的年龄增加到一定程度 (默认为 15 岁), 就会被晋升到老年代中; 对象晋升老年代的年龄阈值, 可以通过参数 -XX: MaxTenuringThreshold 设置
TODO...

##### 动态对象年龄判定
为了能更好地适应不同程序地需要, 虚拟机并不是永远要求对象的年龄达到了 MaxTenuringThreshold 才能晋升老年代, 如果在 Survivor 空间中相同年龄对象大小的总和大于 Survivor 空间的一半, 年龄大于或等于该年龄的对象就可以直接进入老年代, 无须等到 MaxTenuringThreshold 中要求的年龄
TODO...

##### 空间分配担保
在发生 Minor GC 之前, 虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间, 如果这个条件成立, 那么 Minor GC 可以确保是安全的; 如果不成立, 则虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败; 如果允许, 那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小, 如果大于, 将尝试着进行一次 Minor GC, 尽管这个 Minor GC 是有风险的; 如果小于, 或者 HandlePromotionFailure 设置不允许冒险, 那这时也要改为进行一次 Full GC  
这里的风险是指此次分配担保的内存大小远高于历次的平均值, 并导致担保分配失败 (Handle Promotion Failure); 如果出现这种情况, 那就只好在失败后再进行一次 Full GC; 虽然担保失败时绕的圈子是最大的, 但大部分情况下都还是会将 HandlePromotionFailure 开关打开, 避免 Full GC 过于频繁; JDK 6 Update 24 之后此参数已不再使用, 规则也变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行 Minor GC, 否则将进行 Full GC
TODO...

>**参考:**
[TLAB](http://blog.csdn.net/a860mhz/article/details/52694509)  
[JVM源码分析之线程局部缓存TLAB](https://www.jianshu.com/p/cd85098cca39)  
[Java常见面试题—栈分配与TLAB](http://blog.csdn.net/xiaomingdetianxia/article/details/77688945)  
