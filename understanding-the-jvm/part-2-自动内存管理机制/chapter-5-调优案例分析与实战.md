### 调优案例分析与实战
Java 与 C++ 之间有一堵有内存动态分配和垃圾收集技术所围成的 "高墙", 墙外面的人想进去, 墙里面的人却想出来

#### 概述
TODO...

#### 案例分析
TODO...

##### 高性能硬件上的程序部署策略
一个 15 万 PV / 天左右的在线文档类型网站最近更换了硬件系统, 新的硬件为 4 个 CPU, 16 GB 物理内存, 操作系统为 64 位 CentOS 5.4, Resin 作为 Web 服务器; 整个服务器暂时没有部署别的应用, 所有硬件资源都可以提供给这访问量并不算太大的网站使用, 管理员位了尽量使用硬件资源选用了 64 位的 JDK 1.5, 并通过 -Xmx 和 -Xms 参数将 Java 堆固定在 12 GB; 使用一段时间后发现效果并不理想, 网站经常不定期出现长时间失去响应的情况  
监控服务器运行状态后发现网站失去响应是由 GC 停顿导致的, 虚拟机运行在Server 模式, 默认使用吞吐量优先收集器, 回收 12 GB 的堆, 一次 Full GC 的停顿时间长达 14 秒; 并且由于程序设计的关系, 访问文档时要把文档从磁盘提取到内存中, 导致内存中出现很多由文档序列化产生的大对象, 这些大对象很多进入了老年代, 没有在 Minor GC 中清理掉; 这种情况下即使有 12 GB 的堆, 内存也很快被消耗殆尽, 由此导致每个十几分钟出现十几秒的停顿  
先不考虑程序代码的问题, 程序部署上的主要问题显然是过大的堆内存进行回收时带来的长时间的停顿; 硬件升级前使用 32 位系统 1.5 GB 的堆, 用户只感觉到使用网站比较缓慢, 但不会发生十分明显的停顿, 因此才考虑升级硬件以体提升程序效能, 如果重新缩小给 Java 堆分配的内存, 那么硬件升的投资就显得浪费; 在高性能硬件上部署程序, 目前主要有两种方式:
- 通过 64 位 JDK 来使用大内存
- 使用若干个 32 位虚拟机建立逻辑集群来利用硬件资源

#####
