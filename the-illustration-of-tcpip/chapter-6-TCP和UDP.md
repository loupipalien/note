### TCP 和 UDP
TCP/IP 中具有代表性的传输层协议, TCP 和 UDP

#### 传输层定义
IP 首部中有一个协议字段, 用来识别网络层 (IP) 的上一层采用的是哪一种传输层协议, 根据这个字段的协议号, 就可以识别 IP 传输的数据部分究竟是 TCP 还是 UDP 的内容; 同样, 传输层的 TCP 和 UDP, 为了识别自己所传输的数据部分究竟应该发送给哪个应用, 也设定了这样一个编号

##### 通信处理
TCP/IP 的众多应用协议大多以客户端/服务端的形式运行, 服务端的程序有必要提前启动, 时刻准备接收客户端的请求, 否则即使有客户端的请求发过来, 也无法做到相应的处理  
确认一个请求究竟是发给的是哪个服务端 (守护进程), 可以通过所收到的数据包的目标端口号识别

##### 两种传输层协议 TCP 和 UDP
- TCP
TCP 是面向连接的, 可靠的流协议; 流就是指不间断的数据结构, 当应用程序采用 TCP 发送消息时, 虽然可以保证发送顺序, 但还是不能没有任何间隔的数据流发送给接收端
- UDP
UDP 是不具有可靠性的数据报协议, 在这种情况下, 虽谈可以保证发送消息的大小, 但不能保证消息一定会到达

##### TCP 与 UDP 区分
TCP 与 UDP 应按需使用 (应用程序利用套接字可以设置对端的 IP 地址, 端口号, 并实现数据的发送与接收)

#### 端口号
##### 端口号定义
数据链路和 IP 中的地址, 分别指的是 MAC 地址和 IP 地址; 前者用来识别同一链路中不同的计算机, 后者用来识别 TCP/IP 网络中互连的主机和路由器; 在传输层中也有这种类似地址的概念, 就是端口号; 端口号用来识别同一计算机中进行通信的不同应用程序, 因此也被称为程序地址

##### 根据端口号识别应用
传输层协议正是利用端口号识别本机中正在进行通信的应用程序, 并准确的将数据传输

##### 通过 IP 地址, 端口号, 协议号进行通信识别
在使用 TCP/UDP 的通信中, 只有目标地址, 源地址, 目标端口, 源端口以及协议类型五项内容都一致时才会被认为是同一个通信连接

##### 端口号如何确定
- 标准既定的端口号
这种方法叫静态方法, 指每个应用程序都有其指定的端口号, 但并不是说随意使用任何一个端口号, 每个端口号都有其对应的使用目的
- 时序分配法
这种方法叫时序分配法, 服务端有必要确定监听端口号, 但是接受服务端的客户端没必要确定端口号; 在这种方法下, 客户端可以完全不用自己设置端口号, 全权交给操作系统分配即可, 操作系统可以为每个应用程序分配互不冲突的端口号; 动态分配的端口号取值范围在 49152 ~ 65535 之间

##### 端口号与协议
端口号由其使用的传输层协议决定, 因此不同传输协议可以使用相同的端口号???  
此外, 那些知名端口号与传输层协议并无关系, 只要端口一致都将分配同一种程序进行处理???

##### UDP (User Datagram Protocol)
UDP 不提供复杂的控制机制, 利用 IP 提供面向无连接的通信服务,  
并且它是将应用程序发来的数据收到的那一刻, 立即按照原样发送到网络上的一种机制  
由于 UDP 面向无连接, 它可以随时发送数据, 再加上 UDP 本身的处理既简单又高效, 因此经常用于以下几个方面
- 包总量较少的通信 (DNS, SNMP 等)
- 视频, 音频等多媒体通信 (即时通信)
- 限定于 LAN 等特定网络中的应用通信
- 广播通信 (广播, 多播)

##### TCP
TCP 实现了数据传输时各种控制功能, 可以进行丢包时的重发控制, 还可以对次序乱掉的分包进行顺序控制; 此外, TCP 作为一种面向连接的协议, 只有在确认通信对端存在是才会发送数据, 从而可以控制通信流量的浪费  
根据 TCP 的这些机制, 在 IP 这种无连接的网络上也能够实现高可靠性的通信  

##### TCP 的特点及其目的
TCP 通过检验和, 序列号, 确认应答, 重发控制, 连接管理以及窗口控制等机制实现可靠性传输

##### 通过序列号与确认应答提高可靠性
在 TCP 中, 当发送端的数据到达接收主机时, 接收端主机会返回一个已收到消息的通知, 这个消息叫做确认应答 (ACK)  
![TCP 的确认应答.png](http://ww1.sinaimg.cn/large/d8f31fa4ly1gbgx9ad3jvj208k0av0ss.jpg)  
TCP 通过肯定的确认应答 (ACK) 实现可靠的数据传输, 当发送端将数据发出之后会等待目标端的确认应答, 如果有确认应答, 说明数据已经成功到达目标端, 反之则数据丢失的可能性很大  
未收到确认应答并不意味着数据一定丢失, 也有可能是数据对方已经收到, 只是返回的确认应答在途中丢失, 这种情况也会导致发送端因没有收到确认应答, 而认为数据没有到达目的地, 从而进行重新发送  
此外也有可能因为一些其他原因导致确认应答延迟到达, 在源主机重发数据以后才到达的情况也很多, 此时源主机主要按照机制重发数据即可; 但对于目标主机来说, 这则是一种灾难, 它会反复收到相同的数据, 而对于上层应用提供可靠传输, 必须放弃重复的数据包, 这就必须引入一种机制, 它能够识别是否已经接收数据, 又能够判断是否需要接收  
上述这些确认应答处理, 重发控制以及重发控制等功能都可以通过序列号实现, 序列号是按照顺序给发送数据的每一个自己都标上号码的编号; 接收端查询接收数据 TCP 首部中的序列号和数据长度, 将自己下一步应该接收的序号作为确认应答返送回去, 这样通过序列号和确认应答号, TCP 可以实现可靠传输

##### 重发超时如何确定
重发超时是指在重发数据之前, 等待确认应答到来的那个特定时间间隔  
在 BSD 的 Unix 以及 Windows 系统中, 超时都是以 0.5 秒为单位的, 不过最初的数据包还不知道往返时间所以其重发超时一般设置为 6 秒左右; 数据被重发之后还是收不到确认应答, 则进行再次发送, 此时等待确认时间将会以 2 倍, 4 倍的指数函数延长, 当重发一定次数后仍没有确认应答则会判断为目标端主机异常, 关闭连接

##### 连接管理
TCP 在数据通信之前, 通过 TCP 首部发送一个 SYN 包作为建立连接的请求等待确认应答, 如果目标端发来确认应答, 则认为可以进行数据通信, 如果目标端的确认应答未能到达, 就不会进行数据通信, 此外在通信结束时会进行断开连接的处理 (FIN 包)  
可以使用 TCP 首部用于控制的字段来管理 TCP 连接, 一个连接的建立与断开, 正常过程至少需要来回发送 7 个包才能完成
![TCP  连接的建立与断开.png](http://ww1.sinaimg.cn/large/d8f31fa4ly1gbgy4frixnj20b60g8aam.jpg)  

##### TCP 以段为单位发送数据
在建立 TCP 连接的同时也可以确定发送数据包的单位, 可以称其为 "最大消息长度" (MSS: Maximum Segment Size); 最理想的情况是, 最大消息长度正好是 IP 中不会被分片处理的最大数据长度  
TCP 在传送大量数据时, 是以 MSS 的大小将数据进行分割发送, 进行重发时也是以 MSS 为单位; MSS 是在三次握手的时候, 在两端主机之间被计算出, 两端的主机在发出建立连接的请求时, 会在 TCP 首部中写入 MSS 选项, 告诉对方自己接口能够适应 MSS 的大小, 然后会在两者之间选择一个较小的值投入使用  
![接入以太网主机与接入FDDI主机之间通信的情况.png](http://ww1.sinaimg.cn/large/d8f31fa4gy1gbgzznc52zj20g90g8aau.jpg)  

##### 利用窗口控制提高速度
TCP 以 1 个段为单位, 每发一个段进行一次确认应答的处理; 这样的传输方式有一个特点, 那就是包的往返时间越长通信性能就越低  
TCP 引入了窗口的概念, 即使在往返时间较长的情况下, 它也能控制网络性能的下降, 确认应答不再是以每个分段, 而是以更大的单位进行确认, 转发时间将会被大幅度缩短, 也就是说发送端主机在发送了一个段以后不必要一直等待, 而是继续发送  
![TCP 用滑动窗口方式并行处理.png](http://ww1.sinaimg.cn/large/d8f31fa4gy1gbh0izhqydj20db0cgq37.jpg)  
窗口大小就是无需等待确认应答而可以继续发送数据的最大值, 例如上图中窗口大小为 4 个段, 这个机制实现使用了大量的缓冲区, 通过对多个段同时进行确认应答的功能  
在滑动窗口以外的部分包括尚未发送的数据以及已经确认对端收到的数据, 当数据发送后若如期确认应答就可以不用再进行重发, 此时数据就可以从缓存区清除; 在收到确认应答的情况下, 将滑动窗口滑动到确认应答中的序列号的位置, 这样就可以顺序的将多个段同时发送提高通信性能, 这种机制也称为滑动窗口机制  
![TCP 滑动窗口方式.png](http://ww1.sinaimg.cn/large/d8f31fa4gy1gbh10dqgssj20jq0820sy.jpg)  

##### 窗口控制与重发控制
在确认应答未能返回的情况下, 数据已经到达了对端, 是不需要进行重发的; 然而在没有使用窗口控制的时候, 没有收到确认的应答都会被重发, 而使用了窗口控制, 某些确认应答即便丢失了也无需重发  
当某一报文段丢失后, 发送端会一直收到序号为 1001 (假设序号为 1001) 的确认应答, 即提醒发送端 "麻烦发送从 1001 开始的数据"; 在窗口比较大, 又出现报文段丢失的情况下, 同一个序号的确认应答将会被重复不断地返回, 而发送端主机如果连续 3 次收到同一个确认应答, 就会将其所对应的数据进行重发, 这种机制比之前提到的超时管理更加高效, 因此也被称作高速重发控制

##### 流控制
为了放置接收端处理数据能力跟不上发送端的发送速度的情况, TCP 提供了一种机制可以让发送端根据接收端的实际接收能力控制发送的数据流, 这就是所谓的流控制; 具体的操作是, 接收端主机向发送端主机通知自己客户可以接收数据的大小, 于是发送daunt会发送不超过这个限度的数据, 该大小就被称作窗口大小  
TCP 首部中, 专门有一个字段用来通知窗口大小, 接收主机将自己可以接收的缓冲区大小放入这个字段中通知给发送端, 这个字段的值越大则说明网络吞吐量越高

##### 拥塞控制
一般来说, 计算机网络都处在一个共享环境中, 因此有可能因为其他主机之间的通信使得网络拥堵, 在网络出现拥堵时, 如果突然发送一个较大量的数据, 极有可能会导致整个网络瘫痪  
TCP 为了防止该问题的出现, 在通信一开始就会通过一个叫做慢启动的算法得出的数值, 对发送量进行控制  
为了在发送端调节所要发送数据的量, 定义了一个叫做 "拥塞窗口" 的概念, 于是在慢启动的时候, 将这个拥塞窗口的大小设置为 1 个数据段 (1 MSS) 发送数据, 之后每收到一次确认应答 (ACK), 拥塞窗口的值就加 1, 在发送数据包时, 将拥塞窗口的大小与接收端主机通知的窗口大小做比较, 然后按照它们当中较小的那个值, 发送比其还要小的数据量  
TCP 通信开始时, 并没有设置相应的慢启动阈值, 而是在超时重发时, 才会设置为当前拥塞窗口的一半大小

##### 提高网络利用率的规范
- Nagle 算法
TODO
- 延迟确认应答
TODO
- 捎带应答
TODO

##### 使用 TCP 的应用
TODO

#### 其他传输层协议
##### UDP-Lite
UDP-Lite (LightWweight User Datagram Protocol, 轻量级用户数据报协议) 是扩展 UDP 机能的一种传输层协议, 在基于 UDP 的通信当中如果校验和出现错误, 所收到的包将被全部丢弃; UDP-Lite 可以只针对不允许发生错误的部分进行校验和的检查, 对于其他部分, 即使发生了错误, 也会忽略不计, 并且这个包也不会被丢弃, 而是直接传给应用继续处理

##### SCTP
SCTP (Stream Control Transmission Protocol, 流控制传输协议) 与 TCP 一样, 都是对一种提供数据到达与否相关可靠性检查的传输层协议, 其主要特点如下
- 以消息为单位发送
TCP 中接收端不知道发送端应用所决定的消息大小, 在 SCTP 中可以
- 支持多重宿主
在有多个 NIC 的主机中, 即使其中能够使用的 NIC 发生变化, 也仍然可以继续通信
- 支持多数据流通信
TCP 中建立多个连接以后才能进行通信的效果, 在 SCTP 中一个连接就可以
- 可以定义消息的生存期限
超过生存期限的消息, 不会被重发

##### DCCP
DCCP (Datagram Congestion Control Protocol, 数据报拥塞控制协议) 是一个辅助 UDP 的崭新的传输层协议, UDP 没有拥塞控制机制, 当应用使用 UDP 发送大量数据包时极容易出现问题; DCCP 具有以下几个特点
- 与 UDP 一样, 不能提供发送数据的可靠性传输
- 它面向连接, 具备建立连接与断开连接的处理
- 能够根据网络拥堵情况进行拥塞控制
- 为了进行拥塞控制, 接收端收到包以后返回确认应答 (ACK), 该确认应答将被用于重发与否的判断

#### UDP 首部格式
TODO

#### TCP 首部格式
TODO
