### 数据类型和文件格式
Hive 支持关系型数据库中的大多数的基本数据类型, 同时也支持关系型数据库中很少出现的三种集合类型

#### 基本数据类型

|数据类型|长度|例子|
|---|---|---|
|TINYINT|1 byte 的符号整数|20|
|SMALLINT|2 byte 的符号整数|20|
|INT|4 byte 的符号整数|20|
|BIGINT|8 byte 的符号整数|20|
|BOOLEAN|布尔类型, true 或 false|TRUE|
|FLOAT|单精度浮点数|3.14159|
|DOUBLE|双精度浮点数|3.14159|
|STRING|字符序列; 可以指定字符集, 可以使用单引号或双引号|'now is the time', "for all good men"|
|TIMESTAMP(v0.8.0+)|整数, 浮点数或者字符串|1327882394 (Unix 新纪元秒), 1327882394.123456789 (Unix 新纪元秒并跟随有纳秒数) 和 '2012-02-03 12:34:56.123456789' (JDBC 所兼容的 java.sql.Timestamp 时间格式)|
|BINARY(v0.8.0+)|字节数组|见后续讨论|

需要注意的是所有的这些数据类型都是对 Java 中接口的实现, 因此这些类型的具体行为细节和 Java 中对应的类型是完全一致的; 例如, STRING 类型实现的是 Java 中的 String, FLOAT 实现的是 Java 中的 float 等; 在其他 SQL 方言中, 通常会提供限制最大长度的 "字符数组" (也就是很多字符串) 类型, 但需要注意的是 Hive 中不支持这种数据类型

#### 集合数据类型
Hive 中的列支持使用 struct, map 和 array 集合数据类型, 以下表中的语法示例实际上是调用内置函数

|数据类型|描述|字面语法示例|
|---|---|---|
|STRUCT|和 C 语言中的 struct 或者 "对象" 类型, 都可以通过 "点" 符号访问元素内容, 例如, 如果某个列的数据类型是 STRUCT{ first STRING, second STRING}, 那么第 1 个元素可以通过 字段名.first 来访问|strcut('John', 'Doe')|
|MAP|MAP 是一组键值对元组集合, 使用数组表示法 (例如 ['key']) 可以访问元素; 例如, 如果某个列的数据是 MAP, 其中键 -> 值对是 'first' -> 'John' 和 'last' -> 'Doe', 那么可以通过字段名 ['last'] 获取最后一个元素|map('first', 'John', 'last'， ’Doe)|
|ARRAY|数组是一组具有相同类型和名称的变量的集合; 这些变量称为数组的元素, 每个数组元素都有一个编号, 编号从零开始; 例如, 数组值为 ['John', 'Doe'], 那么第 2 个元素可以通过数组名 [1] 进行引用|array('John', 'Doe')

大多数的关系型数据库并不支持这些集合数据, 因为使用它们会趋向于破坏标准格式, 破坏标准格式所带来的一个实际问题是增大数据冗余的风险, 进而导致消耗不必要的磁盘空间, 还有可能造成数据不一致, 因为当数据发生变化时冗余数据可能无法进行相应的同步; 然而在大数据系统中, 不遵循标准格式的一个好处就是可以提供更高吞吐量的数据, 当处理的数据量级是 T 或 P 时, 以最少的 "头部寻址" 来从磁盘上扫描数据是非常必要的

#### 文本文件数据编码
用户应该很熟悉用逗号 (CSV) 或制表符 (TSV) 分隔的文本文件, 但是这两种文件格式都有一个共同的缺点, 那就是用户需要对文本文件中哪些不需要作为分隔符处理的逗号或制表符格外小心; 以下是 Hive 中默认的记录和字段分隔符

|分隔符|描述|
|\n|对于文本文件来说, 每一行都是一条记录, 因此换行符可以分割记录|
|^A (Ctrl + A)|用于分隔字段 (列); 在 CREATE TABLE 语句中可以使用八进制编码 \001 表示|
|^B|用于分隔 ARRAY 或者 STRUCT 中的元素, 或用于 MAP 中键值对之间分隔; 在 CREATE TABLE 语句中可以使用八进制编码 \002 表示|
|^C|用于 MAP 中键和值之间的分隔; 在 CREATE TABLE 语句中可以使用八进制编码 \003 表示|

#### 读时模式
当用户向传统数据库中写入数据的时候, 不管是采用装载外部数据的方式, 还是采用将一个查询的输出结果写入的方式, 或者是使用 UPTDAE 语句等等, 数据库对于存储都具有完全的控制力; 传统数据是写时模式 (schema on write), 即数据在写入数据库时对模式进行检查; Hive 对底层并没有这样的控制, 对于 Hive 要查询的数据, 有很多方式对其进行创建, 修改, 甚至破坏; 因此, Hive 不会在数据加载时就进行验证, 而是在查询时进行, 也就是读时模式  
当模式和文件内容并不匹配时: 如果每行记录中的字段个数少于对应的模式中定义的字段个数的话, 那么用户将会看到查询结果中有很多的 null 值; 如果某些字段是数值型的, 但是 Hive 在读取时发现存在向非数值型的字符串值字段的话, 那么对于那些字段将会返回 null 值; 除此之外的其他情况下, Hive 都极力尝试尽可能地将各种错误恢复回来  
