### 查询性能优化
查询的生命周期大致可以按照顺序来看: 从客户端, 到服务端, 在服务器上进行解析, 生成执行计划, 执行, 并返回结果给客户端; 其中 "执行" 可以认为是整个生命周期中最重要的阶段, 这其中包括了大量为了检索数据到存储引擎的调用以及调用后的数据处理, 包括排序分组等

#### 慢查询基础: 优化数据访问
大部分性能低下的查询都可以通过减少访问的数据量的方法进行优化; 对于低效的查询, 通过以下两个步骤的分析总是很有效
- 确认应用程序是否在检索大量超过需要的数据, 这通常意味着访问了太多的行, 但有时候也可能是访问了太多的列
- 确认 MySQL 服务器层是否在分析大量超过需要的数据行

##### 是否项数据库请求了不需要的数据
- 查询不需要的记录
- 多表关联时返回全部列
- 总是取出全部列
- 重复查询相同的数据

##### MySQL 是否在扫描额外的记录
对于 MySQL 最简单的衡量查询开销的三个指标
- 响应时间
- 扫描的行数
- 返回的行数

###### 响应时间
TODO
###### 扫描的行数和返回的行数
TODO
###### 扫描的行数和访问类型
一般 MySQL 能够使用如下三种凡是应用 WHERE 条件, 从好到坏依次为
- 在索引中使用 WHERE 条件来过滤不匹配的记录; 这是在存储引擎层完成的
- 使用索引覆盖扫描 (在 Extra 列中出现了 Using index) 来返回记录, 直接从索引中过滤不需要的记录并返回命中的结果; 这时在 MySQL 服务器层完成的, 但无须再回表查询记录
- 从数据表中返回数据, 然后过滤不满足条件的记录 (在 Extra 列中出现了 Where); 这在 MySQL 服务器层完成, MySQL 需要先从数据表读出记录然后过滤

#### 重构查询的方式
##### 一个复杂查询还是多个简单查询
设计查询的时候一个需要考虑的问题是, 是否需要将一个复杂的查询分成多个简单的查询; 在传统现实中, 总是强调需要数据库层完成尽可能多的工作, 这样做的逻辑在于以前总认为网络通信, 查询解析, 语句优化是一件代价很高的事, 但这样的想法对于 MySQL 并不适用
##### 切分查询
有时候对于一个大查询需要 "分而治之", 将大查询切分成小查询, 每个查询功能完全一样, 只完成一小部分, 每次值完成一个小部分查询结果
##### 分解关联查询 (???)
很多高性能的应用都会对关联查询进行分解, 将每个表进行单表查询然后将结果在应用程序中进行关联 ; 例如
```Sql
SELECT * FROM tag
JOIN tag_post ON tag_post.tag_id = tag.id
JOIN post ON tag_post.post_id = post.id
WHERE tag.tag = 'mysql';
```
可以分解为以下查询来代替
```Sql
SELECT * FROM tag WHERE tag = 'mysql';
SELECT * FROM tag_post WHERE tag_id = '1234';
SELECT * FROM post WHERE post.id IN (123, 456, 567, 9098, 8904);
```
用分解关联查询的方式重构查询有如下的优势
-  让缓存更有效率; 关联中的某个表发生了变化, 那么就无法使用查询缓存, 而拆分后如果某个表很少改变, 那么基于该表的查询就可以重复利用查询缓存结果了
- 将查询分解后, 执行单个查询可以减少锁的竞争
- 在应用层做关联, 可以容易对数据库进行拆分, 更容易做到高性能和可扩展
- 查询本身效率也可能有所提升
- 可以减少冗余记录的查询

#### 查询执行的基础
客户端项 MySQL 服务器发送一个请求的时候, MySQL 做了如下几件事
- 客户端发送一条查询给服务器
- 服务器先检查查询缓存, 如果命中了缓存, 则立刻返回存储在缓存中的结果, 否则进入下一阶段
- 服务器进行 SQL 解析, 预处理, 再由优化器生成对应的执行计划
- MySQL 根据优化器生成的执行计划, 调用存储引擎的 API 来执行查询
- 将结果返回给客户端

##### MySQL 客户端/服务器通信协议
MySQL 客户端和服务器之间的通信协议是 "半双工" 的, 这意味着在任何一个时刻, 要么是由服务器向客户端发送数据, 要么是由客户端向服务器发送数据  
当客户端从服务器取数时, 看起来是一个拉数据的过程, 但实际上是 MySQL 在向客户端推送数据的过程, 客户端不断地接收服务器推送的数据, 客户端没法方服务器停下来; 多数连接 MySQL 的库函数都可以获得全部结果集并缓存到内存里, 还可以逐行获取需要的数据, 默认一般是获得全部结果集并缓存到内存中; MySQL 通常需要等待所有的数据都已经发送给客户端才能释放这条查询所占用的资源, 所以接收全部结果并缓存通常可以减少服务器的压力, 让查询早点结束, 释放相应的资源
###### 查询状态
对于一个 MySQL 连接, 或者说一个线程, 任何时刻都有一个状态, 该状态标识了 MySQL 当前正在做什么; 可以使用 `SHOW FULL PROCESSLIST` 命令查看所有线程的状态
- Sleep: 线程正在等待客户端发送新的请求
- Query: 线程正在执行查询或者正在将结果发送给客户端
- Locked: 在 MySQL 服务器层, 该线程正在等待表锁; 在存储引擎级别实现的锁, 例如 InnoDB 的行锁, 并不会体现在线程状态中
- Analyzing and statistics: 线程正在收集存储引擎的统计信息, 并生成查询的执行计划
- Copying to tmp table [on disk]: 线程正在执行查询, 并且将其结果集都复制在一个临时表中, 这种状态一般要么是在做 GROUP BY 操作, 要么是文件排序操作, 或者是 UNINO 操作; 如果还带有 "on disk" 标记, 那表示 MySQL 正在将一个内存临时表放到磁盘上
- Sorting result: 线程正在对结果集进行排序
- Sending data: 这表示多种情况, 线程可能在多个状态之间传送数据, 或者在生成结果集, 或者在向客户端返回数据

##### 查询缓存
在解析一个查询语句之前, 如果查询缓存是打开的, 那么 MySQL 会优先检查这个查询是否命中查询缓存中的数据, 如果命中并且权限没有问题, MySQL 会跳过后续阶段直接从缓存中将结果返回给客户端

##### 查询优化处理
查询的生命周期的下一步时将一个 SQL 转换成一个执行计划, MySQL 再依赖这个执行计划和存储引擎进行交互; 这包括多个子阶段: 解析 SQL, 预处理, 优化 SQL 执行计划; 这个过程中任何错误都可能终止查询

###### 语法解释器和预处理
首先 MySQL 通过关键字将 MySQL 语句进行解析, 并生成一棵对应的 "解析树", MySQL 解析器将使用 MySQL 语法规则验证和解析查询  
接着, 预处理器则过呢据一些 MySQL 规则进一步检查解析树是否合法, 例如检查数据表和数据列是否存在, 名称指定是否有歧义  
最后, 预处理器将会验证权限

###### 查询优化器
语法树被检验合法后, 再由优化器将其转化为执行计划; 一条查询可以有很多中执行方式, 最后都返回相同的结果, 优化器的作用就是找到这其中最好的执行计划  
MySQL 使用基于成本的优化器, 它尝试预测一个查询使用某种执行计划时的成本, 并选择其中成本最小的一个; 最初, 成本的最小单位是随机读取一个 4K 数据页的成本, 后来 (成本计算公式) 变得非常复杂, 引入了一些 "因子" 来估算这些操作的代价; 执行一次查询的成本, 可以通常查询当前会话的 `Last_query_cost` 的值来得知 MySQL 计算的当前查询的成本
```SQL
SELECT SQL_NO_CACHE COUNT(*) FROM sakila.film_actor;
...
SHOW STATUS LIKE 'Last_query_cost'; // 1040
```
`Last_query_cost` 的值表示大概需要做多少个数据页的随机查询才能完成上述 SQL; 这是根据一系列的统计信息计算得来的: 每个表或索引的页面个数, 索引的基数 (索引中不同值的数量), 索引和数据行的长度, 索引分布情况; 优化器在评估成本时不考虑任何层面的缓存, 假定读取任何层数据都需要一次磁盘 I/O; 有很多原因会导致 MySQL 优化器选择错误的执行计划
- 统计信息不准确; MySQL 依赖存储引擎提供的统计信息来评估成本, 但有些存储引擎实现统计并不准确, 例如 InnoDB 因为其 MVCC 的架构, 并不能维护一个数据表行数的精确统计信息
- 执行计划中的成本估算不等同于实际执行的成本; 例如读取数据时不考虑页面是在内存中还是磁盘中, 是顺序 I/O 还是随机 I/O
- MySQL 的最优执行可能并不是最快执行
- MySQL 从不考虑其他并发执行的查询, 这可能会影响到查询速度
- MySQL 在某些特定的场景下可能不基于成本优化
- MySQL 不会考虑不受器控制操作的成本; 例如执行存储过程或者用户自定义函数的成本
- 优化器可能无法估算所有可能的执行计划, 所以可能错过实际上最优的执行计划

MySQL 的优化策略简单的分为两种: 静态优化和动态优化; 以下是一些 MySQL 能够处理的优化类型
- 重新定义关联表的顺序
- 将外连接转化为内连接
- 使用等价变换规则
- 优化 COUNT(), MIN(), MAX()
- 预估并转化为常数表达式
- 覆盖索引扫描
- 子查询优化
- 提前终止查询
- 等值传播
- 列表 IN() 的比较

###### 数据和索引的统计信息
统计信息由存储引擎实现
###### MySQL 如何执行关联查询
利用嵌套循环和回溯的方式完成表关联查询, 将中间结果放在临时表中保存, 最后查询临时表 (全外连接不能利用嵌套循环和回溯的方式实现, MySQL 也不支持)
###### 执行计划
TODO
###### 关联查询优化器
TODO
###### 排序优化
TODO

##### 查询执行引擎
在解析和优化阶段, MySQL 将生成查询对应的执行计划, MySQL 的查询执行引擎则根据这个执行计划来完成整个查询; 这里执行计划是一个数据结构, 而不是和很多其他的关系型数据库那样会生成对应的字节码
##### 返回结果给客户端
查询执行的最后一个阶段是将结果返回给客户端, 既是查询不需要返回结果集给客户端, MySQL 仍然会返回这个查询的一些信息, 如该查询影响到的行数; 如果查询可以被缓存, 那么 MySQL 在这个阶段也会将结果存放到查询缓存中  
MySQL 将结果集返回客户端是一个增量, 逐步返回的过程; 这样处理有两个好处: 一是服务端无须存储太多的结果, 也就不会因为要返回太多结果而消耗太多内存; 二是这样处理可以让客户端第一时间获得返回的结果

#### MySQL 查询优化器的局限性
MySQL 的万能 "嵌套循环" 并不是对每种查询都是最优的, 不过还好只对少部分查询不适用; MySQL 5.6 版本后消除了很多 MySQL 原本的限制
##### 关联子查询
TODO
##### UNION 的限制
TODO
##### 索引合并优化
TODO
##### 等值传递
TODO
##### 并行执行
TODO
##### 哈希关联
TODO
##### 松散索引扫描
TODO
##### 最大值和最小值优化
TODO
##### 在同一个表上查询和更新
TODO

#### 查询优化器的提示 (hint)
如果对优化器选择的执行计划不满意, 可以使用优化器提供的几个提示 (hint) 来控制最终的执行计划; 以下是 MySQL 可以使用的一些提示
- HIGH_PRIORITY, LOW_PRIORITY
- DELAYED
- STRAIGHT_JOIN
- SQL_SMALL_RESULT, SQL_BIG_RESULT
- SQL_BUFFER_RESULT
- SQL_CACHE, SQL_NO_CACHE
- SQL_CALC_FOUND_ROWS
- FOR UPDATE 和 LOCK IN SHARE MODE
- USE INDEX, IGNORE INDEX, FORCE INDEX
- optimizer_search_depth
- optimizer_prune_level
- optimizer_switch

#### 优化特定类型的查询

##### 优化 COUNT() 查询
TODO
##### 优化关联查询
- 确保 ON 或者 USING 子句中的列有索引
- 确保任何的 GROUP BY 或者 ORDER BY 中的表达式值涉及到一个表中的列, 这样 MySQL 才有可能使用索引来优化这个过程
- 当升级 MySQL 的时候需要注意: 关联语法, 运算符优先级等其他可能会发生变化的地方
##### 优化子查询
TODO
##### 优化 GROUP BY 和 DISTINCT
TODO
##### 优化 LIMIT
TODO
##### 优化 SQL_CALC_FOUND_ROWS
TODO
##### 优化 UNION 查询
TODO
##### 静态查询分析
TODO
##### 使用用户自定义变量
TODO

#### 案例学习
TODO
