### Schema 与数据类型优化

#### 选择优化的数据类型
MySQL 支持的数据类型非常多, 选择正确的数据类型对于获得高性能至关重要, 以下几个原则有助于做出更好的选择
- 更好的通常更好
一般情况下, 应该尽量使用可以正确存储数据的最小数据类型; 更小的数据类型通常更快, 因为它们占用更少的磁盘, 内存和 CPU 缓存, 并且处理时需要的 CPU 周期也更少
- 简单就好
简单的数据类型的操作通常需要更少的 CPU 周期
- 尽量避免 NULL
很多表通常包含可为 NULL 的列, 通常情况下最好指定列为 NOT NULL, 除非需要存储 NULL 值; 如果查询中包含可为 NULL 的列, 对 MySQL 来说更难优化, 因为可为 NULL 的列使得索引, 索引统计, 值比较都更复杂, 对 MySQL 的列会使用更多的空间, 在 MySQL 里也需要特殊处理

下一步是选择具体类型, 第一步需要确定合适的大类型, 当相同大类型的不同子类型有时也有一些特殊的行为和属性; 例如, DATETIME 和 TIMESTAMP 列都可以存储相同类型的数据: 日期和时间, 精确到秒; 然而 TIMESTAMP 只使用 DATETIME 一半的存储空间, 并且会根据时区变化, 具有特殊的自动更新功能; 另一方面, TIMESTAMP 允许的时间范围要小很多

##### 整数类型
有两种类型的数字: 整数 (whole number) 和实数 (real number); 如果存储整数, 可以使用这几种整数类型: TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT, 分别使用 8, 16, 24, 32, 64 位存储空间; 整数类型可选 UNSIGNED 属性, 表示不允许负值; MySQL 可以为整数类型指定宽度, 例如 INT(11), 对大多数应用这是没有意义的, 它不会限制值的合法范围, 只是规定 MySQL 的一些交互工具用来显示字符的个数, 对于存储和计算来说, INT(1) 和 INT(20) 是相同的

##### 实数类型
实数是带有小数部分的数字, 然而它们不只是为了存储小数部分, 也可以使用 DECIMAL 存储比 BIGINT 还大的整数; MySQL 既支持精确类型 (DECIMAL), 也支持不精确类型 (FALOT, DOUBLE)  
浮点类型在存储同样范围的值时, 通常比 DECIMAL 使用更少的空间; FLOAT 使用 4 个字节, DOUBLE 使用 8 个字节, 相比 FLOAT 有更高的精度和更大的范围; 和整数类型一样, 能选择的只是存储类型, MySQL 使用 DOUBLE 作为内部浮点计算的类型

##### 字符串类型
###### VARCHAR 和 CHAR 类型
VARCHAR 和 CHAR 是两种最主要的字符串类型, 这些值如何存储在内存和磁盘中, 这和存储引擎的具体实现有关; 以下假定使用的是 InnoDB 和 MyISAM 存储引擎
- VARCHAR
VARCHAR 用于存储可变长字符串, 是最常见的字符串数据类型, 它比定长类型更节省空间, 因为它仅使用必要的空间; VARCHAR 需要使用 1 到 2 个额外字节记录字符串的长度
但是由于行是变长的, 在 UPDATE 时可能使行变得比原来更长, 这就导致需要做额外的工作, 如果一个行占用的空间增长, 并且在页内没有更多的空间可以存储, 在这种情况下, 不同存储引擎的处理方式是不一样的; MyISAM 会将行拆成不同的片段存储, InnoDB 则需要分裂页来使行放进页内
所以在字符串列的最大长度比平均长度大很多时, 并且更新很少时, 使用 VARCHAR 类型是合适的
- CHAR
CHAR 类型是定长的, MySQL 总是根据定义的字符串长度分配足够的空间, 多余的空间使用空格填充; CHAR 类型适合存储定长且长更新的值

与 VARCHAR 和 CHAR 类似的类型还有 BINARY 和 VARBINARY, 它们存储的是二进制字符串, 二进制字符串跟常规字符串相似, 但是二进制字符串存储的是字节码而不是字符, 填充的是 `\0` (零字节) 而不是空格

###### BLOB 和 TEXT 类型
BLOB 和 TEXT 都是为存储很大的数据而设计的字符串数据类型, 分别采用二进制何人字符方式存储; 实际上它们分属两组不同的数据类型家族: 字符类型是 TINYTEXT, SMALLTEXT, TEXT, MEDIUMTEXT, LONGTEXT; 对应的二进制类型是 TINYBLOB, SMALLBLOB, BLOB, MEDIUMBLOB, LONGBLOB  
与其他类型不同, MySQL 把每个 BLOB 和 TEXT 值当作一个独立的对象处理, 存储引擎在存储时通常会做特殊处理; 当 BLOB 和 TEXT 值太大时, InnoDB 会使用专门的 "外部" 存储区域来进行存储, 此时每个值在行内需要 1 - 4 个字节存储一个指针, 然后在外部存储区域存储实际的值  
MySQL 对 BLOB 和 TEXT 列进行排序与其他类型不同, 它值对每个列的最前 max_sort_length 字节而不是整个字符串做排序; 如果只需要对前面小部分字符排序, 则可以减小 max_sort_length 的值, 或者使用 ORDER BY SUSTRING(culomn, length)

###### 使用枚举 (ENUM) 代理字符串类型
有时候可以使用枚举列代替常用的字符串类型, 枚举列可以把一些不重复的字符串存储成一个预定义的集合; MySQL 在存储枚举时非常紧凑, 会根据列表值的数据压缩到一个或两个字节中,MySQL 内部会将每个值在列表中的位置保存为整数, 并且在表的 `.frm` 文件中保存 "数字 - 字符串" 映射关系的 "查找表"  
如果使用数字作为 ENUM 枚举常量, 这种双重性很容易导致混乱, 建议必满这样做; 另外一个不同的地方是, 枚举字段是按照内部存储的整数而不是定义的字符串进行排序的, 一种绕过这种限制的方式按照需要来定义枚举列, 或者在查询中使用 FIELD() 函数显示指定排序顺序

###### 日期和时间类型
 
