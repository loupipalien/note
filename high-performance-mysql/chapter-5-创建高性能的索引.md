### 创建高性能的索引
索引是存储引擎用于快速找到记录的一种数据结构; 索引是对查询性能优化最有效的手段

#### 索引基础
索引可以包含一个或多个列的值, 如果索引包含多个列, 那么列的顺序也十分重要, 因为 MySQL 只能高效的使用索引的最左前缀列, 创建一个包含两个列的索引, 和创建两个只包含一列的索引是不同的

##### 索引的种类
在 MySQL 总索引是在存储引擎层而不是服务器层实现的, 所以没有统一的索引标准

###### B-Tree 索引
谈论索引是没有特别指明默认是指 B-Tree 索引, 它使用 B-Tree 数据结构来存储数据  
B-Tree 通常意味着所有的值都是按顺序存储的, 并且每个叶子页到根的距离是相同的; 下图是 InnoDB 的索引图示
![B-Tree树结构.png](http://ww1.sinaimg.cn/large/d8f31fa4gy1g81tfmvh2nj20qj0f8mxu.jpg)
B-Tree 索引能够加快访问数据的速度, 因为存储引擎不再需要进行全表扫描来获取需要的数据, 取而代之的是从索引的根节点开始进行搜索, 根节点的槽中存放了指向子节点的指针, 存储引擎根据这些指针向下层查找, 通过比较节点页的值和要查找的值可以找到合适的指针进入到下层子节点, 这些指针实际上定义了子节点页中值的上限和下限; 最终存储引擎要么找到对应的值, 要么该记录不存在  
可以使用 B-Tree 索引的查询类型, B-Tree 索引适用于全键值, 键值范围或键前缀查找; 其中键前缀查找值适用于根据最左前缀的查找; 之前所叙述的索引对以下类型查询有效
- 全值匹配
- 匹配最左前缀
- 匹配列前缀
- 匹配范围值
- 精确匹配某一列并范围匹配另一列
- 只访问索引的查询

因为索引树中的节点是有序的, 所以除了按值查找之外, 索引还可以用于查询中 ORDER BY 操作; 以下是 B-Tree 索引的一些限制
- 如果不是按照索引的最左列开始查找, 则无法使用索引
- 不能跳过索引中的列
- 如果查询中有某个列的范围查询, 则其右边所有列都无法使用索引优化查找

所以索引中列的顺序是很重要的, 这些限制都和索引中列的顺序有关

###### 哈希索引
哈希索引基于哈希表实现, 只有精确到匹配索引所有列的查询才有效; 对每一行数据, 存储引擎都会对所有的索引列计算一个哈希码, 这个哈希码是一个较小的值, 并且不同键值的行计算出来的哈希码也不一样, 哈希索引将所有的哈希码存储在索引中, 同时在哈希表中保存指向每个数据行的指针; 在 MySQL 中只有 Memory 引擎显式支持哈希索引; 哈希索引也有它的限制
- 哈希索引只包含哈希值和行指针, 而不存储字段值, 所以不能使用索引中的值来避免读取行
- 哈希索引数据并不是按照索引值顺序存储的, 所以也就无法用于排序
- 哈希索引也不支持部分索引列匹配查找, 因为哈希索引始终是使用索引列的全部内容来计算哈希值的
- 哈希索引只支持等值比较查询, 不支持非等值和范围查询
- 当有哈希冲突时, 存储引擎必须遍历链表中所有的行指针, 逐行进行比较, 直到找到所有符合条件的行
- 如果哈希冲突很多的话, 一些索引维护操作的代价也会很高

InnoDB 引擎有一个特殊的功能叫做 "自适应哈希索引 (adaptive hash index)"; 当 InnoDB 注意到某些索引值被使用的非常频繁时, 它会在内存中基于 B-Tree 索引之上再创建一个哈希索引, 这就让B-Tree 所以也具有哈希索引的一些优点, 但如非有必要建议关闭此功能

###### 空间数据索引 (R-Tree)
TODO
###### 全文索引
TODO
###### 其他索引类别
TODO

#### 索引的优点
