### 创建高性能的索引
索引是存储引擎用于快速找到记录的一种数据结构; 索引是对查询性能优化最有效的手段

#### 索引基础
索引可以包含一个或多个列的值, 如果索引包含多个列, 那么列的顺序也十分重要, 因为 MySQL 只能高效的使用索引的最左前缀列, 创建一个包含两个列的索引, 和创建两个只包含一列的索引是不同的

##### 索引的种类
在 MySQL 总索引是在存储引擎层而不是服务器层实现的, 所以没有统一的索引标准

###### B-Tree 索引
谈论索引是没有特别指明默认是指 B-Tree 索引, 它使用 B-Tree 数据结构来存储数据  
B-Tree 通常意味着所有的值都是按顺序存储的, 并且每个叶子页到根的距离是相同的; 下图是 InnoDB 的索引图示
![B-Tree树结构.png](http://ww1.sinaimg.cn/large/d8f31fa4gy1g81tfmvh2nj20qj0f8mxu.jpg)
B-Tree 索引能够加快访问数据的速度, 因为存储引擎不再需要进行全表扫描来获取需要的数据, 取而代之的是从索引的根节点开始进行搜索, 根节点的槽中存放了指向子节点的指针, 存储引擎根据这些指针向下层查找, 通过比较节点页的值和要查找的值可以找到合适的指针进入到下层子节点, 这些指针实际上定义了子节点页中值的上限和下限; 最终存储引擎要么找到对应的值, 要么该记录不存在  
可以使用 B-Tree 索引的查询类型, B-Tree 索引适用于全键值, 键值范围或键前缀查找; 其中键前缀查找值适用于根据最左前缀的查找; 之前所叙述的索引对以下类型查询有效
- 全值匹配
- 匹配最左前缀
- 匹配列前缀
- 匹配范围值
- 精确匹配某一列并范围匹配另一列
- 只访问索引的查询

因为索引树中的节点是有序的, 所以除了按值查找之外, 索引还可以用于查询中 ORDER BY 操作; 以下是 B-Tree 索引的一些限制
- 如果不是按照索引的最左列开始查找, 则无法使用索引
- 不能跳过索引中的列
- 如果查询中有某个列的范围查询, 则其右边所有列都无法使用索引优化查找

所以索引中列的顺序是很重要的, 这些限制都和索引中列的顺序有关

###### 哈希索引
哈希索引基于哈希表实现, 只有精确到匹配索引所有列的查询才有效; 对每一行数据, 存储引擎都会对所有的索引列计算一个哈希码, 这个哈希码是一个较小的值, 并且不同键值的行计算出来的哈希码也不一样, 哈希索引将所有的哈希码存储在索引中, 同时在哈希表中保存指向每个数据行的指针; 在 MySQL 中只有 Memory 引擎显式支持哈希索引; 哈希索引也有它的限制
- 哈希索引只包含哈希值和行指针, 而不存储字段值, 所以不能使用索引中的值来避免读取行
- 哈希索引数据并不是按照索引值顺序存储的, 所以也就无法用于排序
- 哈希索引也不支持部分索引列匹配查找, 因为哈希索引始终是使用索引列的全部内容来计算哈希值的
- 哈希索引只支持等值比较查询, 不支持非等值和范围查询
- 当有哈希冲突时, 存储引擎必须遍历链表中所有的行指针, 逐行进行比较, 直到找到所有符合条件的行
- 如果哈希冲突很多的话, 一些索引维护操作的代价也会很高

InnoDB 引擎有一个特殊的功能叫做 "自适应哈希索引 (adaptive hash index)"; 当 InnoDB 注意到某些索引值被使用的非常频繁时, 它会在内存中基于 B-Tree 索引之上再创建一个哈希索引, 这就让B-Tree 所以也具有哈希索引的一些优点, 但如非有必要建议关闭此功能

###### 空间数据索引 (R-Tree)
TODO
###### 全文索引
TODO
###### 其他索引类别
TODO

#### 索引的优点
索引可以让服务器快速定位到表的指定位置, 但是这并不是索引唯一的作用, 到目前位置可以看到, 根据创建索引的数据结构不同, 索引也有一些其他的附加作用; 总结下来索引有以下三个优点
- 索引大大减少了服务器需要扫描的数据量
- 索引可以帮助服务器避免排序和临时表
- 索引可以将随机 I/O 变为顺序 I/O

Lahdenmaki 和 Leach 介绍了一种如何评价一个索引是否适合某个查询的 "三星系统": 索引将相关的记录放在一起则获得一星, 如果索引中的数据顺序和查找中的排序顺序一致则获得二星, 如果索引中的列包含了查询中需要的全部列则获得三星

#### 高性能的索引策略

##### 独立的列
一些查询不当的使用索引, 或者使得 MySQL 无法使用已有的索引; 如果查询中的列不是独立的, 则 MySQL 就不会使用索引, "独立的列" 是指索引列不能是表达式中的一部分, 也不是能是函数的参数; 例如以下这个查询无法使用 `actor_id` 列的索引
```Sql
SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
```
WHERE 表达式其实等价于 `actor_id = 4`, 但是 MySQL 无法自动解析这个方程式

##### 前缀索引和索引选择性
有时候需要索引很长的字符列, 这会让索引变得大且慢, 一个策略是之前提到的模拟哈希索引; 另一个策略是索引这个字段开始的部分字段, 这样可以大大节约索引空间, 从而提高索引效率; 但这样也会降低索引的选择性, 索引的选择性是指, 不重复的索引值 (也称之为基数, cardinality) 和数据表的记录总数 (#T) 的比值, 范围从 1/#T 到 1 之间; 索引的选择性越高则查询效率越高, 选择性高的索引可以让 MySQL 在查找时过滤掉更多的行, 唯一索引的选择性是 1, 这时最好的索引选择性, 性能也是最好的  
一般情况下, 某个列前缀的选择性也是足够高, 足以满足查询性能; 对于 BLOB, TEXT 或者很长的 VARCHAR 类型的列, 必须使用前缀索引的, 因为 MySQL 不允许索引这些列的完整长度  
前缀所以是一种能让索引更小, 更快的有效办法, 但另一方面也有其缺点: MySQL 无法使用前缀索引做 ORDER BY 或 GROUP BY, 也无法使用前缀索引做覆盖扫描

##### 多列索引
在多个列上建立独立的单例索引大部分情况了下并不能提高 MySQL 的查询性能, MySQL 5. 版本引入了一种叫 "索引合并" 的策略, 一定程度上可以使用表上的多个单列索引来定位指定的行; 索引合并策略有时候是一种优化的结果, 但实际上更多时候说明了表上的索引建的很糟糕
- 当出现服务器对多个索引做相交操作 (通常有多个 AND 条件), 通常意味着需要一个包含多有相关列的多列索引, 而不是多独立的单列索引
- 当服务器需要对多个索引做联合操作时 (通常有多个 OR 条件), 通常需要耗费大量 CPU 和内存资源在算法的缓存, 排序和合并操作上; 特别是当其中有些索引的选择性并不高, 需要合并扫描返回的大量数据的时候
- 更重要的是, 优化器不会把这些计算到 "查询成本" 中, 优化器之关系随机页面读取, 这会使得查询的策划给你本被 "低估", 导致该执行计划还不如直接走全表扫描, 这样做不但会消耗更多的 CPU 和内存资源, 还可能会影响查询的并发性, 但如果是单独运行这样的查询则往往会忽略对并发性的影响; 通常来说, 还不如像在 MySQL 以往版本中, 将查询改写成 UNION 的方式往往会更好

##### 选择合适的索引列顺序
在一个多列 B-Tree 索引中, 索引类的顺序意味着索引首先按照最左列进行排序, 其次是第二列, 等等; 所以索引可以按照升序或者降序进行扫描, 以满足精确符合列顺序的 ORDER BY, GROUP BY 和 DISTINCT 等子句的查询需求  
当不需要考虑排序和分组时, 将选择性最高的列放在前面通常是很好的, 这时候索引的作用知识用于优化 WHERE 条件的查找

##### 聚簇索引
聚簇索引并不是一种但密度的索引类型, 而是一种数据存储方式; 具体的细节依赖于器实现方式, 但 InnoDB 的聚簇索引实际上在同一个结构中保存了 B-Tree 索引和数据行  
当表有聚簇索引时, 它的数据行实际上存放在索引的叶子页中; 术语 "聚簇" 表示数据行和相邻的键值紧凑的存储在一起; 因为无法同时把数据行存放在两个不同的地方, 所以一个表只能有一个聚簇索引 (不过, 覆盖索引可以模拟多个聚簇索引的情况)  
因为是存储引擎负责实现索引, 因此不是所有的存储引擎都支持聚簇索引, 以下介绍的都为 InnoDB 实现的聚簇索引; 下图展示了聚簇索引中的记录是如何存放的, 叶子也包含了行的全部数据, 但节点页只包含了索引项
![Image]()  
如果没有定义主键, InnoDB 会选择一个唯一的非空索引代替, 如果没有这样的索引, InnoDB 会隐式定义一个主键来作为聚簇索引; InnoDB 只聚集在同一个页面中的记录, 包含相邻键值的页面可能会相聚甚远  
聚簇索引有一些重要的优点
- 可以把相关数据保存在一起; 例如查询电子邮箱时, 可以根据用户的 ID 来聚集数据, 这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件, 如果没有聚簇索引则每封邮件都可能导致一次磁盘 I/O
- 数据访问更快, 聚簇索引将索引和数据保存在同一个 B-Tree 中, 因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快
- 使用覆盖索引扫描的查询可以直接使页节点中的主键值

如果设计表和查询时能充分利用上面的优点, 就能极大的提升性能, 同时聚簇索引也有一些缺点
- 聚簇索引最大限度的提高了 I/O 密集型应用的性能, 但如果数据全部都放在内存中, 则访问顺序就没有那么重要了, 聚簇索引也就没什么优势了
- 插入速度严重依赖于插入顺序; 按照主键的顺序插入是加载数据到 InnoDB 表中速度最快的方式, 但如果不是按照主键顺序加载数据, 那么在加载完成后最好使用 OPTIMIZE TABLE 命令重新组织一下表
- 基于聚簇索引的表在插入新行, 或者主键被更新导致需要移动行的时候, 可能面临 "页分裂" 的问题; 当行的主键值要求必须将这一行插入到某个已满的页中时, 存储引擎会将该页分裂成两个页面来容纳改该行, 这就是一次页分裂操作, 页分裂操作会导致占用更多的磁盘空间
- 聚簇索引可能导致全表扫面变慢, 尤其是行比较稀疏, 或者由于页分裂导致数据存储不连续的时候
- 二级索引 (非聚簇索引) 可能比想象的要更大, 因为二级索引的叶子节点包含了引用行的主键列 (即二级索引叶子节点保存的不是指向行的物理位置的指针, 而是行的主键值), 这就意味着通过二级索引查找行, 存储引擎需要找到二级索引的叶子节点获得对应的主键值, 然后根据这个值去聚簇索引中查找到对应的行, 这里做了重复的工作: 两次 B-Tree 树查找而不是一次

###### InnoDB 和 MyISAM 的数据分布对比
TODO
###### 在 InnoDB 表中按主键顺序插入行
TODO

#### 覆盖索引
如果一个索引包含 (或者说覆盖) 所有需要查询的字段的值, 就称之为 "覆盖索引"; 覆盖索引是非常有用的工具, 在以下的场景中能够极大的提高性能
- 索引条目通常远小于数据行大小, 所以如果只需要读取索引, 那么 MySQL 就会极大的减少数据访问量,
- 因为索引是按照列值顺序存储的 (至少在单个也内是如此), 所以对于 I/O 密集型的范围查询会比随机从磁盘读取每一行数据的 I/O 要少的多
-  一些存储引擎如 MyISAM 在内存中只缓存索引, 数据则依赖与操作系统来缓存, 因为要访问数据需要一次系统调用
- 由于 InnoDB 的聚簇索引, 覆盖索引对 InnoDB 表特别有用; InnoDB 的二级索引在叶子节点中保存了行的主键值, 所以如果二级主键能够覆盖查询, 则可以避免主键索引的二次查询

不是所有类型索引都可以成为覆盖索引, 覆盖索引必须要存储索引列的值, 而哈希索引等不存存储索引列的值, 所以 MySQL 只能使用 B-Tree 索引做覆盖索引

##### 使用索引扫描来做排序
MySQL 有两种方式可以生成有序的结果, 通过排序操作, 或者按照索引顺序扫描, 如果 EXPLIAN 出来的 "type" 列的值为 "index", 则说明 MySQL 使用索引扫描来做排序 (不要和 Extra 列混淆了)  
扫描索引本身是很快的, 因为只需从一条索引记录移到到紧接着的下一条记录; 但是如果索引不能覆盖查询所需的全部列, 那就不得不每扫描一条索引记录就都回表查询一次对应的行, 这基本上都是随机 I/O, 因此按索引顺序读取数据的速度通常要比顺序低全表扫描慢, 尤其是在 I/O 密集型的工作负载时  
只有当索引的里顺序和 ORDER BY 子句的顺序完全一致, 并且所有列的排序方向 (倒序或正序) 都一样时, MySQL 才能使用索引引来对结果做排序, 如果查询需要关联多张表, 则只当 ORDER BY 子句引用的字段全部为第一个表时, 才能使用索引做排序, ORDER BY 子句和查询型查询的限制是一样的: 需要满足索引的最左前缀的要求, 否则 MySQL 都需要执行排序操作, 而无法利用索引排序

##### 压缩 (前缀压缩) 索引
MyISAM 使用前缀压缩来减少索引的大小, 从而让更多的索引可以放入内存中, 这在某些情况下能极大的提高性能, 但压缩块使用更少的空间, 代价是某些操作可能更慢, 因为每个值的压缩前缀都依赖前面的值, MyISAM 查找是无法在索引块使用二分查找而只能从头开始扫描

##### 冗余和重复索引
MySQL 允许在相同列上创建多个索引, MySQL 也需要单独维护重复的索引, 并且优化器在优化查询时也需要逐个的进行考虑, 这会影响到性能; 重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引, 应该避免这种情况的发生, 发现后应立即移除  
冗余索引和重复索引有一些不同, 如果创建了索引 (A,B), 再创建索引 (A) 就是冗余索引, 因为这只是前一个索引的前缀索引, 因此 (A,B) 索引可以当作索引 (A) 来使用 (这种冗余只是对 B-Tree 索引来说的)

##### 未使用的索引
除了冗余索引和重复索引, 可能还有有一些永远不用的索引, 这样的索引完全是累赘, 可以删除

##### 索引和锁
索引可以让查询锁住更少的行, 如果查询从不访问哪些不需要的行, 那么就会锁定更少的行, 从两个方面来看这对性能都有好处; 虽然 InnoDB 的行锁效率很高, 内存使用的也很少, 但是锁定行的时候仍然会带来额外开销, 其次锁定超过需要的行会增加锁争用并减少并发性  
InnoDB 只有在访问行的时候才会对其加锁, 而索引能够减少 InnoDB 访问的行数, 从而减少锁的数量; 但这只当 InnoDB 在存储引擎层能够过滤掉所有不需要的行时才有效, 如果索引无法过滤掉无效的行, 那么 InnoDB 检索到数据并放回给服务器层后,  MySQL 服务器才能应用 WHERE 子句, 这时已经无法避免锁定行了: InnoDB 已经锁住了这些行, 到适当的时候才释放, 在 MySQL 5.1 及以后版本后, InnoDB 可以在服务器层过滤行后就释放锁, 但是在早期的版本中, InnoDB 只有在事务提交后才能释放锁

#### 索引案例学习
TODO
#### 维护索引和表
TODO
#### 总结
TODO
