### 分区表

#### 分区表
对用户来说, 分区表是一个独立的逻辑表, 但是底层由多个物理子表组成, 实现分区的代码实际上是对一组底层表的句柄对象的封装; 对分区表的请求, 都会通过句柄对象转化成对存储引擎的接口调用; 所以分区表对于客户端来说是透明的, 但是从底层的文件系统来看就可以发现每个分区表都有一个使用 `#` 分隔命名的表文件   
MySQL 实现分区表的方式是对底层的封装, 这意味着索引也是按照分区的子表定义的, 而没有全局索引; 分区的一个主要目的是将数据按照一个较粗的粒度分在不同的表中, 这样做可以将相关的数据存放在一起; 在下面的场景中, 分区可以起到非常大的作用
- 表非常大以至于无法全部都放在内存中
- 分区表的数据更容易维护
- 分区表的数据可以分布在不同的物理设备上
- 可以使用分区表来避免某些特殊的瓶颈
- 可以单独备份和恢复某个分区

##### 分区表的原理
如前所述, 分区表由多个相关的底层实现, 这些底层实现也是由句柄对象 (Handler object) 表示, 所以也可以直接访问各个分区; 存储引擎管理分区的各个底层表和管理普通表是一样的 (所有底层表都必须使用相同的存储引擎), 分区表的索引知识在各个底层表上各自加上一个完全相同的索引; 从存储引擎的角度来看, 底层表和一个普通的表没有任何不同, 存储引擎3也无须知道这是一个普通的表还是一个分区表的一个分区; 分区表上的操作按照下面操作逻辑进行
- SELECT 查询
当查询一个分区表的时候, 分区层先打开并锁住所有的底层表, 优化器先判断是否可以过滤部分分区, 然后再调用对应的存储引擎接口访问各个分区的数据
- INSERT 操作
当写入一条记录时, 分区层先打开并锁住所有的底层表, 然后确定哪个分区接收这条记录, 再将记录写入对应的底层表
- DELETE 操作
当删除一条记录时, 分区层先打开并锁住所有的底层表, 然后确定数据的对应分区, 最后对相应底层表进行删除操作
- UPDATE 操作
当更新一条记录时, 分区层先打开并锁住所有的底层表, MySQL 先确定需要更新的记录在哪个区, 然后取出数据并更新, 再判断更新后的数据应该放在哪个分区, 最后对底层表进行写入操作, 并对原数据所在的底层表进行删除操作

##### 分区表的类型
MySQL 支持多种分区表, 使用最多的是根据范围进行分区, 每个分区存储落在某个范围的记录, 分区表达式可以是列, 也可以是包含列的表达式; 除此之外, 还有一些其他的分区技术, 包括按键值进行分区, 使用数据函数进行分区等

##### 如何使用分区表
在数据量超大的时候, B-Tree 索引就无法起作用了; 除非是索引覆盖查询, 否则数据库服务器需要根据索引扫描的结果回表, 查询所有符合条件的记录, 如果数据量巨大, 这将产生大量随机 I/O, 随之数据库的响应时间也将大到不可接受的程度; 另外索引维护 (磁盘空间, I/O 操作) 的代价也非常高  
为了保证大数据量的可扩展性, 一般有以下两个策略
- 全量扫描数据, 不要任何索引
可以使用简单的分区方式存放表, 不要任何索引, 根据分区鞥带规则大致定位需要的数据位置, 只要能够使用 WHERE 条件将需要的数据限制在少数分区中, 则效率是很高的
- 索引数据, 比你高分离热点
如果数据有明显的 "热点", 而且除了这部分数据,其他数据很少被访问到, 那么可以将这部分热点数据单独放在一个分区中, 让这个分区的数据能够有机会都缓存在内存中; 这样查询就可以值访问一个很小的分区表, 能够使用索引, 也能够有效的使用缓存

##### 什么情况下会出问题
以上介绍的两个策略都基于两个非常重要的假设: 查询都能够过滤掉很多分区, 分区本身并不会带来很多额外的代价; 而事实证明, 这两个假设在以下情况时会有一些问题
- NULL 值会使分区过滤无效
- 分区列和索引列不匹配
- 选择分区鞥带成本可能很高
- 打开并锁住所有底层表的成本可能很高
- 维护分区的成本可能很高

##### 查询优化
分区最大的优点就是优化器可以根据分区函数来过滤一些分区, 根据粗粒度 "索引" 的优势, 通过分区过滤通常可以让查询扫描更少的数据; 在访问分区表时最重要的一点是要在 WHERE 条件中带入分区列, 有时候看似多于也要带上, 这样可以让优化器能够过滤掉无须访问的分区; 如果没有这个条件, MySQL 就需要让对应存储引擎访问这个表的所有分区, 如果表非常大的话, 就可能会非常慢

##### 合并表
TODO

#### 视图
MySQL 5.0 版本之后开始引入视图, 视图本身是一个虚拟表, 不存放任何数据; 在使用 SQL 语句访问视图的时候, 它返回的数据是 MySQL 从其他表中生成的; 视图和表是在同一个命名空间, MySQL 在很多地方对于视图的表是同样对待的, 不过视图和表也有不同, 如不能对视图创建触发器等  
以下演示视图是如何工作的, 创建一个视图如下
```SQL
CREATE VIEW Oceania AS
SELECT * FROM Country WHERE Contient = 'Oceania'
WITH CHECH OPTION;

SELECT Code, Name FROM Oceania WHERE Contient = 'Australia';
```
实现视图最简单的方法是将 SELECT 语句的结果存放到临时表中, 当需要访问视图的时候, 直接访问这个临时表就可以了; 下面是使用临时表来模拟视图的方法, 这里临时表的名字是为了演示用的
```SQL
CREATE TEMPORARY TABLE TMP_Oceania_123 AS
SELECT * FROM Country WHERE Contient = 'Oceania';

SELECT Code, Name FROM TMP_Oceania_123 WHERE Name = 'Australia';
```
这样做会有明显的性能问题, 优化器也很难优化这个临时表上的查询, 实现视图更好的方法是, 重写含有视图的查询, 将视图定义的 SQL 直接包含进查询的 SQL 中; 例如
```SQL
SELECT Code, Name FROM Country WHERE Contient = 'Oceania' AND Name = 'Australia';
```
MySQL 可以使用这两种办法中的任何一种来处理视图, 这两种算法分别称为合并算法 (MERGE) 和临时表算法 (TEMPTABLE), 如何可能尽可能的使用合并算法; MySQL 甚至可以嵌套的定义视图, 也就是在一个视图之上再定义另一个视图; 在 EXPLIAN EXTENDED 之后使用 SHOW WARNINGS 来查看使用视图的查询重写后的结果; 如果是采用临时表算法实现的视图, EXPLIAN 中会显示为派生表 (DERIVED)  
![Image]()  
如果视图中包含 GROUP BY, DISTINCT, 任何聚合函数, UNION, 子查询等, 只要无法在原表记录和视图记录中建立一一映射的场景中, MySQL 都将使用临时表算法来实现视图  
视图的实现算法是视图本身的属性, 和作用在视图上的查询语句无关; 例如可以为一个基于简单查询的视图指定使用临时表算法
```SQL
CREATE ALGORITM=TEMPTABLE VIEW v1 AS SELECT * FROM sakila.actor;
```
实现该视图的 SQL 本身并不需要临时表, 但基于该视图无论执行什么样鞥带查询, 视图都会生成一个临时表

##### 可更新视图
可更新视图是指通过更新这个视图来更新视图涉及的相关表, 只要指定了合适的条件, 就可以更新删除甚至向视图中写入数据; 例如
```SQL
UPDATE Oceania SET Population = Population * 1.1 WHERE Name = 'Australia';
```
如果视图定义中包含了 GROUP BY, UNION, 聚合函数, 以及其他一些特殊情况, 就不能被更新了; 更新视图的查询也可以是一个关联语句, 但是有一个限制：被更新的列必须来自同一个表中; 另外, 所有使用临时表算法实现的视图都无法被更新; 定义视图使用的 CHECK OPTION 子句, 表示任何通过视图更新的行都必须符合视图本身的 WHERE 条件定义

##### 视图对性能的影响
MySQL 中某些情况下视图可以帮助提升性能; 比如使用视图实现基于列的权限控制, 却不需要真正的在系统中创建列权限, 因此没有额外的开销  
使用临时表算法实现的视图, 在某些时候性能会很糟糕; MySQL 以递归的方式执行这类视图, 先会执行外层查询, 即使外层查询优化器将其优化得很好, 但是 MySQL 优化器可能无法像其他的数据库那样做更多的内外结合优化, 外层查询额 WHERE 条件无法 "下推" 到构建视图的临时表的查询中, 临时表也无法建立索引

##### 视图的限制
- MySQL 不支持物化视图
- MySQL 视图不支持索引
- MySQL 不会保存视图定义的原始 SQL 语句

#### 外键u约束
InnoDB 是目前 MySQL 中唯一支持外键的内置存储引擎; 使用外键是有成本的, 比如外键通常都要求每次在修改数据时要在另一张表中多执行一次查询操作, 虽然 InnoDB 强制使用了外键索引, 但是还是无法消除这种约束检查的开销; 如果外键的选择性很低, 则会导致一个非常大且选择性很低的索引

#### 在 MySQL 内存存储代码
MySQL 允许通过触发器, 存储过程, 函数的形式来存储代码, 还可以在定时任务中存放代码, 这个定时任务也被称为 "事件"; 这四种存储代码都使用特殊的 SQL 语句扩展, 包含了很多过程处理语法, 如循环或分支等; 不同类型的存储代码的主要区别在于其执行的上下文, 也就是器输入和输出, 存储过程和存储函数可以接收参数然后返回值, 但触发器和事件不可以  
MySQL 使用存储代码的优点如下
- 它在服务器内部执行, 离数据最近, 可以节省带宽和网络延迟
- 这是一种代码重用
- 可以简化代码的维护和版本更新
- 可以帮助提升安全, 如更细粒度的权限控制
- 服务器可以缓存存储过程额执行计划, 这对于需要反复调试的过程, 会大大降低消耗
- 因为是在服务端部署的, 所以备份和维护都可以在服务端完成, 所以存储程序的维护工作会很简单
- 他可以在应用开发和数据库开发人员之间更好的分工

MySQL 使用存储代码的缺点如下
- MySQL 没有提供很好的开发和调试工具, 开发起来更难
- 较之应用代码, 存储代码效率要稍微差些
- 存储代码可能会给应用程序代码的部署带来额外的复杂性
- 因为存储程序都部署在服务器内, 所以可能有安全隐患
- 存储过程会给数据库服务器增加额外的压力
- MySQL 没有选项可以控制存储程序的资源消耗
- 存储代码在 MySQL 中的实现也有很多限制
- 调试 MySQL 的存储过程是以减困难的事情
- 它和基于语句的二进制日志复制合作得不好

##### 存储过程和函数
TODO
##### 触发器
TODO
##### 事件
TODO
##### 在存储程序中保留注释
TODO

#### 游标
MySQL 在服务端提供只读的, 单向的游标, 而且只能在存储过程或者更底层的客户端 API 中使用; 因为 MySQL 游标中指向的对象都是存储在临时表中而不是实际查询到的数据; 所以 MySQL 游标总是只读的, 可以逐行读取查询结果

#### 绑定变量
从 MySQL4.1 版本开始, 就执行服务器段的绑定变量 (prepared statement), 这大大提高了客户端和服务端数据传输的效率; 绑定变量的 SQL, 使用问号标记可以接收参数的位置; 客户端发送语句后服务端解析并存储这个 SQL 语句的部分执行计划, 返回给客户端一个 SQL 语句处理句柄, 以后每次执行这类查询客户端都指定使用这个句柄; 当真正需要执行具体查询的时候, 则使用具体值代替这些问号; 例如
```SQL
INSERT INTO tbl(col1, col2, col3) VALUES (?, ?, ?);
```
可以通过向服务器发送各个问号的取值和这个 SQL 的句柄来执行一个具体的查询; 反复使用这样的方式执行具体的查询是绑定变量的优势所在; MySQL 在使用绑定变量的时候可以更高效地执行大量的重复语句
- 阿紫服务端只需要解析一次 SQL 语句
- 在服务端某些优化器的工作只需要执行一次, 因为它会缓存一部分的执行计划
- 以二进制的方式只发送参数和句柄, 比每次都发送 ASCII 码文本效率更高
- 仅仅是参数而不是整个语句需要发送到服务器端, 所以网络开销会更小
- MySQL 在存储参数的时候, 直接将其放到缓存中, 不需要在内存中多次复制

绑定变量相对也更安全, 无须在应用程序中处理转义, 一来更加简单, 二来也大大减少了 SQL 注入和攻击的风险

##### 绑定变量的优化
TODO
##### SQL 接口的绑定变量
在 4.1 和更新的版本中, MySQL 支持了 SQL 接口的绑定变量; 不使用二进制传输一些也可以直接以 SQL 的方式使用绑定变量
```SQL
SET @sql := 'SELECT actor_id, first_name, last_name FROM sakila.actor WHERE first_name = ?';
PREPARE stmt_fetch_actor FROM @sql;
SET @actor_name := 'Penelope';
EXECUTE stmt_fetch_actor USING @actor_name;
```
##### 绑定变量的限制
TODO

#### 用户自定义函数
TODO
#### 插件
TODO

#### 字符集和校对
字符集是指一种二进制编码到某类字符符号的映射; 校对是指一组用于某个字符集的排序规则

##### MySQL 如何使用字符集
每种字符集都可能有多种校对规则, 并且都有一个默认的校对规则; 每个校对规则都是针对某个特定的字符集的, 和其他的字符集没有关系; 校对规则和字符集总是一起使用的, 这样的组合通常也统称为一个字符集  
MySQL 的设置可以分为两类: 创建对象时的默认值, 在服务器和客户端通信时的设置

###### 创建对象时的默认设置
MySQL 服务器有默认的字符集和校对规则, 每个数据库也有自己的默认值, 每个表也有自己的默认值; 这是一个逐层继承的默认设置, 最终最靠底层的默认设置将影响创建的对象; 这些默认值至上而下的告诉 MySQL 应该使用什么字符集来存储某个列; 在阶梯的每一层, 都可以指定一个热顶的字符集或者让服务器使用它的默认值
- 创建数据库时, 可以指定服务器上的 character_set_server 设置来设定该数据库的默认字符集
- 创建表时, 将根据数据库的字符集设置指定这个表的字符集设置
- 创建列时, 将根据表的设置指定列的字符集设置

###### 服务器和客户端通信时的设置
当服务器和客户端通信的时候, 它们可能使用不同的字符集, 这时服务器端将必须进行必要的翻译转换工作
- 服务器端总是假设客户端按照 character_set_client 设置的字符来传输数据和 SQL 语句
- 当服务器收到客户端的 SQL 语句时, 它先将器转换成字符集 character_set_connection, 它还使用这个设置来决定如何将数据转换成字符串
- 当服务器端返回数据或者错误信息给客户端时, 它会将其转换成 character_set_result

###### MySQL 如何比较两个字符串的大小
如果比较的两个字符串的字符集不同,  MySQL 会将其先转换成同一个字符集再进行比较; 如果两个字符集不兼容, 则会抛出错误

##### 选择字符集和校对规则
MySQL 4.1 和之后的版本支持很多的字符集和校对规则, 包括支持使用 Unicode 编码的多字节 UTF-8 字符集： 可以使用 `SHOW CHARACTERSET` 和 `SHOW COLLATION` 来查看 MySQL 支持的字符集和校对规则  
对于校对规则通常需要考虑的一个问题时, 是否以大小写敏感的方式比较字符串, 或者以字符串编码的二进制来比较大小; 它们对应的校对规则的前缀分别是 `_cs, _ci, _bin`, 根据需要很容易选择; 大小写敏感和二进制校对规则的不同之处在于, 二进制校对规则直接使用字符的字节进行比较, 而大小写敏感的校对规则在多字节字符集时, 有更复杂的比较规则

##### 字符集和校对规则如何影响查询
某些字符集和校对规则可能会需要更多的 CPU 操作, 可能会消耗更多的内存和存储空间, 甚至还会影响到索引的使用, 所以在选择字符集的使用, 也有一些需要注意的地方  
不同字符集和校对规则之间的转换可能会带来额外的系统开销, 只有当排序查询要求的字符集和服务器数据的字符集相同的时候, 才能使用索引进行排序; 索引根据数据列的校对规则进行排序, 如果希望使用别的校对规则进行排序, 那么 MySQL 就需要使用文件排序  
为了能够适应各种字符集, 包括客户端字符集在查询中显式指定的字符集, MySQL 会在需要的时候进行字符集的转换; 当使用两个字符集不同的列来关联两个表的时候, MySQL 会尝试转换其中一个列的字符集, 这和在数据列外面封装一个函数一样, 会让 MySQL 无法使用这个列上的索引; 可以在 `EXPLIAN EXTENDED` 后使用 `SHOW WARNINGS` 来查看 MySQL 是如何处理的

#### 全文索引
通过数值比较, 范围过滤等就可以完成绝大多数我们需要的查询了, 但是如果希望通过关键字的匹配来进行查询匹配, 那么就需要基于相似度的查询, 而不是原来的精确数值比较; 全文索引就是为这种场景设计的

TODO

#### 分布式 (XA) 事务
存储引擎的事务特性能够保证在存储引擎级别实现 ACID, 而分布式事务则让存储引擎级别的 ACID 可以扩展到数据库层面, 甚至可以扩展到多个数据库之间, 这需要通过两阶段提交实现; MySQL 5.0 和更新版本的数据库已经开始支持 XA 事务了  
XA 事务中需要一个事务协调器来保证所有的事务参与者都完成了准备工作 (第一阶段); 如果协调器收到所有的参与者都准备阿红的消息, 就会告诉所有的事务可以提交了 (第二阶段); MySQL 在这个 XA 事务过程中扮演一个参与者的角色, 而不是协调者  
实际上, 在 MySQL 中有两种 XA 事务; 一方面, MySQL 可以参与到外部的分布式事务中; 另一方面, 还可以通过 XA 事务来协调存储引擎和二进制日志   

##### 内存 XA 事务
MySQL 本身的插件式架构导致在其内部需要使用 XA 事务; MySQL 中各个存储引擎是完全独立的, 彼此不知道对方的存在, 所以在一个跨存储引擎的事务就需要一个外部的协调者; 如果不适用 XA 协议, 当在某个存储提交过程中发生系统崩溃, 就会破坏事务的特性

##### 外部 XA 事务
MySQL 能够作为参与者完成一个外部的分布式事务; 但它对 XA 协议支持并不完整; 例如, XA 协议要求在一个事务中的多个连接可以做关联, 但目前的 MySQL 版本还不能支持

#### 查询缓存
很多数据库产品都能够缓存查询的执行计划, 对于相同类型的 SQL 就可以跳过 SQL 解析和执行计划生成阶段; MySQL 在某些场景下也可以实现, 但是 MySQL 还有另一种不同的缓存类型：缓存完整的 SELECT 查询结果

##### MySQL 如何判断缓存命中
MySQL 判断缓存命中方法很简单: 缓存存放在一个引用表中, 通过一个哈希值引用, 这个哈希值包括了如下因素: 即查询本身, 当前要查询的数据库, 客户端协议的版本等; 但是当查询语句中包含任何的不确定函数, 那么在查询缓存中是不可能找到缓存结果的, 例如包含 NOW() 等函数时  
MySQL 的查询缓存在很多时候可以提升查询性能, 但有时候也会带来更多额外的消耗
- 读查询在开始之前必须先检查是否命中缓存
- 如果这个读查询可以被缓存, 那么在完成执行之后, MySQL 若发现查询缓存中没有这个查询会将其结果存入查询缓存中, 这会带啦额外的系统开销
- 这对写操作也有影响, 因为当向某个表写入数据的时候, MySQL 必须将对应表的所有缓存都设置失效; 如果查询缓存非常大或者碎片很多, 这个操作会带来很大的系统消耗

##### 查询缓存如何使用内存
查询缓存是完全存储在内存中的

##### 什么情况下查询缓存能发挥作用
并不是什么情况下查询缓存都会提高系统性能的, 缓存和失效都会带来额外的消耗, 所以只有当缓存带来的资源节约大于其本身的资源消耗时才会给系统带来性能提升

##### 如何配置和维护查询缓存
TODO

##### InnoDB 和查询缓存
因为 InnoDB 有自己的 MVCC 机制, 所以相比其他存储引擎, InnoDB 和查询缓存的交互要更加复杂

##### 通用查询缓存优化
- 用多个小表代替一个大表对查询缓存有好处
- 批量写入时只需要做一次缓存失效, 所以相比单条写入效率要好
- 因为缓存空间太大, 在过期操作的时候有可能会导致服务器僵死
- 无法在数据库或者数据表级别控制查询缓存, 但是可以通过 SQL_CACHE 或 SQL_NO_CACHE 来控制某个 SELECT 语句是否需要进行缓存
- 对于写密集型应用来说, 禁用查询缓存可能会提高系统的性能
- 因为对互斥信号量的竞争, 有时直接关闭查询缓存对读密集型的应用也会有好处

##### 查询缓存的替代方案
TODO

#### 总结
TODO
