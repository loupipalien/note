### 分区表

#### 分区表
对用户来说, 分区表是一个独立的逻辑表, 但是底层由多个物理子表组成, 实现分区的代码实际上是对一组底层表的句柄对象的封装; 对分区表的请求, 都会通过句柄对象转化成对存储引擎的接口调用; 所以分区表对于客户端来说是透明的, 但是从底层的文件系统来看就可以发现每个分区表都有一个使用 `#` 分隔命名的表文件   
MySQL 实现分区表的方式是对底层的封装, 这意味着索引也是按照分区的子表定义的, 而没有全局索引; 分区的一个主要目的是将数据按照一个较粗的粒度分在不同的表中, 这样做可以将相关的数据存放在一起; 在下面的场景中, 分区可以起到非常大的作用
- 表非常大以至于无法全部都放在内存中
- 分区表的数据更容易维护
- 分区表的数据可以分布在不同的物理设备上
- 可以使用分区表来避免某些特殊的瓶颈
- 可以单独备份和恢复某个分区

##### 分区表的原理
如前所述, 分区表由多个相关的底层实现, 这些底层实现也是由句柄对象 (Handler object) 表示, 所以也可以直接访问各个分区; 存储引擎管理分区的各个底层表和管理普通表是一样的 (所有底层表都必须使用相同的存储引擎), 分区表的索引知识在各个底层表上各自加上一个完全相同的索引; 从存储引擎的角度来看, 底层表和一个普通的表没有任何不同, 存储引擎3也无须知道这是一个普通的表还是一个分区表的一个分区; 分区表上的操作按照下面操作逻辑进行
- SELECT 查询
当查询一个分区表的时候, 分区层先打开并锁住所有的底层表, 优化器先判断是否可以过滤部分分区, 然后再调用对应的存储引擎接口访问各个分区的数据
- INSERT 操作
当写入一条记录时, 分区层先打开并锁住所有的底层表, 然后确定哪个分区接收这条记录, 再将记录写入对应的底层表
- DELETE 操作
当删除一条记录时, 分区层先打开并锁住所有的底层表, 然后确定数据的对应分区, 最后对相应底层表进行删除操作
- UPDATE 操作
当更新一条记录时, 分区层先打开并锁住所有的底层表, MySQL 先确定需要更新的记录在哪个区, 然后取出数据并更新, 再判断更新后的数据应该放在哪个分区, 最后对底层表进行写入操作, 并对原数据所在的底层表进行删除操作

##### 分区表的类型
MySQL 支持多种分区表, 使用最多的是根据范围进行分区, 每个分区存储落在某个范围的记录, 分区表达式可以是列, 也可以是包含列的表达式; 除此之外, 还有一些其他的分区技术, 包括按键值进行分区, 使用数据函数进行分区等

##### 如何使用分区表
在数据量超大的时候, B-Tree 索引就无法起作用了; 除非是索引覆盖查询, 否则数据库服务器需要根据索引扫描的结果回表, 查询所有符合条件的记录, 如果数据量巨大, 这将产生大量随机 I/O, 随之数据库的响应时间也将大到不可接受的程度; 另外索引维护 (磁盘空间, I/O 操作) 的代价也非常高  
为了保证大数据量的可扩展性, 一般有以下两个策略
- 全量扫描数据, 不要任何索引
可以使用简单的分区方式存放表, 不要任何索引, 根据分区鞥带规则大致定位需要的数据位置, 只要能够使用 WHERE 条件将需要的数据限制在少数分区中, 则效率是很高的
- 索引数据, 比你高分离热点
如果数据有明显的 "热点", 而且除了这部分数据,其他数据很少被访问到, 那么可以将这部分热点数据单独放在一个分区中, 让这个分区的数据能够有机会都缓存在内存中; 这样查询就可以值访问一个很小的分区表, 能够使用索引, 也能够有效的使用缓存

##### 什么情况下会出问题
以上介绍的两个策略都基于两个非常重要的假设: 查询都能够过滤掉很多分区, 分区本身并不会带来很多额外的代价; 而事实证明, 这两个假设在以下情况时会有一些问题
- NULL 值会使分区过滤无效
- 分区列和索引列不匹配
- 选择分区鞥带成本可能很高
- 打开并锁住所有底层表的成本可能很高
- 维护分区的成本可能很高

##### 查询优化
分区最大的优点就是优化器可以根据分区函数来过滤一些分区, 根据粗粒度 "索引" 的优势, 通过分区过滤通常可以让查询扫描更少的数据; 在访问分区表时最重要的一点是要在 WHERE 条件中带入分区列, 有时候看似多于也要带上, 这样可以让优化器能够过滤掉无须访问的分区; 如果没有这个条件, MySQL 就需要让对应存储引擎访问这个表的所有分区, 如果表非常大的话, 就可能会非常慢

##### 合并表
TODO

#### 视图
MySQL 5.0 版本之后开始引入视图, 视图本身是一个虚拟表, 不存放任何数据; 在使用 SQL 语句访问视图的时候, 它返回的数据是 MySQL 从其他表中生成的; 视图和表是在同一个命名空间, MySQL 在很多地方对于视图的表是同样对待的, 不过视图和表也有不同, 如不能对视图创建触发器等  
以下演示视图是如何工作的, 创建一个视图如下
```SQL
CREATE VIEW Oceania AS
SELECT * FROM Country WHERE Contient = 'Oceania'
WITH CHECH OPTION;

SELECT Code, Name FROM Oceania WHERE Contient = 'Australia';
```
实现视图最简单的方法是将 SELECT 语句的结果存放到临时表中, 当需要访问视图的时候, 直接访问这个临时表就可以了; 下面是使用临时表来模拟视图的方法, 这里临时表的名字是为了演示用的
```SQL
CREATE TEMPORARY TABLE TMP_Oceania_123 AS
SELECT * FROM Country WHERE Contient = 'Oceania';

SELECT Code, Name FROM TMP_Oceania_123 WHERE Name = 'Australia';
```
这样做会有明显的性能问题, 优化器也很难优化这个临时表上的查询, 实现视图更好的方法是, 重写含有视图的查询, 将视图定义的 SQL 直接包含进查询的 SQL 中; 例如
```SQL
SELECT Code, Name FROM Country WHERE Contient = 'Oceania' AND Name = 'Australia';
```
